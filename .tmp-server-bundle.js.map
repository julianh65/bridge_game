{
  "version": 3,
  "sources": ["packages/engine/src/config.ts", "packages/shared/src/hex.ts", "packages/shared/src/rng.ts", "packages/engine/src/board-generation.ts", "packages/engine/src/content/cards/age1.ts", "packages/engine/src/content/cards/age2.ts", "packages/engine/src/content/cards/age3.ts", "packages/engine/src/content/cards/faction.ts", "packages/engine/src/content/cards/power.ts", "packages/engine/src/content/cards/starter.ts", "packages/engine/src/content/cards/index.ts", "packages/engine/src/content/market-decks.ts", "packages/engine/src/content/power-decks.ts", "packages/engine/src/content/starter-decks.ts", "packages/engine/src/board.ts", "packages/engine/src/modifiers.ts", "packages/engine/src/player-flags.ts", "packages/engine/src/cards.ts", "packages/engine/src/events.ts", "packages/engine/src/faction-passives.ts", "packages/engine/src/units.ts", "packages/engine/src/setup-flow.ts", "packages/engine/src/rewards.ts", "packages/engine/src/champions.ts", "packages/engine/src/round-flow.ts", "packages/engine/src/deploy-utils.ts", "packages/engine/src/card-effects.ts", "packages/engine/src/combat.ts", "packages/engine/src/action-flow.ts", "packages/engine/src/market.ts", "packages/engine/src/engine.ts", "packages/engine/src/view.ts", "apps/server/src/server.ts"],
  "sourcesContent": ["import type { GameConfig } from \"./types\";\n\nexport const DEFAULT_CONFIG: GameConfig = {\n  MAX_MANA: 6,\n  START_GOLD: 4,\n  BASE_INCOME: 1,\n  HAND_LIMIT: 10,\n  CHAMPION_LIMIT: 4,\n  ROUNDS_MAX: 10,\n  VP_TO_WIN: 10,\n  ACTION_REVEAL_DURATION_MS: 2400,\n  ACTION_REVEAL_HIGHLIGHT_PAUSE_MS: 1200,\n  MARKET_ROLLOFF_DURATION_MS: 1500,\n  COMBAT_ROLL_LOCK_MS: 650,\n  COMBAT_ROLL_ASSIGN_MS: 1300,\n  COMBAT_ROLL_DONE_MS: 1900,\n  COMBAT_AUTO_CLOSE_MS: 2200,\n  basicActionFactionOrder: [\"bastion\", \"veil\", \"aerial\", \"prospect\", \"cipher\", \"gatewright\"],\n  boardRadiusByPlayerCount: {\n    2: 3,\n    3: 4,\n    4: 4,\n    5: 4,\n    6: 4\n  },\n  tileCountsByPlayerCount: {\n    2: { mines: 3, forges: 1, center: 1, randomBridges: 7 },\n    3: { mines: 4, forges: 2, center: 1, randomBridges: 7 },\n    4: { mines: 5, forges: 2, center: 1, randomBridges: 10 },\n    5: { mines: 6, forges: 2, center: 1, randomBridges: 10 },\n    6: { mines: 7, forges: 3, center: 1, randomBridges: 10 }\n  },\n  capitalSlotsByPlayerCount: {\n    2: [\"3,0\", \"-3,0\"],\n    3: [\"4,0\", \"-4,4\", \"0,-4\"],\n    4: [\"4,-1\", \"-1,4\", \"-4,1\", \"1,-4\"],\n    5: [\"-2,4\", \"-4,1\", \"1,-4\", \"2,2\", \"4,-2\"],\n    6: [\"4,0\", \"0,4\", \"-4,4\", \"-4,0\", \"0,-4\", \"4,-4\"]\n  },\n  boardGenerationRules: {\n    minDistanceFromCapital: 2,\n    forgeDistanceFromCenter: [2, 3],\n    mineDistanceFromCenter: [2],\n    homeMineDistanceFromCapital: 2,\n    homeMineMinDistanceFromOtherCapitals: 2,\n    minForgeSpacing: 0,\n    minMineSpacing: 0,\n    maxAttempts: 50,\n    topK: 5,\n    mineValueWeights: [\n      { value: 3, weight: 25 },\n      { value: 4, weight: 35 },\n      { value: 5, weight: 25 },\n      { value: 6, weight: 10 },\n      { value: 7, weight: 5 }\n    ]\n  },\n  ageByRound: {\n    1: \"I\",\n    2: \"I\",\n    3: \"I\",\n    4: \"II\",\n    5: \"II\",\n    6: \"II\",\n    7: \"II\",\n    8: \"III\",\n    9: \"III\",\n    10: \"III\"\n  },\n  marketPreviewByRound: {\n    1: 0,\n    2: 1,\n    3: 1,\n    4: 0,\n    5: 1,\n    6: 2,\n    7: 2,\n    8: 0,\n    9: 0,\n    10: 0\n  },\n  freeStartingCardPool: [\n    \"age1.quick_march\",\n    \"age1.prospecting\",\n    \"age1.trade_caravan\",\n    \"age1.temporary_bridge\",\n    \"age1.patch_up\",\n    \"age1.quick_study\"\n  ]\n};\n", "export type AxialCoord = {\n  q: number;\n  r: number;\n};\n\nexport type HexKey = string;\nexport type EdgeKey = string;\n\nconst DIRS: AxialCoord[] = [\n  { q: 1, r: 0 },\n  { q: 1, r: -1 },\n  { q: 0, r: -1 },\n  { q: -1, r: 0 },\n  { q: -1, r: 1 },\n  { q: 0, r: 1 }\n];\n\nconst assertInteger = (value: number, label: string) => {\n  if (!Number.isInteger(value)) {\n    throw new Error(`${label} must be an integer`);\n  }\n};\n\nexport const toHexKey = (q: number, r: number): HexKey => {\n  assertInteger(q, \"q\");\n  assertInteger(r, \"r\");\n  return `${q},${r}`;\n};\n\nexport const parseHexKey = (key: HexKey): AxialCoord => {\n  const parts = key.split(\",\");\n  if (parts.length !== 2) {\n    throw new Error(\"HexKey must be in the form q,r\");\n  }\n  const q = Number(parts[0]);\n  const r = Number(parts[1]);\n  if (!Number.isInteger(q) || !Number.isInteger(r)) {\n    throw new Error(\"HexKey coordinates must be integers\");\n  }\n  return { q, r };\n};\n\nexport const addAxial = (a: AxialCoord, b: AxialCoord): AxialCoord => ({\n  q: a.q + b.q,\n  r: a.r + b.r\n});\n\nexport const axialDistance = (a: AxialCoord, b: AxialCoord): number => {\n  const dq = a.q - b.q;\n  const dr = a.r - b.r;\n  return (Math.abs(dq) + Math.abs(dr) + Math.abs(dq + dr)) / 2;\n};\n\nexport const areAdjacent = (a: AxialCoord, b: AxialCoord): boolean => {\n  return axialDistance(a, b) === 1;\n};\n\nexport const axialNeighbors = (coord: AxialCoord): AxialCoord[] => {\n  return DIRS.map((dir) => addAxial(coord, dir));\n};\n\nexport const neighborHexKeys = (key: HexKey): HexKey[] => {\n  const coord = parseHexKey(key);\n  return axialNeighbors(coord).map((neighbor) => toHexKey(neighbor.q, neighbor.r));\n};\n\nexport const generateAxialCoords = (radius: number): AxialCoord[] => {\n  assertInteger(radius, \"radius\");\n  if (radius < 0) {\n    throw new Error(\"radius must be >= 0\");\n  }\n\n  const coords: AxialCoord[] = [];\n  for (let q = -radius; q <= radius; q += 1) {\n    const rMin = Math.max(-radius, -q - radius);\n    const rMax = Math.min(radius, -q + radius);\n    for (let r = rMin; r <= rMax; r += 1) {\n      coords.push({ q, r });\n    }\n  }\n  return coords;\n};\n\nexport const generateHexKeys = (radius: number): HexKey[] => {\n  return generateAxialCoords(radius).map((coord) => toHexKey(coord.q, coord.r));\n};\n\nexport const compareHexKeys = (a: HexKey, b: HexKey): number => {\n  const ac = parseHexKey(a);\n  const bc = parseHexKey(b);\n  if (ac.q !== bc.q) {\n    return ac.q - bc.q;\n  }\n  return ac.r - bc.r;\n};\n\nexport const canonicalEdgeKey = (a: HexKey, b: HexKey): EdgeKey => {\n  if (a === b) {\n    throw new Error(\"Edge endpoints must be distinct\");\n  }\n  const [first, second] = compareHexKeys(a, b) <= 0 ? [a, b] : [b, a];\n  return `${first}|${second}`;\n};\n\nexport const parseEdgeKey = (edge: EdgeKey): [HexKey, HexKey] => {\n  const parts = edge.split(\"|\");\n  if (parts.length !== 2) {\n    throw new Error(\"EdgeKey must be in the form hexA|hexB\");\n  }\n  return [parts[0], parts[1]];\n};\n", "const UINT32_RANGE = 0x100000000;\n\nexport type RNGState = { state: number };\nexport type RNGOutput<T> = { value: T; next: RNGState };\n\nexport function createRngState(seed: number): RNGState {\n  if (!Number.isFinite(seed) || !Number.isInteger(seed)) {\n    throw new Error(\"seed must be a finite integer\");\n  }\n\n  return { state: seed >>> 0 };\n}\n\nexport function nextUint32(rng: RNGState): RNGOutput<number> {\n  const nextState = (rng.state + 0x6d2b79f5) >>> 0;\n  let t = nextState;\n  t = Math.imul(t ^ (t >>> 15), t | 1);\n  t ^= t + Math.imul(t ^ (t >>> 7), t | 61);\n  const value = (t ^ (t >>> 14)) >>> 0;\n\n  return { value, next: { state: nextState } };\n}\n\nexport function randInt(\n  rng: RNGState,\n  min: number,\n  max: number\n): RNGOutput<number> {\n  if (!Number.isInteger(min) || !Number.isInteger(max)) {\n    throw new Error(\"randInt bounds must be integers\");\n  }\n  if (max < min) {\n    throw new Error(\"randInt max must be >= min\");\n  }\n\n  const range = max - min + 1;\n  if (range <= 0 || range > UINT32_RANGE) {\n    throw new Error(\"randInt range out of bounds\");\n  }\n\n  const threshold = UINT32_RANGE - (UINT32_RANGE % range);\n  let state = rng;\n  while (true) {\n    const { value, next } = nextUint32(state);\n    if (value < threshold) {\n      return { value: min + (value % range), next };\n    }\n    state = next;\n  }\n}\n\nexport function rollDie(rng: RNGState, sides = 6): RNGOutput<number> {\n  if (!Number.isInteger(sides) || sides <= 0) {\n    throw new Error(\"rollDie sides must be a positive integer\");\n  }\n\n  return randInt(rng, 1, sides);\n}\n\nexport function shuffle<T>(rng: RNGState, items: readonly T[]): RNGOutput<T[]> {\n  const result = items.slice();\n  let state = rng;\n  for (let i = result.length - 1; i > 0; i -= 1) {\n    const { value: j, next } = randInt(state, 0, i);\n    const temp = result[i];\n    result[i] = result[j];\n    result[j] = temp;\n    state = next;\n  }\n\n  return { value: result, next: state };\n}\n", "import {\n  axialDistance,\n  canonicalEdgeKey,\n  compareHexKeys,\n  generateHexKeys,\n  neighborHexKeys,\n  parseHexKey,\n  randInt,\n  shuffle,\n  toHexKey,\n  type RNGState\n} from \"@bridgefront/shared\";\n\nimport type {\n  BoardGenerationRules,\n  BoardState,\n  EdgeKey,\n  HexKey,\n  HexState,\n  TileType\n} from \"./types\";\n\nconst createHexState = (key: HexKey, tile: TileType): HexState => ({\n  key,\n  tile,\n  occupants: {}\n});\n\nexport const createBaseBoard = (radius: number): BoardState => {\n  const hexes: Record<HexKey, HexState> = {};\n  for (const key of generateHexKeys(radius)) {\n    const tile: TileType = key === \"0,0\" ? \"center\" : \"normal\";\n    hexes[key] = createHexState(key, tile);\n  }\n\n  return {\n    radius,\n    hexes,\n    bridges: {},\n    units: {}\n  };\n};\n\nexport const getCapitalSlots = (\n  playerCount: number,\n  radius: number,\n  capitalSlotsByPlayerCount?: Record<number, HexKey[]>\n): HexKey[] => {\n  if (!Number.isInteger(playerCount)) {\n    throw new Error(\"playerCount must be an integer\");\n  }\n  if (playerCount < 2 || playerCount > 6) {\n    throw new Error(\"playerCount must be between 2 and 6\");\n  }\n  if (!Number.isInteger(radius) || radius <= 0) {\n    throw new Error(\"radius must be a positive integer\");\n  }\n\n  const override = capitalSlotsByPlayerCount?.[playerCount];\n  if (override && override.length > 0) {\n    if (override.length !== playerCount) {\n      throw new Error(\"capital slot override length must match player count\");\n    }\n    const unique = new Set(override);\n    if (unique.size !== override.length) {\n      throw new Error(\"capital slot override contains duplicates\");\n    }\n    for (const key of override) {\n      const dist = axialDistance(parseHexKey(key), { q: 0, r: 0 });\n      if (dist > radius) {\n        throw new Error(`capital slot ${key} is outside board radius`);\n      }\n    }\n    return [...override];\n  }\n\n  const corners = [\n    toHexKey(radius, 0),\n    toHexKey(0, radius),\n    toHexKey(-radius, radius),\n    toHexKey(-radius, 0),\n    toHexKey(0, -radius),\n    toHexKey(radius, -radius)\n  ];\n\n  switch (playerCount) {\n    case 2:\n      return [corners[0], corners[3]];\n    case 3:\n      return [corners[0], corners[2], corners[4]];\n    case 4:\n      return [corners[0], corners[1], corners[3], corners[4]];\n    case 5:\n      return corners.slice(0, 5);\n    case 6:\n      return corners;\n    default:\n      throw new Error(\"unsupported player count\");\n  }\n};\n\ntype SpecialTilePlacementResult = {\n  board: BoardState;\n  rngState: RNGState;\n  forgeKeys: HexKey[];\n  homeMineKeys: HexKey[];\n  mineKeys: HexKey[];\n};\n\ntype SpecialTilePlacementOptions = {\n  capitalHexes: HexKey[];\n  forgeCount: number;\n  mineCount: number;\n  rules: BoardGenerationRules;\n};\n\ntype RandomBridgePlacementOptions = {\n  capitalHexes: HexKey[];\n  count: number;\n  rules: BoardGenerationRules;\n};\n\ntype RandomBridgePlacementResult = {\n  board: BoardState;\n  rngState: RNGState;\n  edgeKeys: EdgeKey[];\n};\n\ntype EdgeCandidate = {\n  key: EdgeKey;\n  from: HexKey;\n  to: HexKey;\n};\n\nconst CENTER_KEY = \"0,0\";\nconst CAPITAL_BALANCE_WEIGHT = 4;\nconst GLOBAL_SPREAD_WEIGHT = 3;\nconst BRIDGE_SPECIAL_WEIGHT = 4;\nconst BRIDGE_SPREAD_WEIGHT = 3;\n\nconst cloneBoard = (board: BoardState): BoardState => {\n  const hexes: Record<HexKey, HexState> = {};\n  for (const [key, hex] of Object.entries(board.hexes)) {\n    hexes[key] = {\n      ...hex,\n      occupants: { ...hex.occupants }\n    };\n  }\n\n  return {\n    ...board,\n    hexes,\n    bridges: { ...board.bridges },\n    units: { ...board.units }\n  };\n};\n\nconst distanceBetweenKeys = (a: HexKey, b: HexKey): number => {\n  return axialDistance(parseHexKey(a), parseHexKey(b));\n};\n\nconst minDistanceToSet = (key: HexKey, others: HexKey[]): number => {\n  if (others.length === 0) {\n    return Number.POSITIVE_INFINITY;\n  }\n  let min = Number.POSITIVE_INFINITY;\n  for (const other of others) {\n    const dist = distanceBetweenKeys(key, other);\n    if (dist < min) {\n      min = dist;\n    }\n  }\n  return min;\n};\n\nconst minDistanceToSetForEdge = (edge: EdgeCandidate, others: HexKey[]): number => {\n  return Math.min(minDistanceToSet(edge.from, others), minDistanceToSet(edge.to, others));\n};\n\nconst listSpecialHexKeys = (board: BoardState): HexKey[] => {\n  return Object.values(board.hexes)\n    .filter((hex) => hex.tile !== \"normal\")\n    .map((hex) => hex.key);\n};\n\nconst listBridgeAnchorKeys = (bridges: BoardState[\"bridges\"]): HexKey[] => {\n  const anchors = new Set<HexKey>();\n  for (const bridge of Object.values(bridges)) {\n    anchors.add(bridge.from);\n    anchors.add(bridge.to);\n  }\n  return [...anchors];\n};\n\nconst scoreBridgeCandidate = (\n  edge: EdgeCandidate,\n  specialKeys: HexKey[],\n  bridgeAnchors: HexKey[]\n): number => {\n  const specialDistance = minDistanceToSetForEdge(edge, specialKeys);\n  const bridgeDistance = minDistanceToSetForEdge(edge, bridgeAnchors);\n  const specialScore = Number.isFinite(specialDistance)\n    ? specialDistance * BRIDGE_SPECIAL_WEIGHT\n    : 0;\n  const bridgeScore = Number.isFinite(bridgeDistance)\n    ? bridgeDistance * BRIDGE_SPREAD_WEIGHT\n    : 0;\n  return specialScore + bridgeScore;\n};\n\nconst closestCapitalIndex = (key: HexKey, capitalHexes: HexKey[]): number => {\n  let bestIndex = 0;\n  let bestDistance = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < capitalHexes.length; i += 1) {\n    const dist = distanceBetweenKeys(key, capitalHexes[i]);\n    if (dist < bestDistance) {\n      bestDistance = dist;\n      bestIndex = i;\n      continue;\n    }\n    if (dist === bestDistance) {\n      if (compareHexKeys(capitalHexes[i], capitalHexes[bestIndex]) < 0) {\n        bestIndex = i;\n      }\n    }\n  }\n  return bestIndex;\n};\n\nconst countByClosestCapital = (keys: HexKey[], capitalHexes: HexKey[]): number[] => {\n  const counts = Array.from({ length: capitalHexes.length }, () => 0);\n  for (const key of keys) {\n    const index = closestCapitalIndex(key, capitalHexes);\n    counts[index] += 1;\n  }\n  return counts;\n};\n\nconst respectsMinDistance = (key: HexKey, others: HexKey[], minDistance: number): boolean => {\n  if (minDistance <= 0) {\n    return true;\n  }\n  for (const other of others) {\n    if (distanceBetweenKeys(key, other) < minDistance) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isEligibleForSpecialTile = (\n  key: HexKey,\n  board: BoardState,\n  capitalSet: Set<HexKey>,\n  rules: BoardGenerationRules\n): boolean => {\n  const hex = board.hexes[key];\n  if (!hex) {\n    return false;\n  }\n  if (hex.tile !== \"normal\") {\n    return false;\n  }\n  if (key === CENTER_KEY || capitalSet.has(key)) {\n    return false;\n  }\n\n  for (const capital of capitalSet) {\n    if (distanceBetweenKeys(key, capital) < rules.minDistanceFromCapital) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nconst scoreCandidate = (\n  candidate: HexKey,\n  sameTypeKeys: HexKey[],\n  capitalHexes: HexKey[],\n  capitalCounts?: number[],\n  allSpecialKeys: HexKey[] = []\n): number => {\n  const minSameType = minDistanceToSet(candidate, sameTypeKeys);\n  const minAnySpecial = minDistanceToSet(candidate, allSpecialKeys);\n  const minToCapital = minDistanceToSet(candidate, capitalHexes);\n  const sameTypeScore = Number.isFinite(minSameType) ? minSameType * 10 : 1000;\n  const spreadScore = Number.isFinite(minAnySpecial) ? minAnySpecial * GLOBAL_SPREAD_WEIGHT : 0;\n  const capitalScore = Number.isFinite(minToCapital) ? minToCapital : 0;\n  const balancePenalty =\n    capitalCounts && capitalCounts.length > 0\n      ? capitalCounts[closestCapitalIndex(candidate, capitalHexes)] * CAPITAL_BALANCE_WEIGHT\n      : 0;\n  return sameTypeScore + spreadScore + capitalScore - balancePenalty;\n};\n\nconst chooseCandidate = (\n  rngState: RNGState,\n  candidates: HexKey[],\n  sameTypeKeys: HexKey[],\n  capitalHexes: HexKey[],\n  topK: number,\n  allSpecialKeys?: HexKey[]\n): { key: HexKey; rngState: RNGState } => {\n  const capitalCounts = countByClosestCapital(sameTypeKeys, capitalHexes);\n  const ranked = candidates\n    .map((key) => ({\n      key,\n      score: scoreCandidate(\n        key,\n        sameTypeKeys,\n        capitalHexes,\n        capitalCounts,\n        allSpecialKeys ?? sameTypeKeys\n      )\n    }))\n    .sort((a, b) => {\n      if (a.score !== b.score) {\n        return b.score - a.score;\n      }\n      return compareHexKeys(a.key, b.key);\n    });\n\n  const limit = Math.min(topK, ranked.length);\n  const { value: index, next } = randInt(rngState, 0, limit - 1);\n  return { key: ranked[index].key, rngState: next };\n};\n\nconst validateRules = (rules: BoardGenerationRules) => {\n  const ensureNonNegativeInt = (value: number, label: string) => {\n    if (!Number.isInteger(value) || value < 0) {\n      throw new Error(`${label} must be a non-negative integer`);\n    }\n  };\n\n  const ensurePositiveInt = (value: number, label: string) => {\n    if (!Number.isInteger(value) || value <= 0) {\n      throw new Error(`${label} must be a positive integer`);\n    }\n  };\n\n  ensureNonNegativeInt(rules.minDistanceFromCapital, \"minDistanceFromCapital\");\n  ensureNonNegativeInt(rules.homeMineDistanceFromCapital, \"homeMineDistanceFromCapital\");\n  ensureNonNegativeInt(\n    rules.homeMineMinDistanceFromOtherCapitals,\n    \"homeMineMinDistanceFromOtherCapitals\"\n  );\n  ensureNonNegativeInt(rules.minForgeSpacing, \"minForgeSpacing\");\n  ensureNonNegativeInt(rules.minMineSpacing, \"minMineSpacing\");\n  ensurePositiveInt(rules.maxAttempts, \"maxAttempts\");\n  ensurePositiveInt(rules.topK, \"topK\");\n\n  if (rules.forgeDistanceFromCenter.length === 0) {\n    throw new Error(\"forgeDistanceFromCenter must not be empty\");\n  }\n  if (rules.mineDistanceFromCenter.length === 0) {\n    throw new Error(\"mineDistanceFromCenter must not be empty\");\n  }\n\n  for (const distance of rules.forgeDistanceFromCenter) {\n    ensureNonNegativeInt(distance, \"forgeDistanceFromCenter entry\");\n  }\n  for (const distance of rules.mineDistanceFromCenter) {\n    ensureNonNegativeInt(distance, \"mineDistanceFromCenter entry\");\n  }\n\n  if (rules.mineValueWeights.length === 0) {\n    throw new Error(\"mineValueWeights must not be empty\");\n  }\n  for (const weight of rules.mineValueWeights) {\n    ensureNonNegativeInt(weight.value, \"mineValueWeights value\");\n    ensurePositiveInt(weight.weight, \"mineValueWeights weight\");\n  }\n};\n\nconst rollMineValue = (\n  rngState: RNGState,\n  weights: BoardGenerationRules[\"mineValueWeights\"]\n): { value: number; rngState: RNGState } => {\n  const totalWeight = weights.reduce((sum, entry) => sum + entry.weight, 0);\n  if (totalWeight <= 0) {\n    throw new Error(\"mineValueWeights must include a positive total weight\");\n  }\n\n  const { value: roll, next } = randInt(rngState, 1, totalWeight);\n  let running = 0;\n  for (const entry of weights) {\n    running += entry.weight;\n    if (roll <= running) {\n      return { value: entry.value, rngState: next };\n    }\n  }\n\n  return { value: weights[weights.length - 1].value, rngState: next };\n};\n\nexport const placeSpecialTiles = (\n  board: BoardState,\n  rngState: RNGState,\n  options: SpecialTilePlacementOptions\n): SpecialTilePlacementResult => {\n  const { capitalHexes, forgeCount, mineCount, rules } = options;\n  validateRules(rules);\n  const { maxAttempts, topK } = rules;\n\n  if (!Number.isInteger(forgeCount) || forgeCount < 0) {\n    throw new Error(\"forgeCount must be a non-negative integer\");\n  }\n  if (!Number.isInteger(mineCount) || mineCount < 0) {\n    throw new Error(\"mineCount must be a non-negative integer\");\n  }\n  if (mineCount < capitalHexes.length) {\n    throw new Error(\"mineCount must be >= number of capitals\");\n  }\n\n  const capitalSet = new Set(capitalHexes);\n  for (const capital of capitalHexes) {\n    if (!board.hexes[capital]) {\n      throw new Error(`capital hex ${capital} not on board`);\n    }\n  }\n\n  let state = rngState;\n  for (let attempt = 0; attempt < maxAttempts; attempt += 1) {\n    const working = cloneBoard(board);\n    const forgeKeys: HexKey[] = [];\n    const homeMineKeys: HexKey[] = [];\n    const mineKeys: HexKey[] = [];\n\n    const eligibleKeys = Object.keys(working.hexes)\n      .filter((key) => isEligibleForSpecialTile(key, working, capitalSet, rules))\n      .sort(compareHexKeys);\n\n    let placementFailed = false;\n    let rng = state;\n\n    for (let i = 0; i < forgeCount; i += 1) {\n      const remaining = eligibleKeys.filter((key) => {\n        if (!isEligibleForSpecialTile(key, working, capitalSet, rules)) {\n          return false;\n        }\n        const dist = distanceBetweenKeys(key, CENTER_KEY);\n        if (!rules.forgeDistanceFromCenter.includes(dist)) {\n          return false;\n        }\n        return respectsMinDistance(key, forgeKeys, rules.minForgeSpacing);\n      });\n      if (remaining.length === 0) {\n        placementFailed = true;\n        break;\n      }\n      const choice = chooseCandidate(rng, remaining, forgeKeys, capitalHexes, topK, forgeKeys);\n      rng = choice.rngState;\n      forgeKeys.push(choice.key);\n      working.hexes[choice.key] = {\n        ...working.hexes[choice.key],\n        tile: \"forge\"\n      };\n    }\n\n    if (placementFailed) {\n      state = rng;\n      continue;\n    }\n\n    const { value: capitalOrder, next: shuffledState } = shuffle(rng, capitalHexes);\n    rng = shuffledState;\n\n    for (const capital of capitalOrder) {\n      const candidates = eligibleKeys.filter((key) => {\n        if (!isEligibleForSpecialTile(key, working, capitalSet, rules)) {\n          return false;\n        }\n        if (distanceBetweenKeys(key, capital) !== rules.homeMineDistanceFromCapital) {\n          return false;\n        }\n        for (const other of capitalHexes) {\n          if (\n            other !== capital &&\n            distanceBetweenKeys(key, other) < rules.homeMineMinDistanceFromOtherCapitals\n          ) {\n            return false;\n          }\n        }\n        return respectsMinDistance(key, homeMineKeys, rules.minMineSpacing);\n      });\n\n      if (candidates.length === 0) {\n        placementFailed = true;\n        break;\n      }\n\n      const choice = chooseCandidate(\n        rng,\n        candidates,\n        homeMineKeys,\n        capitalHexes,\n        topK,\n        [...forgeKeys, ...homeMineKeys]\n      );\n      rng = choice.rngState;\n      homeMineKeys.push(choice.key);\n      working.hexes[choice.key] = {\n        ...working.hexes[choice.key],\n        tile: \"mine\"\n      };\n    }\n\n    if (placementFailed) {\n      state = rng;\n      continue;\n    }\n\n    const remainingMineCount = mineCount - homeMineKeys.length;\n    for (let i = 0; i < remainingMineCount; i += 1) {\n      const candidates = eligibleKeys.filter((key) => {\n        if (!isEligibleForSpecialTile(key, working, capitalSet, rules)) {\n          return false;\n        }\n        const dist = distanceBetweenKeys(key, CENTER_KEY);\n        if (!rules.mineDistanceFromCenter.includes(dist)) {\n          return false;\n        }\n        return respectsMinDistance(key, [...homeMineKeys, ...mineKeys], rules.minMineSpacing);\n      });\n\n      if (candidates.length === 0) {\n        placementFailed = true;\n        break;\n      }\n\n      const choice = chooseCandidate(\n        rng,\n        candidates,\n        [...homeMineKeys, ...mineKeys],\n        capitalHexes,\n        topK,\n        [...forgeKeys, ...homeMineKeys, ...mineKeys]\n      );\n      rng = choice.rngState;\n      mineKeys.push(choice.key);\n      working.hexes[choice.key] = {\n        ...working.hexes[choice.key],\n        tile: \"mine\"\n      };\n    }\n\n    if (placementFailed) {\n      state = rng;\n      continue;\n    }\n\n    const allMines = [...homeMineKeys, ...mineKeys];\n    for (const mine of allMines) {\n      const roll = rollMineValue(rng, rules.mineValueWeights);\n      rng = roll.rngState;\n      working.hexes[mine] = {\n        ...working.hexes[mine],\n        mineValue: roll.value\n      };\n    }\n\n    return {\n      board: working,\n      rngState: rng,\n      forgeKeys,\n      homeMineKeys,\n      mineKeys: allMines\n    };\n  }\n\n  throw new Error(\"Failed to place special tiles within maxAttempts\");\n};\n\nexport const placeRandomBridges = (\n  board: BoardState,\n  rngState: RNGState,\n  options: RandomBridgePlacementOptions\n): RandomBridgePlacementResult => {\n  const { capitalHexes, count, rules } = options;\n  if (!Number.isInteger(count) || count < 0) {\n    throw new Error(\"random bridge count must be a non-negative integer\");\n  }\n\n  const capitalSet = new Set(capitalHexes);\n  for (const capital of capitalHexes) {\n    if (!board.hexes[capital]) {\n      throw new Error(`capital hex ${capital} not on board`);\n    }\n  }\n\n  if (count === 0) {\n    return { board, rngState, edgeKeys: [] };\n  }\n\n  const seenEdges = new Set<EdgeKey>();\n  const candidates: EdgeCandidate[] = [];\n  for (const key of Object.keys(board.hexes)) {\n    const from = key as HexKey;\n    for (const neighbor of neighborHexKeys(from)) {\n      if (!board.hexes[neighbor]) {\n        continue;\n      }\n      if (from === CENTER_KEY || neighbor === CENTER_KEY) {\n        continue;\n      }\n      if (capitalSet.has(from) || capitalSet.has(neighbor)) {\n        continue;\n      }\n      const edgeKey = canonicalEdgeKey(from, neighbor);\n      if (seenEdges.has(edgeKey) || board.bridges[edgeKey]) {\n        continue;\n      }\n      seenEdges.add(edgeKey);\n      candidates.push({ key: edgeKey, from, to: neighbor });\n    }\n  }\n\n  const emptyCandidates = candidates.filter((edge) => {\n    const fromHex = board.hexes[edge.from];\n    const toHex = board.hexes[edge.to];\n    return fromHex?.tile === \"normal\" && toHex?.tile === \"normal\";\n  });\n  const candidatePool = emptyCandidates.length >= count ? emptyCandidates : candidates;\n\n  if (count > candidatePool.length) {\n    throw new Error(\"random bridge count exceeds available edges\");\n  }\n\n  const specialKeys = listSpecialHexKeys(board);\n  const baseAnchors = listBridgeAnchorKeys(board.bridges);\n  const anchorKeys = new Set(baseAnchors);\n  let next = rngState;\n  let remaining = [...candidatePool];\n  const selected: EdgeCandidate[] = [];\n  const topK = Math.max(1, rules.topK);\n\n  for (let i = 0; i < count; i += 1) {\n    const anchorList = Array.from(anchorKeys);\n    const ranked = remaining\n      .map((edge) => ({\n        edge,\n        score: scoreBridgeCandidate(edge, specialKeys, anchorList)\n      }))\n      .sort((a, b) => {\n        if (a.score !== b.score) {\n          return b.score - a.score;\n        }\n        return a.edge.key.localeCompare(b.edge.key);\n      });\n    const limit = Math.min(topK, ranked.length);\n    const { value: index, next: nextRng } = randInt(next, 0, limit - 1);\n    const chosen = ranked[index].edge;\n    next = nextRng;\n    selected.push(chosen);\n    anchorKeys.add(chosen.from);\n    anchorKeys.add(chosen.to);\n    remaining = remaining.filter((edge) => edge.key !== chosen.key);\n  }\n\n  const bridges = { ...board.bridges };\n  for (const edge of selected) {\n    bridges[edge.key] = {\n      key: edge.key,\n      from: edge.from,\n      to: edge.to\n    };\n  }\n\n  return {\n    board: { ...board, bridges },\n    rngState: next,\n    edgeKeys: selected.map((edge) => edge.key)\n  };\n};\n", "import type { CardDef } from \"./types\";\n\nexport const QUICK_MARCH: CardDef = {\n  id: \"age1.quick_march\",\n  name: \"Quick March\",\n  rulesText: \"Move 1 stack up to 2 hexes along Bridges.\",\n  type: \"Order\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 40,\n  burn: false,\n  targetSpec: {\n    kind: \"path\",\n    owner: \"self\",\n    maxDistance: 2,\n    requiresBridge: true\n  },\n  effects: [{ kind: \"moveStack\", maxDistance: 2 }]\n};\n\nexport const ROLL_OUT: CardDef = {\n  id: \"age1.roll_out\",\n  name: \"Roll Out\",\n  rulesText: \"Move up to 2 different stacks up to 1 hex along Bridges each.\",\n  type: \"Order\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 60,\n  burn: false,\n  targetSpec: {\n    kind: \"multiPath\",\n    owner: \"self\",\n    maxDistance: 1,\n    maxPaths: 2,\n    requiresBridge: true\n  },\n  effects: [{ kind: \"moveStacks\", maxDistance: 1 }]\n};\n\nexport const FLANK_STEP: CardDef = {\n  id: \"age1.flank_step\",\n  name: \"Flank Step\",\n  rulesText: \"Move 1 stack 1 hex ignoring Bridges.\",\n  type: \"Order\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 35,\n  burn: false,\n  targetSpec: {\n    kind: \"stack\",\n    owner: \"self\",\n    maxDistance: 1,\n    requiresBridge: false\n  },\n  effects: [{ kind: \"moveStack\", maxDistance: 1, requiresBridge: false }]\n};\n\nexport const EMERGENCY_EVAC: CardDef = {\n  id: \"age1.emergency_evac\",\n  name: \"Emergency Evac\",\n  rulesText: \"Move 1 friendly Champion to your Capital. Heal it 1 HP.\",\n  type: \"Order\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 45,\n  burn: false,\n  targetSpec: {\n    kind: \"champion\",\n    owner: \"self\"\n  },\n  effects: [{ kind: \"evacuateChampion\" }, { kind: \"healChampion\", amount: 1 }]\n};\n\nexport const COLUMN_ADVANCE: CardDef = {\n  id: \"age1.column_advance\",\n  name: \"Column Advance\",\n  rulesText:\n    \"Move 1 stack up to 3 hexes along Bridges; must stop if it enters any occupied hex.\",\n  type: \"Order\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 2 },\n  initiative: 55,\n  burn: false,\n  targetSpec: {\n    kind: \"path\",\n    owner: \"self\",\n    maxDistance: 3,\n    requiresBridge: true,\n    stopOnOccupied: true\n  },\n  effects: [{ kind: \"moveStack\", maxDistance: 3, stopOnOccupied: true }]\n};\n\nexport const PROSPECTING: CardDef = {\n  id: \"age1.prospecting\",\n  name: \"Prospecting\",\n  rulesText: \"Gain +2 gold. If you occupy a Mine, gain +3 gold instead.\",\n  type: \"Order\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 30,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"prospecting\", baseGold: 2, bonusIfMine: 1 }]\n};\n\nexport const TRADE_CARAVAN: CardDef = {\n  id: \"age1.trade_caravan\",\n  name: \"Trade Caravan\",\n  rulesText: \"Gain +3 gold.\",\n  type: \"Order\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 75,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"gainGold\", amount: 3 }]\n};\n\nexport const RECRUIT_DETACHMENT: CardDef = {\n  id: \"age1.recruit_detachment\",\n  name: \"Recruit Detachment\",\n  rulesText: \"Deploy 4 Forces to your Capital, OR 2 Forces to a hex you occupy.\",\n  type: \"Order\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 2, gold: 1 },\n  initiative: 45,\n  burn: false,\n  targetSpec: {\n    kind: \"choice\",\n    options: [\n      { kind: \"capital\" },\n      { kind: \"occupiedHex\", owner: \"self\" }\n    ]\n  },\n  effects: [{ kind: \"recruit\", capitalCount: 4, occupiedCount: 2 }]\n};\n\nexport const PAID_VOLUNTEERS: CardDef = {\n  id: \"age1.paid_volunteers\",\n  name: \"Paid Volunteers\",\n  rulesText: \"Deploy 4 Forces to your Capital.\",\n  type: \"Order\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 1, gold: 2 },\n  initiative: 65,\n  burn: false,\n  targetSpec: {\n    kind: \"choice\",\n    options: [{ kind: \"capital\" }]\n  },\n  effects: [{ kind: \"recruit\", capitalCount: 4 }]\n};\n\nexport const ESCORT_DETAIL: CardDef = {\n  id: \"age1.escort_detail\",\n  name: \"Escort Detail\",\n  rulesText: \"Deploy 2 Forces to a friendly Champion's hex.\",\n  type: \"Order\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 1, gold: 1 },\n  initiative: 35,\n  burn: false,\n  targetSpec: {\n    kind: \"champion\",\n    owner: \"self\"\n  },\n  effects: [{ kind: \"deployForces\", count: 2 }]\n};\n\nexport const NATIONAL_SERVICE: CardDef = {\n  id: \"age1.national_service\",\n  name: \"National Service\",\n  rulesText: \"Deploy 1 Force to your Capital.\",\n  type: \"Order\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 0, gold: 1 },\n  initiative: 55,\n  burn: false,\n  targetSpec: {\n    kind: \"choice\",\n    options: [{ kind: \"capital\" }]\n  },\n  effects: [{ kind: \"recruit\", capitalCount: 1 }]\n};\n\nexport const FRONTIER_CLAIM: CardDef = {\n  id: \"age1.frontier_claim\",\n  name: \"Frontier Claim\",\n  rulesText:\n    \"Deploy 4 Forces to an empty hex within distance 1 of your Capital (ignoring Bridges).\",\n  type: \"Order\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 2, gold: 2 },\n  initiative: 55,\n  burn: false,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"any\",\n    maxDistanceFromCapital: 1,\n    requiresEmpty: true,\n    allowCapital: false\n  },\n  effects: [{ kind: \"deployForces\", count: 4 }]\n};\n\nexport const SCAVENGERS_MARKET: CardDef = {\n  id: \"age1.scavengers_market\",\n  name: \"Scavenger's Market\",\n  rulesText: \"Gain +1 gold. Draw 1 card.\",\n  type: \"Order\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 50,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [\n    { kind: \"gainGold\", amount: 1 },\n    { kind: \"drawCards\", count: 1 }\n  ]\n};\n\nexport const TEMPORARY_BRIDGE: CardDef = {\n  id: \"age1.temporary_bridge\",\n  name: \"Temporary Bridge\",\n  rulesText:\n    \"Build 1 Bridge between any two adjacent hexes (no occupancy requirement). Destroy it in Cleanup.\",\n  type: \"Order\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 50,\n  burn: false,\n  targetSpec: {\n    kind: \"edge\",\n    anywhere: true\n  },\n  effects: [{ kind: \"buildBridge\", temporary: true }]\n};\n\nexport const SABOTAGE_BRIDGE: CardDef = {\n  id: \"age1.sabotage_bridge\",\n  name: \"Sabotage Bridge\",\n  rulesText: \"Destroy a Bridge adjacent to a hex you occupy.\",\n  type: \"Order\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 2 },\n  initiative: 65,\n  burn: false,\n  targetSpec: {\n    kind: \"edge\"\n  },\n  effects: [{ kind: \"destroyBridge\" }]\n};\n\nexport const BRIDGE_TRAP: CardDef = {\n  id: \"age1.bridge_trap\",\n  name: \"Bridge Trap\",\n  rulesText:\n    \"Choose a Bridge adjacent to a hex you occupy. The first enemy stack to cross it this round loses 1 Force (random).\",\n  type: \"Spell\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 55,\n  burn: false,\n  targetSpec: {\n    kind: \"edge\"\n  },\n  effects: [{ kind: \"trapBridge\" }]\n};\n\nexport const TUNNEL_NETWORK: CardDef = {\n  id: \"age1.tunnel_network\",\n  name: \"Tunnel Network\",\n  rulesText:\n    \"Your Capital is considered connected to the center by a Bridge until end of round. Burn.\",\n  type: \"Order\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 80,\n  burn: true,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"linkCapitalToCenter\" }]\n};\n\nexport const PATCH_UP: CardDef = {\n  id: \"age1.patch_up\",\n  name: \"Patch Up\",\n  rulesText:\n    \"Heal a friendly Champion anywhere 2. If it is in your Capital, heal 4 instead.\",\n  type: \"Order\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 75,\n  burn: false,\n  targetSpec: {\n    kind: \"champion\",\n    owner: \"self\"\n  },\n  effects: [{ kind: \"patchUp\", baseHeal: 2, capitalBonus: 2 }]\n};\n\nexport const BATTLE_CRY: CardDef = {\n  id: \"age1.battle_cry\",\n  name: \"Battle Cry\",\n  rulesText:\n    \"Until end of round, the first battle you fight: each of your Champions in that battle rolls +1 die in combat round 1.\",\n  type: \"Spell\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 35,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"battleCry\" }]\n};\n\nexport const SMOKE_SCREEN: CardDef = {\n  id: \"age1.smoke_screen\",\n  name: \"Smoke Screen\",\n  rulesText:\n    \"Until end of round, the first battle you fight: enemy Forces hit on 1 only in combat round 1.\",\n  type: \"Spell\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 2 },\n  initiative: 30,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"smokeScreen\" }]\n};\n\nexport const QUICK_STUDY: CardDef = {\n  id: \"age1.quick_study\",\n  name: \"Quick Study\",\n  rulesText: \"Draw 2 cards.\",\n  type: \"Order\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 25,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"drawCards\", count: 2 }]\n};\n\nexport const MAKE_A_PLAY: CardDef = {\n  id: \"age1.make_a_play\",\n  name: \"Make a Play\",\n  rulesText: \"Gain 1 mana. Burn.\",\n  type: \"Spell\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 0 },\n  initiative: 70,\n  burn: true,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"gainMana\", amount: 1 }]\n};\n\nexport const PAID_LOGISTICS: CardDef = {\n  id: \"age1.paid_logistics\",\n  name: \"Paid Logistics\",\n  rulesText: \"Gain 1 mana. Burn.\",\n  type: \"Spell\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 0, gold: 6 },\n  initiative: 70,\n  burn: true,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"gainMana\", amount: 1 }]\n};\n\nexport const SMALL_HANDS: CardDef = {\n  id: \"age1.small_hands\",\n  name: \"Small Hands\",\n  rulesText: \"If this is the last card in your hand, draw 3 cards.\",\n  type: \"Spell\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 70,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"drawCardsIfHandEmpty\", count: 3 }]\n};\n\nexport const SUPPLY_LEDGER: CardDef = {\n  id: \"age1.supply_ledger\",\n  name: \"Supply Ledger\",\n  rulesText: \"When played: Gain +1 gold.\",\n  type: \"Victory\",\n  victoryPoints: 1,\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 75,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"gainGold\", amount: 1 }]\n};\n\nexport const PATROL_RECORD: CardDef = {\n  id: \"age1.patrol_record\",\n  name: \"Patrol Record\",\n  rulesText: \"When played: Draw 1 card.\",\n  type: \"Victory\",\n  victoryPoints: 1,\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 30,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"drawCards\", count: 1 }]\n};\n\nexport const BANNER_CLAIM: CardDef = {\n  id: \"age1.banner_claim\",\n  name: \"Banner Claim\",\n  rulesText: \"When played: Move 1 Force you control 1 hex along a Bridge.\",\n  type: \"Victory\",\n  victoryPoints: 1,\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 60,\n  burn: false,\n  targetSpec: {\n    kind: \"stack\",\n    owner: \"self\",\n    maxDistance: 1,\n    requiresBridge: true\n  },\n  effects: [{ kind: \"moveStack\", maxDistance: 1, forceCount: 1 }]\n};\n\nexport const SKIRMISHER_CAPTAIN: CardDef = {\n  id: \"champion.age1.skirmisher_captain\",\n  name: \"Skirmisher Captain\",\n  rulesText: \"On deploy: Deploy 1 Force to its hex.\",\n  type: \"Champion\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 2 },\n  initiative: 65,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 4,\n    attackDice: 2,\n    hitFaces: 3,\n    bounty: 2,\n    goldCostByChampionCount: [0, 2, 4]\n  }\n};\n\nexport const BRIDGE_RUNNER: CardDef = {\n  id: \"champion.age1.bridge_runner\",\n  name: \"Bridge Runner\",\n  rulesText: \"Pathfinder: may move to adjacent hexes without Bridges.\",\n  type: \"Champion\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 2 },\n  initiative: 55,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 3,\n    attackDice: 3,\n    hitFaces: 2,\n    bounty: 2,\n    goldCostByChampionCount: [0, 2, 4]\n  }\n};\n\nexport const INSPIRING_GEEZER: CardDef = {\n  id: \"champion.age1.inspiring_geezer\",\n  name: \"Inspiring Geezer\",\n  rulesText: \"All friendly forces in this hex hit on 1-3.\",\n  type: \"Champion\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 2 },\n  initiative: 70,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 2,\n    attackDice: 1,\n    hitFaces: 2,\n    bounty: 2,\n    goldCostByChampionCount: [1, 3, 5]\n  }\n};\n\nexport const FIELD_SURGEON: CardDef = {\n  id: \"champion.age1.field_surgeon\",\n  name: \"Field Surgeon\",\n  rulesText: \"Stitchwork (1/round): Heal a friendly Champion in this hex 2.\",\n  type: \"Champion\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 2 },\n  initiative: 60,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 4,\n    attackDice: 2,\n    hitFaces: 2,\n    bounty: 2,\n    goldCostByChampionCount: [1, 3, 5]\n  }\n};\n\nexport const BRUTE: CardDef = {\n  id: \"champion.age1.brute\",\n  name: \"Brute\",\n  rulesText:\n    \"If there is no enemy Champion in this hex, roll 2 extra dice (total 3) that hit on 1-3.\",\n  type: \"Champion\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 2 },\n  initiative: 35,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 6,\n    attackDice: 1,\n    hitFaces: 3,\n    bounty: 2,\n    goldCostByChampionCount: [2, 4, 6]\n  }\n};\n\nexport const BOUNTY_HUNTER: CardDef = {\n  id: \"champion.age1.bounty_hunter\",\n  name: \"Bounty Hunter\",\n  rulesText:\n    \"Contract Pay: When an enemy Champion dies in a battle this Champion is in, gain +1 gold.\",\n  type: \"Champion\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 2 },\n  initiative: 75,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 4,\n    attackDice: 2,\n    hitFaces: 3,\n    bounty: 2,\n    goldCostByChampionCount: [1, 3, 5]\n  }\n};\n\nexport const SERGEANT: CardDef = {\n  id: \"champion.age1.sergeant\",\n  name: \"Sergeant\",\n  rulesText: \"No special ability.\",\n  type: \"Champion\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 35,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 3,\n    attackDice: 1,\n    hitFaces: 3,\n    bounty: 1,\n    goldCostByChampionCount: [1, 1, 1]\n  }\n};\n\nexport const TRAITOR: CardDef = {\n  id: \"champion.age1.traitor\",\n  name: \"Traitor\",\n  rulesText: \"Upon death: set the owner's mana to 0.\",\n  type: \"Champion\",\n  deck: \"age1\",\n  tags: [\"market\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 35,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 5,\n    attackDice: 3,\n    hitFaces: 3,\n    bounty: 3,\n    goldCostByChampionCount: [1, 2, 5]\n  }\n};\n\nexport const AGE1_CARDS: CardDef[] = [\n  QUICK_MARCH,\n  ROLL_OUT,\n  FLANK_STEP,\n  EMERGENCY_EVAC,\n  COLUMN_ADVANCE,\n  PROSPECTING,\n  TRADE_CARAVAN,\n  RECRUIT_DETACHMENT,\n  PAID_VOLUNTEERS,\n  ESCORT_DETAIL,\n  NATIONAL_SERVICE,\n  FRONTIER_CLAIM,\n  SCAVENGERS_MARKET,\n  TEMPORARY_BRIDGE,\n  SABOTAGE_BRIDGE,\n  BRIDGE_TRAP,\n  TUNNEL_NETWORK,\n  PATCH_UP,\n  BATTLE_CRY,\n  SMOKE_SCREEN,\n  QUICK_STUDY,\n  MAKE_A_PLAY,\n  PAID_LOGISTICS,\n  SMALL_HANDS,\n  SUPPLY_LEDGER,\n  PATROL_RECORD,\n  BANNER_CLAIM,\n  SKIRMISHER_CAPTAIN,\n  BRIDGE_RUNNER,\n  INSPIRING_GEEZER,\n  FIELD_SURGEON,\n  BRUTE,\n  BOUNTY_HUNTER,\n  SERGEANT,\n  TRAITOR\n];\n", "import type { CardDef } from \"./types\";\n\nexport const TRIPLE_MARCH: CardDef = {\n  id: \"age2.triple_march\",\n  name: \"Triple March\",\n  rulesText: \"Move 1 stack up to 3 along Bridges.\",\n  type: \"Order\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 1 },\n  initiative: 40,\n  burn: false,\n  targetSpec: {\n    kind: \"path\",\n    owner: \"self\",\n    maxDistance: 3,\n    requiresBridge: true\n  },\n  effects: [{ kind: \"moveStack\", maxDistance: 3 }]\n};\n\nexport const COORDINATED_ADVANCE: CardDef = {\n  id: \"age2.coordinated_advance\",\n  name: \"Coordinated Advance\",\n  rulesText: \"Move 2 stacks up to 2 along Bridges each.\",\n  type: \"Order\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 2 },\n  initiative: 55,\n  burn: false,\n  targetSpec: {\n    kind: \"multiPath\",\n    owner: \"self\",\n    maxDistance: 2,\n    minPaths: 2,\n    maxPaths: 2,\n    requiresBridge: true\n  },\n  effects: [{ kind: \"moveStacks\", maxDistance: 2 }]\n};\n\nexport const BREAKTHROUGH_LINE: CardDef = {\n  id: \"age2.breakthrough_line\",\n  name: \"Breakthrough Line\",\n  rulesText:\n    \"Move 1 stack up to 2 along Bridges. If it wins a battle this round, draw 2 at Cleanup.\",\n  type: \"Order\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 2 },\n  initiative: 75,\n  burn: false,\n  targetSpec: {\n    kind: \"path\",\n    owner: \"self\",\n    maxDistance: 2,\n    requiresBridge: true\n  },\n  effects: [{ kind: \"battleWinDraw\", drawCount: 2 }, { kind: \"moveStack\", maxDistance: 2 }]\n};\n\nexport const SET_TO_SKIRMISH: CardDef = {\n  id: \"age2.set_to_skirmish\",\n  name: \"Set to Skirmish\",\n  rulesText:\n    \"Select a hex. If a battle happens there with your forces this round, they retreat to a random empty adjacent hex (or die if none are empty).\",\n  type: \"Order\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 1 },\n  initiative: 75,\n  burn: false,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"any\",\n    allowEmpty: true\n  },\n  effects: [{ kind: \"setToSkirmish\" }]\n};\n\nexport const BATTALION_CONTRACT: CardDef = {\n  id: \"age2.battalion_contract\",\n  name: \"Battalion Contract\",\n  rulesText: \"Deploy 10 Forces to your Capital.\",\n  type: \"Order\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 3, gold: 2 },\n  initiative: 80,\n  burn: false,\n  targetSpec: {\n    kind: \"choice\",\n    options: [{ kind: \"capital\" }]\n  },\n  effects: [{ kind: \"recruit\", capitalCount: 10 }]\n};\n\nexport const RALLY_WHERE_YOU_STAND: CardDef = {\n  id: \"age2.rally_where_you_stand\",\n  name: \"Rally Where You Stand\",\n  rulesText: \"Deploy 3 Forces to a friendly Champion's hex.\",\n  type: \"Order\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 1, gold: 3 },\n  initiative: 50,\n  burn: false,\n  targetSpec: {\n    kind: \"champion\",\n    owner: \"self\"\n  },\n  effects: [{ kind: \"deployForces\", count: 3 }]\n};\n\nexport const FORWARD_BARRACKS: CardDef = {\n  id: \"age2.forward_barracks\",\n  name: \"Forward Barracks\",\n  rulesText: \"Deploy 4 Forces to a Mine/Forge you occupy or your Capital.\",\n  type: \"Order\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 1, gold: 2 },\n  initiative: 65,\n  burn: false,\n  targetSpec: {\n    kind: \"choice\",\n    options: [\n      { kind: \"capital\" },\n      { kind: \"occupiedHex\", tile: \"mine\" },\n      { kind: \"occupiedHex\", tile: \"forge\" }\n    ]\n  },\n  effects: [{ kind: \"recruit\", capitalCount: 4, occupiedCount: 4 }]\n};\n\nexport const CONSCRIPTION_DRIVE: CardDef = {\n  id: \"age2.conscription_drive\",\n  name: \"Conscription Drive\",\n  rulesText: \"Deploy 4 Forces to your Capital, then discard 1 card.\",\n  type: \"Order\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 1, gold: 1 },\n  initiative: 70,\n  burn: false,\n  targetSpec: {\n    kind: \"choice\",\n    options: [{ kind: \"capital\" }]\n  },\n  effects: [\n    { kind: \"recruit\", capitalCount: 4 },\n    { kind: \"discardFromHand\", count: 1 }\n  ]\n};\n\nexport const MINER_ARMY: CardDef = {\n  id: \"age2.miner_army\",\n  name: \"Miner Army\",\n  rulesText: \"Deploy 2 Forces into all Mines you occupy.\",\n  type: \"Order\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 1, gold: 1 },\n  initiative: 70,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"deployForcesOnMines\", count: 2 }]\n};\n\nexport const FOCUS_FIRE: CardDef = {\n  id: \"age2.focus_fire\",\n  name: \"Focus Fire\",\n  rulesText:\n    \"In your next battle this round, you assign hits you deal instead of random.\",\n  type: \"Spell\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 1 },\n  initiative: 30,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"focusFire\" }]\n};\n\nexport const SLOW: CardDef = {\n  id: \"age2.slow\",\n  name: \"Slow\",\n  rulesText: \"Selected champion rolls only 1 die in their next battle.\",\n  type: \"Spell\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 1 },\n  initiative: 40,\n  burn: false,\n  targetSpec: {\n    kind: \"champion\",\n    owner: \"enemy\"\n  },\n  effects: [{ kind: \"slow\" }]\n};\n\nexport const WARD: CardDef = {\n  id: \"age2.ward\",\n  name: \"Ward\",\n  rulesText: \"Choose a friendly Champion. It can't be targeted by enemy cards this round.\",\n  type: \"Spell\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 1 },\n  initiative: 55,\n  burn: false,\n  targetSpec: {\n    kind: \"champion\",\n    owner: \"self\"\n  },\n  effects: [{ kind: \"ward\" }]\n};\n\nexport const FRENZY: CardDef = {\n  id: \"age2.frenzy\",\n  name: \"Frenzy\",\n  rulesText: \"Friendly Champion rolls +2 dice this round; it takes 2 damage immediately.\",\n  type: \"Spell\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 1 },\n  initiative: 35,\n  burn: false,\n  targetSpec: {\n    kind: \"champion\",\n    owner: \"self\"\n  },\n  effects: [{ kind: \"frenzy\", diceBonus: 2, damage: 2 }]\n};\n\nexport const REPAIR_ORDERS: CardDef = {\n  id: \"age2.repair_orders\",\n  name: \"Repair Orders\",\n  rulesText: \"All your champions heal 1.\",\n  type: \"Spell\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 1 },\n  initiative: 35,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"healChampions\", amount: 1 }]\n};\n\nexport const GOLD_PLATED_ARMOR: CardDef = {\n  id: \"age2.gold_plated_armor\",\n  name: \"Gold Plated Armor\",\n  rulesText:\n    \"Choose a friendly Champion. This round, each time it would take 1 damage, lose 2 gold and prevent that damage.\",\n  type: \"Spell\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 2 },\n  initiative: 35,\n  burn: false,\n  targetSpec: {\n    kind: \"champion\",\n    owner: \"self\"\n  },\n  effects: [{ kind: \"goldPlatedArmor\", costPerDamage: 2 }]\n};\n\nexport const MORTAR_SHOT: CardDef = {\n  id: \"age2.mortar_shot\",\n  name: \"Mortar Shot\",\n  rulesText:\n    \"Target a hex within distance 2 of your forces. 50% chance it hits that hex, otherwise it hits an adjacent hex. Destroy 4 forces and deal 2 damage to any champions in the hit hex.\",\n  type: \"Spell\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 2 },\n  initiative: 300,\n  burn: false,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"any\",\n    allowEmpty: true\n  },\n  effects: [{ kind: \"mortarShot\", maxDistance: 2, forceLoss: 4, damage: 2 }]\n};\n\nexport const CHAMPION_RECALL: CardDef = {\n  id: \"age2.champion_recall\",\n  name: \"Champion Recall\",\n  rulesText: \"Recall a friendly Champion to your hand.\",\n  type: \"Spell\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 2 },\n  initiative: 35,\n  burn: false,\n  targetSpec: {\n    kind: \"champion\",\n    owner: \"self\"\n  },\n  effects: [{ kind: \"recallChampion\" }]\n};\n\nexport const BURN_THE_BRIDGES: CardDef = {\n  id: \"age2.burn_the_bridges\",\n  name: \"Burn the Bridges\",\n  rulesText:\n    \"Move 1 stack up to 1 along Bridges. After moving destroy every bridge connected to the hex you selected. Burn.\",\n  type: \"Order\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 2 },\n  initiative: 75,\n  burn: true,\n  targetSpec: {\n    kind: \"path\",\n    owner: \"self\",\n    maxDistance: 1,\n    requiresBridge: true\n  },\n  effects: [\n    { kind: \"moveStack\", maxDistance: 1 },\n    { kind: \"destroyConnectedBridges\" }\n  ]\n};\n\nexport const WAR_TAXES: CardDef = {\n  id: \"age2.war_taxes\",\n  name: \"War Taxes\",\n  rulesText: \"Gain +4 gold.\",\n  type: \"Order\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 1 },\n  initiative: 60,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"gainGold\", amount: 4 }]\n};\n\nexport const SMUGGLING_RING: CardDef = {\n  id: \"age2.smuggling_ring\",\n  name: \"Smuggling Ring\",\n  rulesText: \"Gain +2 gold. If you occupy an enemy Capital right now, gain +3 more.\",\n  type: \"Order\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 1 },\n  initiative: 75,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [\n    { kind: \"gainGold\", amount: 2 },\n    { kind: \"gainGoldIfEnemyCapital\", amount: 3 }\n  ]\n};\n\nexport const REFINED_INGOTS: CardDef = {\n  id: \"age2.refined_ingots\",\n  name: \"Refined Ingots\",\n  rulesText: \"Gain +2 gold. If you occupy a Mine, gain +4 gold instead.\",\n  type: \"Order\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 1 },\n  initiative: 55,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"prospecting\", baseGold: 2, bonusIfMine: 2 }]\n};\n\nexport const GUILD_FAVOR: CardDef = {\n  id: \"age2.guild_favor\",\n  name: \"Guild Favor\",\n  rulesText: \"Gain +4 gold and draw 1.\",\n  type: \"Order\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 2 },\n  initiative: 40,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [\n    { kind: \"gainGold\", amount: 4 },\n    { kind: \"drawCards\", count: 1 }\n  ]\n};\n\nexport const INSIGHT: CardDef = {\n  id: \"age2.insight\",\n  name: \"Insight\",\n  rulesText: \"Draw 2. Burn.\",\n  type: \"Order\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 0 },\n  initiative: 60,\n  burn: true,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"drawCards\", count: 2 }]\n};\n\nexport const CLEAN_CUTS: CardDef = {\n  id: \"age2.clean_cuts\",\n  name: \"Clean Cuts\",\n  rulesText: \"Burn 1 card from your hand. Draw 1.\",\n  type: \"Order\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 1 },\n  initiative: 70,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [\n    { kind: \"burnFromHand\", count: 1 },\n    { kind: \"drawCards\", count: 1 }\n  ]\n};\n\nexport const STALL: CardDef = {\n  id: \"age2.stall\",\n  name: \"Stall\",\n  rulesText: \"Do nothing.\",\n  type: \"Order\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 0 },\n  initiative: 50,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: []\n};\n\nexport const INTERRUPT: CardDef = {\n  id: \"age2.interrupt\",\n  name: \"Interrupt\",\n  rulesText: \"Draw 2 cards. All other players draw 1 card.\",\n  type: \"Order\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 1 },\n  initiative: 50,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [\n    { kind: \"drawCards\", count: 2 },\n    { kind: \"drawCardsOtherPlayers\", count: 1 }\n  ]\n};\n\nexport const BRIDGE_LOCKDOWN: CardDef = {\n  id: \"age2.bridge_lockdown\",\n  name: \"Bridge Lockdown\",\n  rulesText: \"Choose a Bridge adjacent to a hex you occupy; it can't be crossed this round.\",\n  type: \"Spell\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 2 },\n  initiative: 40,\n  burn: false,\n  targetSpec: { kind: \"edge\" },\n  effects: [{ kind: \"lockBridge\" }]\n};\n\nexport const BRIDGE_NETWORK: CardDef = {\n  id: \"age2.bridge_network\",\n  name: \"Bridge Network\",\n  rulesText: \"Build 3 Bridges, each touching a hex you occupy.\",\n  type: \"Order\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 2 },\n  initiative: 75,\n  burn: false,\n  targetSpec: {\n    kind: \"multiEdge\",\n    minEdges: 3,\n    maxEdges: 3\n  },\n  effects: [{ kind: \"buildBridge\" }]\n};\n\nexport const WORMHOLE_LINK: CardDef = {\n  id: \"age2.wormhole_link\",\n  name: \"Wormhole Link\",\n  rulesText:\n    \"Choose 2 hexes within distance 3 of your Champions; treat them as adjacent until end of round.\",\n  type: \"Spell\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 2 },\n  initiative: 80,\n  burn: true,\n  targetSpec: {\n    kind: \"hexPair\",\n    maxDistanceFromFriendlyChampion: 3\n  },\n  effects: [{ kind: \"linkHexes\" }]\n};\n\nexport const BRIDGE_PIVOT: CardDef = {\n  id: \"age2.bridge_pivot\",\n  name: \"Bridge Pivot\",\n  rulesText:\n    \"Choose a hex, destroy one bridge connected to that hex and place a new bridge connected to that hex.\",\n  type: \"Spell\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 1 },\n  initiative: 80,\n  burn: false,\n  targetSpec: {\n    kind: \"multiEdge\",\n    minEdges: 2,\n    maxEdges: 2\n  },\n  effects: [{ kind: \"bridgePivot\" }]\n};\n\nexport const DEEP_SHAFT_RIG: CardDef = {\n  id: \"age2.deep_shaft_rig\",\n  name: \"Deep Shaft Rig\",\n  rulesText:\n    \"Choose a Mine you occupy. Increase its Mine Value by +1 (max 7). Then deploy 1 Force onto that Mine.\",\n  type: \"Order\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 2, gold: 1 },\n  initiative: 60,\n  burn: false,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    tile: \"mine\"\n  },\n  effects: [\n    { kind: \"increaseMineValue\", amount: 1, maxValue: 7 },\n    { kind: \"deployForces\", count: 1 }\n  ]\n};\n\nexport const WAR_PROFITEERS: CardDef = {\n  id: \"age2.war_profiteers\",\n  name: \"Dice: War Profiteers\",\n  rulesText: \"Roll 1 die. 1-4: Gain 1 gold. 5-6: Gain 6 gold.\",\n  type: \"Order\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 1 },\n  initiative: 45,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"rollGold\", sides: 6, highMin: 5, lowGain: 1, highGain: 6 }]\n};\n\nexport const ENCIRCLEMENT: CardDef = {\n  id: \"age2.encirclement\",\n  name: \"Encirclement\",\n  rulesText:\n    \"Choose an enemy-occupied hex. If you occupy at least three adjacent hexes, destroy up to 6 enemy Forces there.\",\n  type: \"Spell\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 1 },\n  initiative: 70,\n  burn: false,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"enemy\"\n  },\n  effects: [{ kind: \"encirclement\", minAdjacent: 3, maxForces: 6 }]\n};\n\nexport const STRATEGIC_TRIUMPH: CardDef = {\n  id: \"age2.strategic_triumph\",\n  name: \"Strategic Triumph\",\n  rulesText: \"Gain +2 gold.\",\n  type: \"Victory\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 1 },\n  initiative: 55,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"gainGold\", amount: 2 }],\n  victoryPoints: 1\n};\n\nexport const CENTER_DISPATCH: CardDef = {\n  id: \"age2.center_dispatch\",\n  name: \"Center Dispatch\",\n  rulesText: \"Draw 2 if you occupy Center; otherwise draw 1.\",\n  type: \"Victory\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 1 },\n  initiative: 35,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [\n    { kind: \"drawCards\", count: 1 },\n    { kind: \"drawCardsIfTile\", tile: \"center\", count: 1 }\n  ],\n  victoryPoints: 1\n};\n\nexport const BANNER_OF_RESOLVE: CardDef = {\n  id: \"age2.banner_of_resolve\",\n  name: \"Banner of Resolve\",\n  rulesText: \"Deploy 1 Force to your Capital.\",\n  type: \"Victory\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 1 },\n  initiative: 75,\n  burn: false,\n  targetSpec: {\n    kind: \"choice\",\n    options: [{ kind: \"capital\" }]\n  },\n  effects: [{ kind: \"recruit\", capitalCount: 1 }],\n  victoryPoints: 1\n};\n\nexport const BIG_VP_GAINER: CardDef = {\n  id: \"age2.big_vp_gainer\",\n  name: \"Big VP Gainer\",\n  rulesText: \"Gives +2 VP. When drawn: lose 1 gold.\",\n  type: \"Victory\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 1 },\n  initiative: 75,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [],\n  onDraw: [{ kind: \"loseGold\", amount: 1 }],\n  victoryPoints: 2\n};\n\nexport const JET_STRIKER: CardDef = {\n  id: \"champion.age2.jet_striker\",\n  name: \"Jet Striker\",\n  rulesText: \"No special ability.\",\n  type: \"Champion\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 2 },\n  initiative: 45,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 5,\n    attackDice: 3,\n    hitFaces: 2,\n    bounty: 3,\n    goldCostByChampionCount: [1, 3, 5]\n  }\n};\n\nexport const GUERILLA_NATIVE_MERCENARY: CardDef = {\n  id: \"champion.age2.guerilla_native_mercenary\",\n  name: \"Guerilla Native Mercenary\",\n  rulesText:\n    \"Can be deployed to any unoccupied hex on the board (in addition to being able to be deployed to anywhere you occupy).\",\n  type: \"Champion\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 2 },\n  initiative: 45,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    allowEmpty: true\n  },\n  champion: {\n    hp: 4,\n    attackDice: 2,\n    hitFaces: 2,\n    bounty: 3,\n    goldCostByChampionCount: [1, 3, 5]\n  }\n};\n\nexport const TAX_REAVER: CardDef = {\n  id: \"champion.age2.tax_reaver\",\n  name: \"Tax Reaver\",\n  rulesText:\n    \"Extort: When it kills a Champion, take up to 2 gold from that player (if possible).\",\n  type: \"Champion\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 2 },\n  initiative: 70,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 6,\n    attackDice: 2,\n    hitFaces: 3,\n    bounty: 3,\n    goldCostByChampionCount: [2, 4, 6]\n  }\n};\n\nexport const SIEGE_ENGINEER: CardDef = {\n  id: \"champion.age2.siege_engineer\",\n  name: \"Siege Engineer\",\n  rulesText: \"On deploy: destroy 1 Bridge adjacent to its hex.\",\n  type: \"Champion\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 2 },\n  initiative: 60,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 5,\n    attackDice: 2,\n    hitFaces: 2,\n    bounty: 3,\n    goldCostByChampionCount: [1, 3, 5]\n  }\n};\n\nexport const DUELIST_EXEMPLAR: CardDef = {\n  id: \"champion.age2.duelist_exemplar\",\n  name: \"Duelist Exemplar\",\n  rulesText:\n    \"If any enemy Champion is in its battle, roll +1 die each combat round.\",\n  type: \"Champion\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 2 },\n  initiative: 35,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 5,\n    attackDice: 2,\n    hitFaces: 3,\n    bounty: 3,\n    goldCostByChampionCount: [1, 3, 5]\n  }\n};\n\nexport const LONE_WOLF: CardDef = {\n  id: \"champion.age2.lone_wolf\",\n  name: \"Lone Wolf\",\n  rulesText: \"If there are no friendly Forces, roll 3 extra dice.\",\n  type: \"Champion\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 2 },\n  initiative: 75,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 5,\n    attackDice: 1,\n    hitFaces: 2,\n    bounty: 3,\n    goldCostByChampionCount: [2, 4, 6]\n  }\n};\n\nexport const RELIABLE_VETERAN: CardDef = {\n  id: \"champion.age2.reliable_veteran\",\n  name: \"Reliable Veteran\",\n  rulesText: \"No special ability.\",\n  type: \"Champion\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 2 },\n  initiative: 65,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 6,\n    attackDice: 1,\n    hitFaces: 5,\n    bounty: 3,\n    goldCostByChampionCount: [2, 4, 6]\n  }\n};\n\nexport const CAPTURER: CardDef = {\n  id: \"champion.age2.capturer\",\n  name: \"Capturer\",\n  rulesText:\n    \"When this Champion wins a battle, deploy 1 Force to the hex it occupies.\",\n  type: \"Champion\",\n  deck: \"age2\",\n  tags: [\"market\", \"age2\"],\n  cost: { mana: 2 },\n  initiative: 35,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 5,\n    attackDice: 2,\n    hitFaces: 3,\n    bounty: 0,\n    goldCostByChampionCount: [1, 2, 5]\n  }\n};\n\nexport const AGE2_CARDS: CardDef[] = [\n  TRIPLE_MARCH,\n  COORDINATED_ADVANCE,\n  BREAKTHROUGH_LINE,\n  SET_TO_SKIRMISH,\n  BATTALION_CONTRACT,\n  RALLY_WHERE_YOU_STAND,\n  FORWARD_BARRACKS,\n  CONSCRIPTION_DRIVE,\n  MINER_ARMY,\n  FOCUS_FIRE,\n  SLOW,\n  WARD,\n  FRENZY,\n  REPAIR_ORDERS,\n  GOLD_PLATED_ARMOR,\n  MORTAR_SHOT,\n  CHAMPION_RECALL,\n  BURN_THE_BRIDGES,\n  WAR_TAXES,\n  SMUGGLING_RING,\n  REFINED_INGOTS,\n  GUILD_FAVOR,\n  INSIGHT,\n  CLEAN_CUTS,\n  STALL,\n  INTERRUPT,\n  BRIDGE_LOCKDOWN,\n  BRIDGE_NETWORK,\n  WORMHOLE_LINK,\n  BRIDGE_PIVOT,\n  DEEP_SHAFT_RIG,\n  WAR_PROFITEERS,\n  ENCIRCLEMENT,\n  STRATEGIC_TRIUMPH,\n  CENTER_DISPATCH,\n  BANNER_OF_RESOLVE,\n  BIG_VP_GAINER,\n  JET_STRIKER,\n  GUERILLA_NATIVE_MERCENARY,\n  TAX_REAVER,\n  SIEGE_ENGINEER,\n  DUELIST_EXEMPLAR,\n  LONE_WOLF,\n  RELIABLE_VETERAN,\n  CAPTURER\n];\n", "import type { CardDef } from \"./types\";\n\nexport const GRAND_MANEUVER: CardDef = {\n  id: \"age3.grand_maneuver\",\n  name: \"Grand Maneuver\",\n  rulesText: \"Move up to 2 different stacks up to 3 hexes along Bridges each.\",\n  type: \"Order\",\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 3 },\n  initiative: 45,\n  burn: false,\n  targetSpec: {\n    kind: \"multiPath\",\n    owner: \"self\",\n    maxDistance: 3,\n    maxPaths: 2,\n    requiresBridge: true\n  },\n  effects: [{ kind: \"moveStacks\", maxDistance: 3 }]\n};\n\nexport const GHOST_STEP: CardDef = {\n  id: \"age3.ghost_step\",\n  name: \"Ghost Step\",\n  rulesText: \"Move 1 stack up to 2 hexes ignoring Bridges. Burn.\",\n  type: \"Order\",\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 1 },\n  initiative: 30,\n  burn: true,\n  targetSpec: {\n    kind: \"path\",\n    owner: \"self\",\n    maxDistance: 2,\n    requiresBridge: false\n  },\n  effects: [{ kind: \"moveStack\", maxDistance: 2, requiresBridge: false }]\n};\n\nexport const FINAL_PUSH: CardDef = {\n  id: \"age3.final_push\",\n  name: \"Final Push\",\n  rulesText:\n    \"Move 1 stack up to 1 along Bridges. If it wins a battle this round, draw 2 at Cleanup.\",\n  type: \"Order\",\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 1 },\n  initiative: 55,\n  burn: false,\n  targetSpec: {\n    kind: \"path\",\n    owner: \"self\",\n    maxDistance: 1,\n    requiresBridge: true\n  },\n  effects: [{ kind: \"battleWinDraw\", drawCount: 2 }, { kind: \"moveStack\", maxDistance: 1 }]\n};\n\nexport const DEEP_RESERVES: CardDef = {\n  id: \"age3.deep_reserves\",\n  name: \"Deep Reserves\",\n  rulesText: \"Deploy 8 Forces to your Capital.\",\n  type: \"Order\",\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 2, gold: 2 },\n  initiative: 80,\n  burn: false,\n  targetSpec: {\n    kind: \"choice\",\n    options: [{ kind: \"capital\" }]\n  },\n  effects: [{ kind: \"recruit\", capitalCount: 8 }]\n};\n\nexport const ENDLESS_CONSCRIPTION: CardDef = {\n  id: \"age3.endless_conscription\",\n  name: \"Endless Conscription\",\n  rulesText:\n    \"Deploy X Forces to your Capital, where X is the number of cards in your hand.\",\n  type: \"Order\",\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 2, gold: 1 },\n  initiative: 60,\n  burn: false,\n  targetSpec: {\n    kind: \"choice\",\n    options: [{ kind: \"capital\" }]\n  },\n  effects: [{ kind: \"recruitByHandSize\" }]\n};\n\nexport const FORWARD_LEGION: CardDef = {\n  id: \"age3.forward_legion\",\n  name: \"Forward Legion\",\n  rulesText: \"Deploy 5 Forces to a hex you occupy.\",\n  type: \"Order\",\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 1, gold: 3 },\n  initiative: 70,\n  burn: false,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  effects: [{ kind: \"deployForces\", count: 5 }]\n};\n\nexport const ROYAL_MINT: CardDef = {\n  id: \"age3.royal_mint\",\n  name: \"Royal Mint\",\n  rulesText: \"Gain 5 gold.\",\n  type: \"Order\",\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 1 },\n  initiative: 65,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"gainGold\", amount: 5 }]\n};\n\nexport const TOME_OF_ORDERS: CardDef = {\n  id: \"age3.tome_of_orders\",\n  name: \"Tome of Orders\",\n  rulesText: \"Draw 2 cards. Then you may put 1 card from your hand on top of your draw pile.\",\n  type: \"Order\",\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 1 },\n  initiative: 60,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [\n    { kind: \"drawCards\", count: 2 },\n    { kind: \"topdeckFromHand\", count: 1 }\n  ]\n};\n\nexport const LAST_LECTURE: CardDef = {\n  id: \"age3.last_lecture\",\n  name: \"Last Lecture\",\n  rulesText: \"Draw 5 cards. Burn.\",\n  type: \"Order\",\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 2 },\n  initiative: 80,\n  burn: true,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"drawCards\", count: 5 }]\n};\n\nexport const MASTER_PLAN: CardDef = {\n  id: \"age3.master_plan\",\n  name: \"Master Plan\",\n  rulesText: \"Draw 4, discard 2.\",\n  type: \"Order\",\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 1 },\n  initiative: 30,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [\n    { kind: \"drawCards\", count: 4 },\n    { kind: \"discardFromHand\", count: 2 }\n  ]\n};\n\nexport const PERFECT_CYCLE: CardDef = {\n  id: \"age3.perfect_cycle\",\n  name: \"Perfect Cycle\",\n  rulesText: \"Draw 1, burn 1.\",\n  type: \"Order\",\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 1 },\n  initiative: 45,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [\n    { kind: \"drawCards\", count: 1 },\n    { kind: \"burnFromHand\", count: 1 }\n  ]\n};\n\nexport const EXECUTION_ORDER: CardDef = {\n  id: \"age3.execution_order\",\n  name: \"Execution Order\",\n  rulesText: \"Deal 3 damage to an enemy Champion within 2 hexes of your Champion.\",\n  type: \"Spell\",\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 2 },\n  initiative: 35,\n  burn: false,\n  targetSpec: {\n    kind: \"champion\",\n    owner: \"enemy\",\n    requiresFriendlyChampion: true,\n    maxDistance: 2\n  },\n  effects: [{ kind: \"dealChampionDamage\", amount: 3 }]\n};\n\nexport const WORMHOLE_GATE: CardDef = {\n  id: \"age3.wormhole_gate\",\n  name: \"Wormhole Gate\",\n  rulesText: \"Choose 2 hexes anywhere on the board; treat them as adjacent this round. Burn.\",\n  type: \"Spell\",\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 3 },\n  initiative: 45,\n  burn: true,\n  targetSpec: {\n    kind: \"hexPair\",\n    allowSame: false\n  },\n  effects: [{ kind: \"linkHexes\" }]\n};\n\nexport const RUIN_THE_SPAN: CardDef = {\n  id: \"age3.ruin_the_span\",\n  name: \"Ruin the Span\",\n  rulesText: \"Destroy 2 Bridges anywhere.\",\n  type: \"Order\",\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 3 },\n  initiative: 60,\n  burn: false,\n  targetSpec: {\n    kind: \"multiEdge\",\n    anywhere: true,\n    minEdges: 2,\n    maxEdges: 2\n  },\n  effects: [{ kind: \"destroyBridge\" }]\n};\n\nexport const CONQUEST_RECORD: CardDef = {\n  id: \"age3.conquest_record\",\n  name: \"Conquest Record\",\n  rulesText: \"When played: Gain 3 gold.\",\n  type: \"Victory\",\n  victoryPoints: 1,\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 1 },\n  initiative: 50,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"gainGold\", amount: 3 }]\n};\n\nexport const FINAL_OATH: CardDef = {\n  id: \"age3.final_oath\",\n  name: \"Final Oath\",\n  rulesText: \"When played: Heal a friendly Champion anywhere 2.\",\n  type: \"Victory\",\n  victoryPoints: 1,\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 1 },\n  initiative: 35,\n  burn: false,\n  targetSpec: {\n    kind: \"champion\",\n    owner: \"self\"\n  },\n  effects: [{ kind: \"healChampion\", amount: 2 }]\n};\n\nexport const MONUMENT_PLAN: CardDef = {\n  id: \"age3.monument_plan\",\n  name: \"Monument Plan\",\n  rulesText: \"Gives +2 VP. When played: Discard 1 card.\",\n  type: \"Victory\",\n  victoryPoints: 2,\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 1 },\n  initiative: 60,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"discardFromHand\", count: 1 }]\n};\n\nexport const LOGISTICS_OFFICER: CardDef = {\n  id: \"champion.age3.logistics_officer\",\n  name: \"Logistics Officer\",\n  rulesText: \"You may deploy to this Champion as if it were your Capital.\",\n  type: \"Champion\",\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 2 },\n  initiative: 55,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 4,\n    attackDice: 2,\n    hitFaces: 3,\n    bounty: 3,\n    goldCostByChampionCount: [2, 4, 6]\n  }\n};\n\nexport const TITAN_VANGUARD: CardDef = {\n  id: \"champion.age3.titan_vanguard\",\n  name: \"Titan Vanguard\",\n  rulesText: \"No special ability.\",\n  type: \"Champion\",\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 3 },\n  initiative: 70,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 10,\n    attackDice: 2,\n    hitFaces: 3,\n    bounty: 5,\n    goldCostByChampionCount: [2, 4, 6]\n  }\n};\n\nexport const CENTER_BANNERMAN: CardDef = {\n  id: \"champion.age3.center_bannerman\",\n  name: \"Center Bannerman\",\n  rulesText: \"Worth 1 VP while occupying the Center.\",\n  type: \"Champion\",\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 2 },\n  initiative: 55,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 3,\n    attackDice: 2,\n    hitFaces: 2,\n    bounty: 5,\n    goldCostByChampionCount: [2, 4, 6]\n  }\n};\n\nexport const BLOOD_BANKER: CardDef = {\n  id: \"champion.age3.blood_banker\",\n  name: \"Blood Banker\",\n  rulesText:\n    \"Blood Ledger (1/round): First time a Champion dies in this hex, gain +2 gold.\",\n  type: \"Champion\",\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 2 },\n  initiative: 55,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 7,\n    attackDice: 2,\n    hitFaces: 3,\n    bounty: 3,\n    goldCostByChampionCount: [2, 4, 6]\n  }\n};\n\nexport const STORMCALLER: CardDef = {\n  id: \"champion.age3.stormcaller\",\n  name: \"Stormcaller\",\n  rulesText:\n    \"Tempest (1/round): deal 1 damage to every enemy Champion in adjacent hexes.\",\n  type: \"Champion\",\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 3 },\n  initiative: 45,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 8,\n    attackDice: 3,\n    hitFaces: 2,\n    bounty: 4,\n    goldCostByChampionCount: [2, 4, 6]\n  }\n};\n\nexport const GRAND_STRATEGIST: CardDef = {\n  id: \"champion.age3.grand_strategist\",\n  name: \"Grand Strategist\",\n  rulesText:\n    \"Tactical Hand (1/round): in a battle it\u2019s in, you may assign 3 of your hits.\",\n  type: \"Champion\",\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 2 },\n  initiative: 25,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 6,\n    attackDice: 2,\n    hitFaces: 3,\n    bounty: 3,\n    goldCostByChampionCount: [2, 4, 6]\n  }\n};\n\nexport const CAPITAL_BREAKER: CardDef = {\n  id: \"champion.age3.capital_breaker\",\n  name: \"Capital Breaker\",\n  rulesText:\n    \"Breach: In Capital sieges this round, your Forces in that siege hit on 1\u20133 in combat round 1.\",\n  type: \"Champion\",\n  deck: \"age3\",\n  tags: [\"market\", \"age3\"],\n  cost: { mana: 3 },\n  initiative: 60,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 8,\n    attackDice: 3,\n    hitFaces: 3,\n    bounty: 4,\n    goldCostByChampionCount: [2, 4, 6]\n  }\n};\n\nexport const AGE3_CARDS: CardDef[] = [\n  GRAND_MANEUVER,\n  GHOST_STEP,\n  FINAL_PUSH,\n  DEEP_RESERVES,\n  ENDLESS_CONSCRIPTION,\n  FORWARD_LEGION,\n  ROYAL_MINT,\n  TOME_OF_ORDERS,\n  LAST_LECTURE,\n  MASTER_PLAN,\n  PERFECT_CYCLE,\n  EXECUTION_ORDER,\n  WORMHOLE_GATE,\n  RUIN_THE_SPAN,\n  CONQUEST_RECORD,\n  FINAL_OATH,\n  MONUMENT_PLAN,\n  LOGISTICS_OFFICER,\n  TITAN_VANGUARD,\n  CENTER_BANNERMAN,\n  BLOOD_BANKER,\n  STORMCALLER,\n  GRAND_STRATEGIST,\n  CAPITAL_BREAKER\n];\n", "import type { CardDef } from \"./types\";\n\nexport const HOLD_THE_LINE: CardDef = {\n  id: \"faction.bastion.hold_the_line\",\n  name: \"Hold the Line\",\n  rulesText:\n    \"Choose a hex you occupy. Until end of round, when you defend in that hex, your Forces hit on 1-3.\",\n  type: \"Spell\",\n  deck: \"starter\",\n  tags: [\"starter\", \"faction\"],\n  cost: { mana: 1 },\n  initiative: 35,\n  burn: false,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  effects: [{ kind: \"holdTheLine\" }],\n  factionId: \"bastion\"\n};\n\nexport const MARKED_FOR_COIN: CardDef = {\n  id: \"faction.veil.marked_for_coin\",\n  name: \"Marked for Coin\",\n  rulesText:\n    \"Mark an enemy Champion within distance 2 of one of your Champions. If it dies before end of round, gain +4 gold.\",\n  type: \"Spell\",\n  deck: \"starter\",\n  tags: [\"starter\", \"faction\"],\n  cost: { mana: 1 },\n  initiative: 35,\n  burn: false,\n  targetSpec: {\n    kind: \"champion\",\n    owner: \"enemy\",\n    maxDistance: 2,\n    requiresFriendlyChampion: true\n  },\n  effects: [{ kind: \"markForCoin\", bounty: 4 }],\n  factionId: \"veil\"\n};\n\nexport const AIR_DROP: CardDef = {\n  id: \"faction.aerial.air_drop\",\n  name: \"Air Drop\",\n  rulesText:\n    \"Deploy 3 Forces into any non-Capital hex within distance 1 of one of your Champions (ignores Bridges).\",\n  type: \"Spell\",\n  deck: \"starter\",\n  tags: [\"starter\", \"faction\"],\n  cost: { mana: 2, gold: 1 },\n  initiative: 30,\n  burn: false,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"any\",\n    maxDistanceFromFriendlyChampion: 1,\n    allowCapital: false,\n    ignoresBridges: true\n  },\n  effects: [{ kind: \"deployForces\", count: 3, ignoresBridges: true }],\n  factionId: \"aerial\"\n};\n\nexport const RICH_VEINS: CardDef = {\n  id: \"faction.prospect.rich_veins\",\n  name: \"Rich Veins\",\n  rulesText: \"If you occupy a Mine, increase its value permanently by 1 (max 7).\",\n  type: \"Spell\",\n  deck: \"starter\",\n  tags: [\"starter\", \"faction\"],\n  cost: { mana: 2 },\n  initiative: 45,\n  burn: false,\n  targetSpec: {\n    kind: \"hex\",\n    tile: \"mine\",\n    owner: \"self\",\n    occupied: true\n  },\n  effects: [{ kind: \"increaseMineValue\", amount: 1, maxValue: 7 }],\n  factionId: \"prospect\"\n};\n\nexport const PERFECT_RECALL: CardDef = {\n  id: \"faction.cipher.perfect_recall\",\n  name: \"Perfect Recall\",\n  rulesText: \"Draw 1 card. Then you may put 1 card from your hand on top of your draw pile.\",\n  type: \"Spell\",\n  deck: \"starter\",\n  tags: [\"starter\", \"faction\"],\n  cost: { mana: 1 },\n  initiative: 25,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"drawCards\", count: 1 }, { kind: \"topdeckFromHand\", count: 1 }],\n  factionId: \"cipher\"\n};\n\nexport const BRIDGEBORN_PATH: CardDef = {\n  id: \"faction.gatewright.bridgeborn_path\",\n  name: \"Bridgeborn Path\",\n  rulesText: \"Build 1 Bridge anywhere on the board.\",\n  type: \"Spell\",\n  deck: \"starter\",\n  tags: [\"starter\", \"faction\"],\n  cost: { mana: 1 },\n  initiative: 50,\n  burn: false,\n  targetSpec: {\n    kind: \"edge\",\n    anywhere: true\n  },\n  effects: [{ kind: \"buildBridge\" }],\n  factionId: \"gatewright\"\n};\n\nexport const IRONCLAD_WARDEN: CardDef = {\n  id: \"champion.bastion.ironclad_warden\",\n  name: \"Ironclad Warden\",\n  rulesText:\n    \"Bodyguard: the first hit that would be assigned to a friendly Champion is assigned to a friendly Force instead (if any).\",\n  type: \"Champion\",\n  deck: \"starter\",\n  tags: [\"starter\", \"faction\"],\n  cost: { mana: 2 },\n  initiative: 70,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 6,\n    attackDice: 2,\n    hitFaces: 2,\n    bounty: 3,\n    goldCostByChampionCount: [1, 3, 5]\n  },\n  factionId: \"bastion\"\n};\n\nexport const SHADEBLADE: CardDef = {\n  id: \"champion.veil.shadeblade\",\n  name: \"Shadeblade\",\n  rulesText:\n    \"Assassin's Edge (1/round): before combat round 1 of a battle Shadeblade is in, deal 1 damage to an enemy Champion in that hex.\",\n  type: \"Champion\",\n  deck: \"starter\",\n  tags: [\"starter\", \"faction\"],\n  cost: { mana: 2 },\n  initiative: 55,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 3,\n    attackDice: 5,\n    hitFaces: 1,\n    bounty: 3,\n    goldCostByChampionCount: [0, 2, 4]\n  },\n  factionId: \"veil\"\n};\n\nexport const SKYSTRIKER_ACE: CardDef = {\n  id: \"champion.aerial.skystriker_ace\",\n  name: \"Skystriker Ace\",\n  rulesText: \"Flight: may move to adjacent hexes without Bridges.\",\n  type: \"Champion\",\n  deck: \"starter\",\n  tags: [\"starter\", \"faction\"],\n  cost: { mana: 2 },\n  initiative: 60,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 4,\n    attackDice: 2,\n    hitFaces: 3,\n    bounty: 3,\n    goldCostByChampionCount: [0, 2, 4]\n  },\n  factionId: \"aerial\"\n};\n\nexport const MINE_OVERSEER: CardDef = {\n  id: \"champion.prospect.mine_overseer\",\n  name: \"Mine Overseer\",\n  rulesText: \"Extraction: while on a Mine you occupy, that Mine gives +1 gold at Collection.\",\n  type: \"Champion\",\n  deck: \"starter\",\n  tags: [\"starter\", \"faction\"],\n  cost: { mana: 2 },\n  initiative: 65,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 5,\n    attackDice: 2,\n    hitFaces: 2,\n    bounty: 4,\n    goldCostByChampionCount: [1, 3, 5]\n  },\n  factionId: \"prospect\"\n};\n\nexport const ARCHIVIST_PRIME: CardDef = {\n  id: \"champion.cipher.archivist_prime\",\n  name: \"Archivist Prime\",\n  rulesText: \"Gain +1 attack die for each card you have played this round.\",\n  type: \"Champion\",\n  deck: \"starter\",\n  tags: [\"starter\", \"faction\"],\n  cost: { mana: 2 },\n  initiative: 60,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 5,\n    attackDice: 2,\n    hitFaces: 3,\n    bounty: 3,\n    goldCostByChampionCount: [1, 3, 5]\n  },\n  factionId: \"cipher\"\n};\n\nexport const WORMHOLE_ARTIFICER: CardDef = {\n  id: \"champion.gatewright.wormhole_artificer\",\n  name: \"Wormhole Artificer\",\n  rulesText: \"If moving alone, may move +1 hex.\",\n  type: \"Champion\",\n  deck: \"starter\",\n  tags: [\"starter\", \"faction\"],\n  cost: { mana: 2 },\n  initiative: 65,\n  burn: true,\n  targetSpec: {\n    kind: \"hex\",\n    owner: \"self\",\n    occupied: true\n  },\n  champion: {\n    hp: 5,\n    attackDice: 2,\n    hitFaces: 3,\n    bounty: 3,\n    goldCostByChampionCount: [1, 3, 5]\n  },\n  factionId: \"gatewright\"\n};\n\nexport const FACTION_SPELLS: CardDef[] = [\n  HOLD_THE_LINE,\n  MARKED_FOR_COIN,\n  AIR_DROP,\n  RICH_VEINS,\n  PERFECT_RECALL,\n  BRIDGEBORN_PATH\n];\n\nexport const FACTION_CHAMPIONS: CardDef[] = [\n  IRONCLAD_WARDEN,\n  SHADEBLADE,\n  SKYSTRIKER_ACE,\n  MINE_OVERSEER,\n  ARCHIVIST_PRIME,\n  WORMHOLE_ARTIFICER\n];\n\nexport const FACTION_CARDS: CardDef[] = [...FACTION_SPELLS, ...FACTION_CHAMPIONS];\n", "import type { CardDef } from \"./types\";\n\nexport const COMMAND_SURGE: CardDef = {\n  id: \"power.age1.command_surge\",\n  name: \"Command Surge\",\n  rulesText: \"Gain +2 mana. Burn.\",\n  type: \"Spell\",\n  deck: \"power\",\n  tags: [\"power\", \"age1\"],\n  cost: { mana: 0 },\n  initiative: 10,\n  burn: true,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"gainMana\", amount: 2 }]\n};\n\nexport const INSTANT_BRIDGE_NET: CardDef = {\n  id: \"power.age1.instant_bridge_net\",\n  name: \"Instant Bridge Net\",\n  rulesText: \"Build 3 Bridges, each touching a hex you occupy. Burn.\",\n  type: \"Order\",\n  deck: \"power\",\n  tags: [\"power\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 35,\n  burn: true,\n  targetSpec: {\n    kind: \"multiEdge\",\n    minEdges: 3,\n    maxEdges: 3\n  },\n  effects: [{ kind: \"buildBridge\" }]\n};\n\nexport const SECRET_PLANS: CardDef = {\n  id: \"power.age1.secret_plans\",\n  name: \"Secret Plans\",\n  rulesText: \"Draw 2. Burn.\",\n  type: \"Order\",\n  deck: \"power\",\n  tags: [\"power\", \"age1\"],\n  cost: { mana: 0 },\n  initiative: 15,\n  burn: true,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"drawCards\", count: 2 }]\n};\n\nexport const EMERGENCY_PAY: CardDef = {\n  id: \"power.age1.emergency_pay\",\n  name: \"Emergency Pay\",\n  rulesText: \"Gain +5 gold. Burn.\",\n  type: \"Order\",\n  deck: \"power\",\n  tags: [\"power\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 50,\n  burn: true,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"gainGold\", amount: 5 }]\n};\n\nexport const SHOCK_DRILL: CardDef = {\n  id: \"power.age1.shock_drill\",\n  name: \"Shock Drill\",\n  rulesText:\n    \"In your next battle this round, your Forces hit on 1\u20135 in combat round 1. Burn.\",\n  type: \"Spell\",\n  deck: \"power\",\n  tags: [\"power\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 45,\n  burn: true,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"shockDrill\" }]\n};\n\nexport const BRIDGE_DEED: CardDef = {\n  id: \"power.age1.bridge_deed\",\n  name: \"Bridge Deed\",\n  rulesText:\n    \"When played: Build 1 Bridge. Then you may move 1 stack 1 hex along a Bridge.\",\n  type: \"Victory\",\n  deck: \"power\",\n  tags: [\"power\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 40,\n  burn: false,\n  targetSpec: {\n    kind: \"edge\",\n    requiresOccupiedEndpoint: true\n  },\n  effects: [{ kind: \"buildBridge\" }, { kind: \"moveStack\", maxDistance: 1 }],\n  victoryPoints: 1\n};\n\nexport const MINE_CHARTER: CardDef = {\n  id: \"power.age1.mine_charter\",\n  name: \"Mine Charter\",\n  rulesText: \"When played: Gain +1 gold; if you occupy a Mine, gain +2 instead.\",\n  type: \"Victory\",\n  deck: \"power\",\n  tags: [\"power\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 55,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"prospecting\", baseGold: 1, bonusIfMine: 1 }],\n  victoryPoints: 1\n};\n\nexport const FORGE_SKETCH: CardDef = {\n  id: \"power.age1.forge_sketch\",\n  name: \"Forge Sketch\",\n  rulesText: \"When played: You may discard 1 card; if you do, draw 2.\",\n  type: \"Victory\",\n  deck: \"power\",\n  tags: [\"power\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 30,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [\n    { kind: \"discardFromHand\", count: 1 },\n    { kind: \"drawCards\", count: 2 }\n  ],\n  victoryPoints: 1\n};\n\nexport const CENTER_WRIT: CardDef = {\n  id: \"power.age1.center_writ\",\n  name: \"Center Writ\",\n  rulesText: \"When played: If you occupy Center, gain +1 mana.\",\n  type: \"Victory\",\n  deck: \"power\",\n  tags: [\"power\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 25,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"gainManaIfTile\", tile: \"center\", amount: 1 }],\n  victoryPoints: 1\n};\n\nexport const OATHSTONE: CardDef = {\n  id: \"power.age1.oathstone\",\n  name: \"Oathstone\",\n  rulesText: \"When played: Heal a friendly Champion in your hex 2.\",\n  type: \"Victory\",\n  deck: \"power\",\n  tags: [\"power\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 70,\n  burn: false,\n  targetSpec: {\n    kind: \"champion\",\n    owner: \"self\"\n  },\n  effects: [{ kind: \"healChampion\", amount: 2 }],\n  victoryPoints: 1\n};\n\nexport const BANNER_OF_SPARKS: CardDef = {\n  id: \"power.age1.banner_of_sparks\",\n  name: \"Banner of Sparks\",\n  rulesText: \"When played: Deploy 3 Forces to your Capital.\",\n  type: \"Victory\",\n  deck: \"power\",\n  tags: [\"power\", \"age1\"],\n  cost: { mana: 1 },\n  initiative: 60,\n  burn: false,\n  targetSpec: {\n    kind: \"choice\",\n    options: [{ kind: \"capital\" }]\n  },\n  effects: [{ kind: \"recruit\", capitalCount: 3 }],\n  victoryPoints: 1\n};\n\nexport const AGE1_POWER_CARDS: CardDef[] = [\n  COMMAND_SURGE,\n  INSTANT_BRIDGE_NET,\n  SECRET_PLANS,\n  EMERGENCY_PAY,\n  SHOCK_DRILL,\n  BRIDGE_DEED,\n  MINE_CHARTER,\n  FORGE_SKETCH,\n  CENTER_WRIT,\n  OATHSTONE,\n  BANNER_OF_SPARKS\n];\n\nexport const POWER_CARDS: CardDef[] = [...AGE1_POWER_CARDS];\n", "import type { CardDef } from \"./types\";\n\nconst createStarterVariant = (\n  base: CardDef,\n  id: string,\n  initiative: number\n): CardDef => ({\n  ...base,\n  id,\n  initiative\n});\n\nexport const RECRUIT: CardDef = {\n  id: \"starter.recruit\",\n  name: \"Recruit\",\n  rulesText: \"Deploy either 2 Forces into your Capital or 1 Force into a hex you occupy.\",\n  type: \"Order\",\n  deck: \"starter\",\n  tags: [\"starter\"],\n  cost: { mana: 1, gold: 1 },\n  initiative: 40,\n  burn: false,\n  targetSpec: {\n    kind: \"choice\",\n    options: [\n      { kind: \"capital\" },\n      { kind: \"occupiedHex\", owner: \"self\" }\n    ]\n  },\n  effects: [{ kind: \"recruit\" }]\n};\n\nexport const MARCH_ORDERS: CardDef = {\n  id: \"starter.march_orders\",\n  name: \"March Orders\",\n  rulesText: \"Move 1 stack up to 2 hexes along Bridges.\",\n  type: \"Order\",\n  deck: \"starter\",\n  tags: [\"starter\"],\n  cost: { mana: 1 },\n  initiative: 100,\n  burn: false,\n  targetSpec: {\n    kind: \"path\",\n    owner: \"self\",\n    maxDistance: 2,\n    requiresBridge: true\n  },\n  effects: [{ kind: \"moveStack\", maxDistance: 2 }]\n};\n\nexport const SUPPLY_CACHE: CardDef = {\n  id: \"starter.supply_cache\",\n  name: \"Supply Cache\",\n  rulesText: \"Gain +2 gold.\",\n  type: \"Order\",\n  deck: \"starter\",\n  tags: [\"starter\"],\n  cost: { mana: 1 },\n  initiative: 55,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"gainGold\", amount: 2 }]\n};\n\nexport const FIELD_MEDIC: CardDef = {\n  id: \"starter.field_medic\",\n  name: \"Field Medic\",\n  rulesText: \"Heal any Champion 2 HP.\",\n  type: \"Order\",\n  deck: \"starter\",\n  tags: [\"starter\"],\n  cost: { mana: 1 },\n  initiative: 60,\n  burn: false,\n  targetSpec: {\n    kind: \"champion\",\n    owner: \"any\"\n  },\n  effects: [{ kind: \"healChampion\", amount: 2 }]\n};\n\nexport const SCOUT_REPORT: CardDef = {\n  id: \"starter.scout_report\",\n  name: \"Scout Report\",\n  rulesText: \"Look at the top 3 cards of your draw pile. Put 1 into hand, discard 2.\",\n  type: \"Order\",\n  deck: \"starter\",\n  tags: [\"starter\"],\n  cost: { mana: 1 },\n  initiative: 220,\n  burn: false,\n  targetSpec: { kind: \"none\" },\n  effects: [{ kind: \"scoutReport\", lookCount: 3, keepCount: 1 }]\n};\n\nexport const SCOUT_REPORT_VEIL: CardDef = createStarterVariant(\n  SCOUT_REPORT,\n  \"starter.scout_report.veil\",\n  215\n);\nexport const SCOUT_REPORT_AERIAL: CardDef = createStarterVariant(\n  SCOUT_REPORT,\n  \"starter.scout_report.aerial\",\n  200\n);\nexport const SCOUT_REPORT_PROSPECT: CardDef = createStarterVariant(\n  SCOUT_REPORT,\n  \"starter.scout_report.prospect\",\n  218\n);\nexport const SCOUT_REPORT_CIPHER: CardDef = createStarterVariant(\n  SCOUT_REPORT,\n  \"starter.scout_report.cipher\",\n  217\n);\nexport const SCOUT_REPORT_GATEWRIGHT: CardDef = createStarterVariant(\n  SCOUT_REPORT,\n  \"starter.scout_report.gatewright\",\n  210\n);\n\nexport const BRIDGE_CREW: CardDef = {\n  id: \"starter.bridge_crew\",\n  name: \"Bridge Crew\",\n  rulesText:\n    \"Build 1 Bridge between adjacent hexes where at least one endpoint is a hex you occupy. Then you may move 1 stack 1 hex.\",\n  type: \"Order\",\n  deck: \"starter\",\n  tags: [\"starter\"],\n  cost: { mana: 1 },\n  initiative: 90,\n  burn: false,\n  targetSpec: {\n    kind: \"edge\",\n    requiresOccupiedEndpoint: true\n  },\n  effects: [{ kind: \"buildBridge\" }, { kind: \"moveStack\", maxDistance: 1 }]\n};\n\nexport const QUICK_MOVE: CardDef = {\n  id: \"starter.quick_move\",\n  name: \"Quick Move\",\n  rulesText: \"Move 1 Force you control 1 hex along Bridges.\",\n  type: \"Order\",\n  deck: \"starter\",\n  tags: [\"starter\"],\n  cost: { mana: 1 },\n  initiative: 120,\n  burn: false,\n  targetSpec: {\n    kind: \"stack\",\n    owner: \"self\",\n    maxDistance: 1,\n    requiresBridge: true\n  },\n  effects: [{ kind: \"moveStack\", maxDistance: 1, forceCount: 1 }]\n};\n\nexport const QUICK_MOVE_VEIL: CardDef = createStarterVariant(\n  QUICK_MOVE,\n  \"starter.quick_move.veil\",\n  115\n);\nexport const QUICK_MOVE_AERIAL: CardDef = createStarterVariant(\n  QUICK_MOVE,\n  \"starter.quick_move.aerial\",\n  100\n);\nexport const QUICK_MOVE_PROSPECT: CardDef = createStarterVariant(\n  QUICK_MOVE,\n  \"starter.quick_move.prospect\",\n  118\n);\nexport const QUICK_MOVE_CIPHER: CardDef = createStarterVariant(\n  QUICK_MOVE,\n  \"starter.quick_move.cipher\",\n  117\n);\nexport const QUICK_MOVE_GATEWRIGHT: CardDef = createStarterVariant(\n  QUICK_MOVE,\n  \"starter.quick_move.gatewright\",\n  110\n);\n\nexport const ZAP: CardDef = {\n  id: \"starter.zap\",\n  name: \"Zap\",\n  rulesText: \"Deal 1 damage to any Champion.\",\n  type: \"Order\",\n  deck: \"starter\",\n  tags: [\"starter\"],\n  cost: { mana: 1 },\n  initiative: 220,\n  burn: false,\n  targetSpec: {\n    kind: \"champion\",\n    owner: \"any\"\n  },\n  effects: [{ kind: \"dealChampionDamage\", amount: 1 }]\n};\n\nexport const ZAP_VEIL: CardDef = createStarterVariant(ZAP, \"starter.zap.veil\", 215);\nexport const ZAP_AERIAL: CardDef = createStarterVariant(ZAP, \"starter.zap.aerial\", 200);\nexport const ZAP_PROSPECT: CardDef = createStarterVariant(ZAP, \"starter.zap.prospect\", 218);\nexport const ZAP_CIPHER: CardDef = createStarterVariant(ZAP, \"starter.zap.cipher\", 217);\nexport const ZAP_GATEWRIGHT: CardDef = createStarterVariant(\n  ZAP,\n  \"starter.zap.gatewright\",\n  210\n);\n\nexport const STARTER_CARDS: CardDef[] = [\n  RECRUIT,\n  MARCH_ORDERS,\n  SUPPLY_CACHE,\n  FIELD_MEDIC,\n  SCOUT_REPORT,\n  SCOUT_REPORT_VEIL,\n  SCOUT_REPORT_AERIAL,\n  SCOUT_REPORT_PROSPECT,\n  SCOUT_REPORT_CIPHER,\n  SCOUT_REPORT_GATEWRIGHT,\n  BRIDGE_CREW,\n  QUICK_MOVE,\n  QUICK_MOVE_VEIL,\n  QUICK_MOVE_AERIAL,\n  QUICK_MOVE_PROSPECT,\n  QUICK_MOVE_CIPHER,\n  QUICK_MOVE_GATEWRIGHT,\n  ZAP,\n  ZAP_VEIL,\n  ZAP_AERIAL,\n  ZAP_PROSPECT,\n  ZAP_CIPHER,\n  ZAP_GATEWRIGHT\n];\n", "import type { CardDef, CardDefId } from \"./types\";\nimport { AGE1_CARDS } from \"./age1\";\nimport { AGE2_CARDS } from \"./age2\";\nimport { AGE3_CARDS } from \"./age3\";\nimport { FACTION_CARDS } from \"./faction\";\nimport { POWER_CARDS } from \"./power\";\nimport { STARTER_CARDS } from \"./starter\";\n\nexport * from \"./types\";\nexport * from \"./age1\";\nexport * from \"./age2\";\nexport * from \"./age3\";\nexport * from \"./faction\";\nexport * from \"./power\";\nexport * from \"./starter\";\n\nconst addDerivedTags = (card: CardDef): CardDef => {\n  const tags = [...card.tags];\n  const addTag = (tag: string, condition: boolean) => {\n    if (condition && !tags.includes(tag)) {\n      tags.push(tag);\n    }\n  };\n  addTag(\"burn\", card.burn);\n  addTag(\"champion\", card.type === \"Champion\");\n  addTag(\"victory\", card.type === \"Victory\");\n  addTag(\"power\", card.deck === \"power\");\n\n  if (tags.length === card.tags.length) {\n    return card;\n  }\n  return { ...card, tags };\n};\n\nexport const CARD_DEFS: CardDef[] = [\n  ...STARTER_CARDS,\n  ...FACTION_CARDS,\n  ...AGE1_CARDS,\n  ...AGE2_CARDS,\n  ...AGE3_CARDS,\n  ...POWER_CARDS\n].map(addDerivedTags);\n\nexport const CARD_DEFS_BY_ID: Record<CardDefId, CardDef> = CARD_DEFS.reduce(\n  (acc, card) => {\n    acc[card.id] = card;\n    return acc;\n  },\n  {} as Record<CardDefId, CardDef>\n);\n\nexport const getCardDef = (id: CardDefId): CardDef | undefined => {\n  return CARD_DEFS_BY_ID[id];\n};\n", "import type { Age, CardDefId } from \"../types\";\n\nimport { AGE1_CARDS } from \"./cards/age1\";\nimport { AGE2_CARDS } from \"./cards/age2\";\nimport { AGE3_CARDS } from \"./cards/age3\";\n\nconst toIds = (cards: { id: CardDefId }[]): CardDefId[] => cards.map((card) => card.id);\n\nexport const AGE1_MARKET_DECK: CardDefId[] = toIds(AGE1_CARDS);\nexport const AGE2_MARKET_DECK: CardDefId[] = toIds(AGE2_CARDS);\nexport const AGE3_MARKET_DECK: CardDefId[] = toIds(AGE3_CARDS);\n\nexport const MARKET_DECKS_BY_AGE: Record<Age, CardDefId[]> = {\n  I: AGE1_MARKET_DECK,\n  II: AGE2_MARKET_DECK,\n  III: AGE3_MARKET_DECK\n};\n", "import type { Age, CardDefId } from \"../types\";\n\nimport { AGE2_MARKET_DECK, AGE3_MARKET_DECK } from \"./market-decks\";\n\nconst clone = (deck: CardDefId[]) => deck.slice();\n\nexport const AGE1_POWER_DECK: CardDefId[] = [\n  \"power.age1.command_surge\",\n  \"power.age1.instant_bridge_net\",\n  \"power.age1.secret_plans\",\n  \"power.age1.emergency_pay\",\n  \"power.age1.shock_drill\",\n  \"power.age1.bridge_deed\",\n  \"power.age1.mine_charter\",\n  \"power.age1.forge_sketch\",\n  \"power.age1.center_writ\",\n  \"power.age1.oathstone\",\n  \"power.age1.banner_of_sparks\"\n];\nexport const AGE2_POWER_DECK: CardDefId[] = clone(AGE2_MARKET_DECK);\nexport const AGE3_POWER_DECK: CardDefId[] = clone(AGE3_MARKET_DECK);\n\nexport const POWER_DECKS_BY_AGE: Record<Age, CardDefId[]> = {\n  I: AGE1_POWER_DECK,\n  II: AGE2_POWER_DECK,\n  III: AGE3_POWER_DECK\n};\n", "import type { CardDefId } from \"../types\";\n\nexport const COMMON_STARTER_DECK: CardDefId[] = [\n  \"starter.recruit\",\n  \"starter.recruit\",\n  \"starter.march_orders\",\n  \"starter.supply_cache\",\n  \"starter.field_medic\",\n  \"starter.scout_report\",\n  \"starter.bridge_crew\",\n  \"starter.quick_move\",\n  \"starter.zap\"\n];\n\nexport const DEFAULT_FACTION_ID = \"bastion\";\n\nconst QUICK_MOVE_ID = \"starter.quick_move\";\nconst ZAP_ID = \"starter.zap\";\nconst SCOUT_REPORT_ID = \"starter.scout_report\";\n\nconst applyStarterOverrides = (\n  overrides: Partial<Record<CardDefId, CardDefId>>\n): CardDefId[] => COMMON_STARTER_DECK.map((cardId) => overrides[cardId] ?? cardId);\n\nexport const FACTION_STARTER_DECKS: Record<string, CardDefId[]> = {\n  bastion: [...COMMON_STARTER_DECK],\n  veil: applyStarterOverrides({\n    [QUICK_MOVE_ID]: \"starter.quick_move.veil\",\n    [ZAP_ID]: \"starter.zap.veil\",\n    [SCOUT_REPORT_ID]: \"starter.scout_report.veil\"\n  }),\n  aerial: applyStarterOverrides({\n    [QUICK_MOVE_ID]: \"starter.quick_move.aerial\",\n    [ZAP_ID]: \"starter.zap.aerial\",\n    [SCOUT_REPORT_ID]: \"starter.scout_report.aerial\"\n  }),\n  prospect: applyStarterOverrides({\n    [QUICK_MOVE_ID]: \"starter.quick_move.prospect\",\n    [ZAP_ID]: \"starter.zap.prospect\",\n    [SCOUT_REPORT_ID]: \"starter.scout_report.prospect\"\n  }),\n  cipher: applyStarterOverrides({\n    [QUICK_MOVE_ID]: \"starter.quick_move.cipher\",\n    [ZAP_ID]: \"starter.zap.cipher\",\n    [SCOUT_REPORT_ID]: \"starter.scout_report.cipher\"\n  }),\n  gatewright: applyStarterOverrides({\n    [QUICK_MOVE_ID]: \"starter.quick_move.gatewright\",\n    [ZAP_ID]: \"starter.zap.gatewright\",\n    [SCOUT_REPORT_ID]: \"starter.scout_report.gatewright\"\n  })\n};\n\nexport const FACTION_STARTER_SPELLS: Record<string, CardDefId> = {\n  bastion: \"faction.bastion.hold_the_line\",\n  veil: \"faction.veil.marked_for_coin\",\n  aerial: \"faction.aerial.air_drop\",\n  prospect: \"faction.prospect.rich_veins\",\n  cipher: \"faction.cipher.perfect_recall\",\n  gatewright: \"faction.gatewright.bridgeborn_path\"\n};\n\nexport const FACTION_STARTER_CHAMPIONS: Record<string, CardDefId> = {\n  bastion: \"champion.bastion.ironclad_warden\",\n  veil: \"champion.veil.shadeblade\",\n  aerial: \"champion.aerial.skystriker_ace\",\n  prospect: \"champion.prospect.mine_overseer\",\n  cipher: \"champion.cipher.archivist_prime\",\n  gatewright: \"champion.gatewright.wormhole_artificer\"\n};\n\nexport type StarterFactionCards = {\n  factionId: string;\n  starterSpellId: CardDefId;\n  championId: CardDefId;\n  deck: CardDefId[];\n};\n\nexport const resolveStarterFactionCards = (factionId: string): StarterFactionCards => {\n  const hasFaction =\n    Boolean(FACTION_STARTER_SPELLS[factionId]) && Boolean(FACTION_STARTER_CHAMPIONS[factionId]);\n  const resolvedFaction = hasFaction ? factionId : DEFAULT_FACTION_ID;\n\n  return {\n    factionId: resolvedFaction,\n    starterSpellId: FACTION_STARTER_SPELLS[resolvedFaction],\n    championId: FACTION_STARTER_CHAMPIONS[resolvedFaction],\n    deck: FACTION_STARTER_DECKS[resolvedFaction] ?? COMMON_STARTER_DECK\n  };\n};\n", "import { canonicalEdgeKey } from \"@bridgefront/shared\";\n\nimport type { BoardState, HexKey, HexState, PlayerID } from \"./types\";\n\nexport const getHex = (board: BoardState, key: HexKey): HexState | undefined => {\n  return board.hexes[key];\n};\n\nexport const getPlayerIdsOnHex = (hex: HexState): PlayerID[] => {\n  return Object.entries(hex.occupants)\n    .filter(([, unitIds]) => unitIds.length > 0)\n    .map(([playerId]) => playerId);\n};\n\nexport const getCenterHexKey = (board: BoardState): HexKey | null => {\n  for (const hex of Object.values(board.hexes)) {\n    if (hex.tile === \"center\") {\n      return hex.key;\n    }\n  }\n  return null;\n};\n\nexport const countPlayersOnHex = (hex: HexState): number => {\n  return getPlayerIdsOnHex(hex).length;\n};\n\nexport const isOccupiedByPlayer = (hex: HexState, playerId: PlayerID): boolean => {\n  return (hex.occupants[playerId]?.length ?? 0) > 0;\n};\n\nexport const hasEnemyUnits = (hex: HexState, playerId: PlayerID): boolean => {\n  return getPlayerIdsOnHex(hex).some((occupantId) => occupantId !== playerId);\n};\n\nexport const isContestedHex = (hex: HexState): boolean => {\n  return countPlayersOnHex(hex) === 2;\n};\n\nexport const wouldExceedTwoPlayers = (hex: HexState, enteringPlayerId: PlayerID): boolean => {\n  const occupants = new Set(getPlayerIdsOnHex(hex));\n  occupants.add(enteringPlayerId);\n  return occupants.size > 2;\n};\n\nexport const hasBridge = (board: BoardState, from: HexKey, to: HexKey): boolean => {\n  const edgeKey = canonicalEdgeKey(from, to);\n  return Boolean(board.bridges[edgeKey]);\n};\n\nexport const getBridgeKey = (from: HexKey, to: HexKey): string => {\n  return canonicalEdgeKey(from, to);\n};\n", "import type {\n  CardDrawContext,\n  CardChoiceContext,\n  ChampionKillContext,\n  CombatAssignmentContext,\n  CombatEndContext,\n  CombatRoundContext,\n  CombatUnitContext,\n  ControlBonusContext,\n  ControlValueContext,\n  DeployForcesContext,\n  GameState,\n  HexKey,\n  Modifier,\n  MoveContext,\n  ModifierEventHook,\n  ModifierHooks,\n  ModifierQueryHook,\n  RoundEndContext\n} from \"./types\";\n\nconst getHooks = (modifier: Modifier): ModifierHooks | null => {\n  if (!modifier.hooks) {\n    return null;\n  }\n  return modifier.hooks as ModifierHooks;\n};\n\nconst isModifierActive = (modifier: Modifier): boolean => {\n  if (modifier.duration.type === \"uses\") {\n    return modifier.duration.remaining > 0;\n  }\n  return true;\n};\n\nconst consumeModifierUse = (state: GameState, modifierId: string): GameState => {\n  const index = state.modifiers.findIndex((modifier) => modifier.id === modifierId);\n  if (index < 0) {\n    return state;\n  }\n\n  const modifier = state.modifiers[index];\n  if (modifier.duration.type !== \"uses\") {\n    return state;\n  }\n\n  const remaining = modifier.duration.remaining - 1;\n  const nextModifiers = [...state.modifiers];\n\n  if (remaining <= 0) {\n    nextModifiers.splice(index, 1);\n  } else {\n    nextModifiers[index] = {\n      ...modifier,\n      duration: { type: \"uses\", remaining }\n    };\n  }\n\n  return { ...state, modifiers: nextModifiers };\n};\n\nconst filterActiveModifiers = (modifiers: Modifier[]): Modifier[] => {\n  return modifiers.filter((modifier) => isModifierActive(modifier));\n};\n\nexport const getCombatModifiers = (state: GameState, hexKey: HexKey): Modifier[] => {\n  return state.modifiers.filter((modifier) => {\n    if (modifier.attachedHex && modifier.attachedHex !== hexKey) {\n      return false;\n    }\n    if (modifier.attachedEdge) {\n      return false;\n    }\n    return true;\n  });\n};\n\nexport const expireEndOfRoundModifiers = (state: GameState): GameState => {\n  const modifiers = filterActiveModifiers(\n    state.modifiers.filter((modifier) => modifier.duration.type !== \"endOfRound\")\n  );\n  return modifiers.length === state.modifiers.length ? state : { ...state, modifiers };\n};\n\nexport const expireEndOfBattleModifiers = (state: GameState, hexKey: HexKey): GameState => {\n  const modifiers = filterActiveModifiers(\n    state.modifiers.filter((modifier) => {\n      if (modifier.duration.type !== \"endOfBattle\") {\n        return true;\n      }\n      if (!modifier.attachedHex) {\n        return false;\n      }\n      return modifier.attachedHex !== hexKey;\n    })\n  );\n  return modifiers.length === state.modifiers.length ? state : { ...state, modifiers };\n};\n\nexport const applyModifierQuery = <TContext, TValue>(\n  state: GameState,\n  modifiers: Modifier[],\n  getHook: (hooks: ModifierHooks) => ModifierQueryHook<TContext, TValue> | undefined,\n  context: TContext,\n  base: TValue\n): TValue => {\n  let value = base;\n  for (const modifier of modifiers) {\n    if (!isModifierActive(modifier)) {\n      continue;\n    }\n    const hooks = getHooks(modifier);\n    if (!hooks) {\n      continue;\n    }\n    const hook = getHook(hooks);\n    if (!hook) {\n      continue;\n    }\n    value = hook({ ...context, modifier, state }, value);\n  }\n  return value;\n};\n\nexport const getMoveRequiresBridge = (\n  state: GameState,\n  context: MoveContext,\n  base: boolean\n): boolean => {\n  return applyModifierQuery(\n    state,\n    state.modifiers,\n    (hooks) => hooks.getMoveRequiresBridge,\n    context,\n    base\n  );\n};\n\nexport const getMoveAdjacency = (\n  state: GameState,\n  context: MoveContext,\n  base: boolean\n): boolean => {\n  return applyModifierQuery(\n    state,\n    state.modifiers,\n    (hooks) => hooks.getMoveAdjacency,\n    context,\n    base\n  );\n};\n\nexport const getMoveMaxDistance = (\n  state: GameState,\n  context: MoveContext,\n  base: number\n): number => {\n  return applyModifierQuery(\n    state,\n    state.modifiers,\n    (hooks) => hooks.getMoveMaxDistance,\n    context,\n    base\n  );\n};\n\nexport const getDeployForcesCount = (\n  state: GameState,\n  context: DeployForcesContext,\n  base: number\n): number => {\n  return applyModifierQuery(\n    state,\n    state.modifiers,\n    (hooks) => hooks.getDeployForcesCount,\n    context,\n    base\n  );\n};\n\nexport const getChampionKillBonusGold = (\n  state: GameState,\n  context: ChampionKillContext,\n  base: number\n): number => {\n  return applyModifierQuery(\n    state,\n    state.modifiers,\n    (hooks) => hooks.getChampionKillBonusGold,\n    context,\n    base\n  );\n};\n\nexport const getChampionKillStealGold = (\n  state: GameState,\n  context: ChampionKillContext,\n  base: number\n): number => {\n  return applyModifierQuery(\n    state,\n    state.modifiers,\n    (hooks) => hooks.getChampionKillStealGold,\n    context,\n    base\n  );\n};\n\nexport const getCardChoiceCount = (\n  state: GameState,\n  context: CardChoiceContext,\n  base: number\n): number => {\n  return applyModifierQuery(\n    state,\n    state.modifiers,\n    (hooks) => hooks.getCardChoiceCount,\n    context,\n    base\n  );\n};\n\nexport const getControlValue = (\n  state: GameState,\n  context: ControlValueContext,\n  base: number\n): number => {\n  return applyModifierQuery(\n    state,\n    state.modifiers,\n    (hooks) => hooks.getControlValue,\n    context,\n    base\n  );\n};\n\nexport const getControlBonus = (\n  state: GameState,\n  context: ControlBonusContext,\n  base: number\n): number => {\n  return applyModifierQuery(\n    state,\n    state.modifiers,\n    (hooks) => hooks.getControlBonus,\n    context,\n    base\n  );\n};\n\nexport const runModifierEvents = <TContext>(\n  state: GameState,\n  modifiers: Modifier[],\n  getHook: (hooks: ModifierHooks) => ModifierEventHook<TContext> | undefined,\n  context: TContext\n): GameState => {\n  let nextState = state;\n  for (const modifier of modifiers) {\n    if (!isModifierActive(modifier)) {\n      continue;\n    }\n    const hooks = getHooks(modifier);\n    if (!hooks) {\n      continue;\n    }\n    const hook = getHook(hooks);\n    if (!hook) {\n      continue;\n    }\n    nextState = hook({ ...context, modifier, state: nextState });\n    nextState = consumeModifierUse(nextState, modifier.id);\n  }\n  return nextState;\n};\n\nexport const runMoveEvents = (state: GameState, context: MoveContext): GameState => {\n  return runModifierEvents(state, state.modifiers, (hooks) => hooks.onMove, context);\n};\n\nexport type {\n  CardChoiceContext,\n  CardDrawContext,\n  CombatAssignmentContext,\n  CombatEndContext,\n  CombatRoundContext,\n  CombatUnitContext,\n  ControlBonusContext,\n  ControlValueContext,\n  DeployForcesContext,\n  MoveContext,\n  RoundEndContext\n};\n", "import type { GameState, PlayerID } from \"./types\";\n\nexport const MOVED_THIS_ROUND_FLAG = \"movedThisRound\";\nexport const CARDS_PLAYED_THIS_ROUND_FLAG = \"cardsPlayedThisRound\";\nexport const CARDS_DISCARDED_THIS_ROUND_FLAG = \"cardsDiscardedThisRound\";\n\nconst readCardsPlayedThisRound = (player: GameState[\"players\"][number]): number => {\n  const raw = player.flags[CARDS_PLAYED_THIS_ROUND_FLAG];\n  if (typeof raw !== \"number\" || !Number.isFinite(raw)) {\n    return 0;\n  }\n  return Math.max(0, Math.floor(raw));\n};\n\nconst readCardsDiscardedThisRound = (player: GameState[\"players\"][number]): number => {\n  const raw = player.flags[CARDS_DISCARDED_THIS_ROUND_FLAG];\n  if (typeof raw !== \"number\" || !Number.isFinite(raw)) {\n    return 0;\n  }\n  return Math.max(0, Math.floor(raw));\n};\n\nexport const hasPlayerMovedThisRound = (state: GameState, playerId: PlayerID): boolean => {\n  const player = state.players.find((entry) => entry.id === playerId);\n  return Boolean(player?.flags[MOVED_THIS_ROUND_FLAG]);\n};\n\nexport const markPlayerMovedThisRound = (state: GameState, playerId: PlayerID): GameState => {\n  const index = state.players.findIndex((entry) => entry.id === playerId);\n  if (index < 0) {\n    return state;\n  }\n\n  const player = state.players[index];\n  if (player.flags[MOVED_THIS_ROUND_FLAG] === true) {\n    return state;\n  }\n\n  const nextPlayers = [...state.players];\n  nextPlayers[index] = {\n    ...player,\n    flags: {\n      ...player.flags,\n      [MOVED_THIS_ROUND_FLAG]: true\n    }\n  };\n\n  return {\n    ...state,\n    players: nextPlayers\n  };\n};\n\nexport const getCardsPlayedThisRound = (state: GameState, playerId: PlayerID): number => {\n  const player = state.players.find((entry) => entry.id === playerId);\n  return player ? readCardsPlayedThisRound(player) : 0;\n};\n\nexport const getCardsDiscardedThisRound = (state: GameState, playerId: PlayerID): number => {\n  const player = state.players.find((entry) => entry.id === playerId);\n  return player ? readCardsDiscardedThisRound(player) : 0;\n};\n\nexport const incrementCardsPlayedThisRound = (\n  state: GameState,\n  playerId: PlayerID,\n  amount = 1\n): GameState => {\n  if (!Number.isFinite(amount) || amount <= 0) {\n    return state;\n  }\n\n  const index = state.players.findIndex((entry) => entry.id === playerId);\n  if (index < 0) {\n    return state;\n  }\n\n  const player = state.players[index];\n  const nextCount = readCardsPlayedThisRound(player) + Math.floor(amount);\n  if (player.flags[CARDS_PLAYED_THIS_ROUND_FLAG] === nextCount) {\n    return state;\n  }\n\n  const nextPlayers = [...state.players];\n  nextPlayers[index] = {\n    ...player,\n    flags: {\n      ...player.flags,\n      [CARDS_PLAYED_THIS_ROUND_FLAG]: nextCount\n    }\n  };\n\n  return {\n    ...state,\n    players: nextPlayers\n  };\n};\n\nexport const incrementCardsDiscardedThisRound = (\n  state: GameState,\n  playerId: PlayerID,\n  amount = 1\n): GameState => {\n  if (!Number.isFinite(amount) || amount <= 0) {\n    return state;\n  }\n\n  const index = state.players.findIndex((entry) => entry.id === playerId);\n  if (index < 0) {\n    return state;\n  }\n\n  const player = state.players[index];\n  const nextCount = readCardsDiscardedThisRound(player) + Math.floor(amount);\n  if (player.flags[CARDS_DISCARDED_THIS_ROUND_FLAG] === nextCount) {\n    return state;\n  }\n\n  const nextPlayers = [...state.players];\n  nextPlayers[index] = {\n    ...player,\n    flags: {\n      ...player.flags,\n      [CARDS_DISCARDED_THIS_ROUND_FLAG]: nextCount\n    }\n  };\n\n  return {\n    ...state,\n    players: nextPlayers\n  };\n};\n", "import { randInt, shuffle } from \"@bridgefront/shared\";\n\nimport type {\n  CardDefId,\n  CardDrawContext,\n  CardInstanceID,\n  GameState,\n  PlayerID\n} from \"./types\";\nimport { getCardDef } from \"./content/cards\";\nimport type { EffectSpec } from \"./content/cards\";\nimport { runModifierEvents } from \"./modifiers\";\nimport { incrementCardsDiscardedThisRound } from \"./player-flags\";\n\nconst getPlayer = (state: GameState, playerId: PlayerID) => {\n  const player = state.players.find((entry) => entry.id === playerId);\n  if (!player) {\n    throw new Error(`player not found: ${playerId}`);\n  }\n  return player;\n};\n\nconst updatePlayerDeck = (\n  state: GameState,\n  playerId: PlayerID,\n  deckUpdate: Partial<GameState[\"players\"][number][\"deck\"]>\n): GameState => {\n  return {\n    ...state,\n    players: state.players.map((player) =>\n      player.id === playerId ? { ...player, deck: { ...player.deck, ...deckUpdate } } : player\n    )\n  };\n};\n\nconst addPermanentVp = (state: GameState, playerId: PlayerID, amount: number): GameState => {\n  if (!Number.isFinite(amount) || amount <= 0) {\n    return state;\n  }\n\n  return {\n    ...state,\n    players: state.players.map((player) =>\n      player.id === playerId\n        ? {\n            ...player,\n            vp: {\n              ...player.vp,\n              permanent: player.vp.permanent + amount\n            }\n          }\n        : player\n    )\n  };\n};\n\nconst adjustGold = (state: GameState, playerId: PlayerID, delta: number): GameState => {\n  if (!Number.isFinite(delta) || delta === 0) {\n    return state;\n  }\n\n  return {\n    ...state,\n    players: state.players.map((player) =>\n      player.id === playerId\n        ? {\n            ...player,\n            resources: {\n              ...player.resources,\n              gold: Math.max(0, player.resources.gold + delta)\n            }\n          }\n        : player\n    )\n  };\n};\n\nconst applyCardDrawEffects = (\n  state: GameState,\n  playerId: PlayerID,\n  effects?: EffectSpec[]\n): GameState => {\n  if (!effects || effects.length === 0) {\n    return state;\n  }\n\n  let nextState = state;\n  for (const effect of effects) {\n    switch (effect.kind) {\n      case \"gainGold\": {\n        const amount = typeof effect.amount === \"number\" ? Math.floor(effect.amount) : 0;\n        if (amount > 0) {\n          nextState = adjustGold(nextState, playerId, amount);\n        }\n        break;\n      }\n      case \"loseGold\": {\n        const amount = typeof effect.amount === \"number\" ? Math.floor(effect.amount) : 0;\n        if (amount > 0) {\n          nextState = adjustGold(nextState, playerId, -amount);\n        }\n        break;\n      }\n      default:\n        break;\n    }\n  }\n  return nextState;\n};\n\nconst applyCardDrawTriggers = (\n  state: GameState,\n  playerId: PlayerID,\n  cardInstanceId: CardInstanceID,\n  destination: CardDrawContext[\"destination\"]\n): GameState => {\n  const instance = state.cardsByInstanceId[cardInstanceId];\n  if (!instance) {\n    return state;\n  }\n\n  const context: CardDrawContext = {\n    playerId,\n    cardInstanceId,\n    cardDefId: instance.defId,\n    destination\n  };\n\n  let nextState = runModifierEvents(state, state.modifiers, (hooks) => hooks.onCardDraw, context);\n  const cardDef = getCardDef(instance.defId);\n  nextState = applyCardDrawEffects(nextState, playerId, cardDef?.onDraw);\n  return nextState;\n};\n\ntype DiscardOptions = {\n  countAsDiscard?: boolean;\n};\n\nexport const createCardInstances = (\n  state: GameState,\n  defIds: CardDefId[]\n): { state: GameState; instanceIds: CardInstanceID[] } => {\n  let nextIndex = Object.keys(state.cardsByInstanceId).length + 1;\n  const instanceIds: CardInstanceID[] = [];\n  const cardsByInstanceId = { ...state.cardsByInstanceId };\n\n  for (const defId of defIds) {\n    const instanceId = `ci_${nextIndex}`;\n    nextIndex += 1;\n    cardsByInstanceId[instanceId] = { id: instanceId, defId };\n    instanceIds.push(instanceId);\n  }\n\n  return {\n    state: { ...state, cardsByInstanceId },\n    instanceIds\n  };\n};\n\nexport const createCardInstance = (\n  state: GameState,\n  defId: CardDefId\n): { state: GameState; instanceId: CardInstanceID } => {\n  const { state: nextState, instanceIds } = createCardInstances(state, [defId]);\n  return { state: nextState, instanceId: instanceIds[0] };\n};\n\nexport const shuffleCardIds = (\n  state: GameState,\n  cardIds: CardInstanceID[]\n): { state: GameState; cardIds: CardInstanceID[] } => {\n  const { value, next } = shuffle(state.rngState, cardIds);\n  return { state: { ...state, rngState: next }, cardIds: value };\n};\n\nexport const takeTopCards = (\n  state: GameState,\n  playerId: PlayerID,\n  count: number\n): { state: GameState; cards: CardInstanceID[] } => {\n  if (count <= 0) {\n    return { state, cards: [] };\n  }\n\n  let nextState = state;\n  const cards: CardInstanceID[] = [];\n\n  for (let i = 0; i < count; i += 1) {\n    let player = getPlayer(nextState, playerId);\n    let { drawPile, discardPile } = player.deck;\n\n    if (drawPile.length === 0) {\n      if (discardPile.length === 0) {\n        break;\n      }\n      const shuffled = shuffleCardIds(nextState, discardPile);\n      nextState = updatePlayerDeck(shuffled.state, playerId, {\n        drawPile: shuffled.cardIds,\n        discardPile: []\n      });\n      player = getPlayer(nextState, playerId);\n      ({ drawPile } = player.deck);\n    }\n\n    if (drawPile.length === 0) {\n      break;\n    }\n\n    const [top, ...rest] = drawPile;\n    cards.push(top);\n    nextState = updatePlayerDeck(nextState, playerId, { drawPile: rest });\n  }\n\n  return { state: nextState, cards };\n};\n\nexport const insertCardIntoDrawPileRandom = (\n  state: GameState,\n  playerId: PlayerID,\n  instanceId: CardInstanceID\n): GameState => {\n  const player = getPlayer(state, playerId);\n  const { value: insertIndex, next } = randInt(\n    state.rngState,\n    0,\n    player.deck.drawPile.length\n  );\n  const drawPile = player.deck.drawPile.slice();\n  drawPile.splice(insertIndex, 0, instanceId);\n\n  let nextState = updatePlayerDeck({ ...state, rngState: next }, playerId, { drawPile });\n  const defId = state.cardsByInstanceId[instanceId]?.defId;\n  const cardDef = defId ? getCardDef(defId) : undefined;\n  if (cardDef?.type === \"Victory\") {\n    const victoryPoints = cardDef.victoryPoints ?? 1;\n    if (victoryPoints !== 0) {\n      nextState = addPermanentVp(nextState, playerId, victoryPoints);\n    }\n  }\n  return nextState;\n};\n\nexport const addCardToHandWithOverflow = (\n  state: GameState,\n  playerId: PlayerID,\n  cardInstanceId: CardInstanceID\n): GameState => {\n  const player = getPlayer(state, playerId);\n  if (player.deck.hand.length >= state.config.HAND_LIMIT) {\n    const nextState = addCardToDiscardPile(state, playerId, cardInstanceId, {\n      countAsDiscard: true\n    });\n    return applyCardDrawTriggers(nextState, playerId, cardInstanceId, \"discard\");\n  }\n\n  const nextState = updatePlayerDeck(state, playerId, {\n    hand: [...player.deck.hand, cardInstanceId]\n  });\n  return applyCardDrawTriggers(nextState, playerId, cardInstanceId, \"hand\");\n};\n\nexport const drawCards = (\n  state: GameState,\n  playerId: PlayerID,\n  count: number\n): GameState => {\n  if (count <= 0) {\n    return state;\n  }\n\n  let nextState = state;\n  for (let i = 0; i < count; i += 1) {\n    let player = getPlayer(nextState, playerId);\n    let { drawPile, discardPile, hand } = player.deck;\n\n    if (drawPile.length === 0) {\n      if (discardPile.length === 0) {\n        return nextState;\n      }\n      const shuffled = shuffleCardIds(nextState, discardPile);\n      nextState = updatePlayerDeck(shuffled.state, playerId, {\n        drawPile: shuffled.cardIds,\n        discardPile: []\n      });\n      player = getPlayer(nextState, playerId);\n      ({ drawPile, discardPile, hand } = player.deck);\n    }\n\n    if (drawPile.length === 0) {\n      return nextState;\n    }\n\n    const [top, ...rest] = drawPile;\n    if (hand.length >= nextState.config.HAND_LIMIT) {\n      nextState = updatePlayerDeck(nextState, playerId, {\n        drawPile: rest,\n        discardPile,\n        hand\n      });\n      nextState = addCardToDiscardPile(nextState, playerId, top, { countAsDiscard: true });\n      nextState = applyCardDrawTriggers(nextState, playerId, top, \"discard\");\n      player = getPlayer(nextState, playerId);\n      ({ drawPile, discardPile, hand } = player.deck);\n      continue;\n    }\n\n    hand = [...hand, top];\n\n    nextState = updatePlayerDeck(nextState, playerId, {\n      drawPile: rest,\n      discardPile,\n      hand\n    });\n    nextState = applyCardDrawTriggers(nextState, playerId, top, \"hand\");\n  }\n\n  return nextState;\n};\n\nexport const drawToHandSize = (\n  state: GameState,\n  playerId: PlayerID,\n  targetHandSize: number\n): GameState => {\n  const player = getPlayer(state, playerId);\n  const needed = Math.max(0, targetHandSize - player.deck.hand.length);\n  return drawCards(state, playerId, needed);\n};\n\nexport const removeCardFromHand = (\n  state: GameState,\n  playerId: PlayerID,\n  cardInstanceId: CardInstanceID\n): GameState => {\n  const player = getPlayer(state, playerId);\n  if (!player.deck.hand.includes(cardInstanceId)) {\n    return state;\n  }\n\n  const hand = player.deck.hand.filter((id) => id !== cardInstanceId);\n  return updatePlayerDeck(state, playerId, { hand });\n};\n\nexport const discardCardFromHand = (\n  state: GameState,\n  playerId: PlayerID,\n  cardInstanceId: CardInstanceID,\n  options: DiscardOptions = { countAsDiscard: true }\n): GameState => {\n  const player = getPlayer(state, playerId);\n  if (!player.deck.hand.includes(cardInstanceId)) {\n    return state;\n  }\n\n  let nextState = removeCardFromHand(state, playerId, cardInstanceId);\n  nextState = addCardToDiscardPile(nextState, playerId, cardInstanceId, options);\n  return nextState;\n};\n\nexport const topdeckCardFromHand = (\n  state: GameState,\n  playerId: PlayerID,\n  cardInstanceId: CardInstanceID\n): GameState => {\n  const player = getPlayer(state, playerId);\n  if (!player.deck.hand.includes(cardInstanceId)) {\n    return state;\n  }\n\n  const hand = player.deck.hand.filter((id) => id !== cardInstanceId);\n  return updatePlayerDeck(state, playerId, {\n    hand,\n    drawPile: [cardInstanceId, ...player.deck.drawPile]\n  });\n};\n\nexport const scrapCardFromHand = (\n  state: GameState,\n  playerId: PlayerID,\n  cardInstanceId: CardInstanceID\n): GameState => {\n  const player = getPlayer(state, playerId);\n  if (!player.deck.hand.includes(cardInstanceId)) {\n    return state;\n  }\n\n  const hand = player.deck.hand.filter((id) => id !== cardInstanceId);\n  return updatePlayerDeck(state, playerId, {\n    hand,\n    scrapped: [...player.deck.scrapped, cardInstanceId]\n  });\n};\n\nexport const addCardToDiscardPile = (\n  state: GameState,\n  playerId: PlayerID,\n  cardInstanceId: CardInstanceID,\n  options: DiscardOptions = {}\n): GameState => {\n  const player = getPlayer(state, playerId);\n  const nextState = updatePlayerDeck(state, playerId, {\n    discardPile: [...player.deck.discardPile, cardInstanceId]\n  });\n  if (options.countAsDiscard) {\n    return incrementCardsDiscardedThisRound(nextState, playerId);\n  }\n  return nextState;\n};\n\nexport const addCardToBurned = (\n  state: GameState,\n  playerId: PlayerID,\n  cardInstanceId: CardInstanceID\n): GameState => {\n  return {\n    ...state,\n    players: state.players.map((player) =>\n      player.id === playerId ? { ...player, burned: [...player.burned, cardInstanceId] } : player\n    )\n  };\n};\n", "import type { GameEvent, GameState } from \"./types\";\n\nconst MAX_LOGS = 200;\n\nexport const emit = (state: GameState, event: GameEvent): GameState => {\n  const logs = [...state.logs, event];\n  if (logs.length <= MAX_LOGS) {\n    return { ...state, logs };\n  }\n  return { ...state, logs: logs.slice(logs.length - MAX_LOGS) };\n};\n", "import type { GameState, Modifier, PlayerID } from \"./types\";\nimport { isOccupiedByPlayer } from \"./board\";\nimport { hasPlayerMovedThisRound } from \"./player-flags\";\n\nconst buildModifierId = (factionId: string, playerId: PlayerID, key: string) =>\n  `faction.${factionId}.${playerId}.${key}`;\n\nconst createBastionShieldWallModifier = (playerId: PlayerID): Modifier => ({\n  id: buildModifierId(\"bastion\", playerId, \"shield_wall\"),\n  source: { type: \"faction\", sourceId: \"bastion\" },\n  ownerPlayerId: playerId,\n  duration: { type: \"permanent\" },\n  hooks: {\n    getForceHitFaces: ({ modifier, unit, defenderPlayerId, round }, current) => {\n      if (unit.kind !== \"force\") {\n        return current;\n      }\n      if (modifier.ownerPlayerId && modifier.ownerPlayerId !== unit.ownerPlayerId) {\n        return current;\n      }\n      if (defenderPlayerId !== unit.ownerPlayerId) {\n        return current;\n      }\n      if (round !== 1) {\n        return current;\n      }\n      return Math.max(current, 3);\n    }\n  }\n});\n\nconst createBastionHomeGuardModifier = (playerId: PlayerID): Modifier => ({\n  id: buildModifierId(\"bastion\", playerId, \"home_guard\"),\n  source: { type: \"faction\", sourceId: \"bastion\" },\n  ownerPlayerId: playerId,\n  duration: { type: \"permanent\" },\n  hooks: {\n    getDeployForcesCount: ({ modifier, playerId: deployerId, hexKey, state }, current) => {\n      if (modifier.ownerPlayerId && modifier.ownerPlayerId !== deployerId) {\n        return current;\n      }\n      if (current <= 0) {\n        return current;\n      }\n      const player = state.players.find((entry) => entry.id === deployerId);\n      if (!player?.capitalHex || player.capitalHex !== hexKey) {\n        return current;\n      }\n      return current + 1;\n    }\n  }\n});\n\nconst createProspectOreCutModifier = (playerId: PlayerID): Modifier => ({\n  id: buildModifierId(\"prospect\", playerId, \"ore_cut\"),\n  source: { type: \"faction\", sourceId: \"prospect\" },\n  ownerPlayerId: playerId,\n  duration: { type: \"permanent\" },\n  hooks: {\n    getMineGoldValue: ({ modifier, playerId: collectingPlayerId, mineValue }, current) => {\n      if (modifier.ownerPlayerId && modifier.ownerPlayerId !== collectingPlayerId) {\n        return current;\n      }\n      return current + 1;\n    }\n  }\n});\n\nconst createProspectMineMilitiaModifier = (playerId: PlayerID): Modifier => ({\n  id: buildModifierId(\"prospect\", playerId, \"mine_militia\"),\n  source: { type: \"faction\", sourceId: \"prospect\" },\n  ownerPlayerId: playerId,\n  duration: { type: \"permanent\" },\n  hooks: {\n    getForceHitFaces: ({ modifier, unit, defenderPlayerId, hexKey, state }, current) => {\n      if (unit.kind !== \"force\") {\n        return current;\n      }\n      if (modifier.ownerPlayerId && modifier.ownerPlayerId !== unit.ownerPlayerId) {\n        return current;\n      }\n      if (defenderPlayerId !== unit.ownerPlayerId) {\n        return current;\n      }\n      const hex = state.board.hexes[hexKey];\n      if (!hex || hex.tile !== \"mine\") {\n        return current;\n      }\n      return Math.max(current, 3);\n    }\n  }\n});\n\nconst createProspectDeepTunnelsModifier = (playerId: PlayerID): Modifier => ({\n  id: buildModifierId(\"prospect\", playerId, \"deep_tunnels\"),\n  source: { type: \"faction\", sourceId: \"prospect\" },\n  ownerPlayerId: playerId,\n  duration: { type: \"permanent\" },\n  hooks: {\n    getMoveAdjacency: ({ modifier, playerId: movingPlayerId, from, to, state }, current) => {\n      if (current) {\n        return current;\n      }\n      if (modifier.ownerPlayerId && modifier.ownerPlayerId !== movingPlayerId) {\n        return current;\n      }\n      const fromHex = state.board.hexes[from];\n      const toHex = state.board.hexes[to];\n      if (!fromHex || !toHex) {\n        return current;\n      }\n      if (fromHex.tile !== \"mine\" || toHex.tile !== \"mine\") {\n        return current;\n      }\n      if (!isOccupiedByPlayer(fromHex, movingPlayerId)) {\n        return current;\n      }\n      if (!isOccupiedByPlayer(toHex, movingPlayerId)) {\n        return current;\n      }\n      return true;\n    }\n  }\n});\n\nconst createAerialTailwindModifier = (playerId: PlayerID): Modifier => ({\n  id: buildModifierId(\"aerial\", playerId, \"tailwind\"),\n  source: { type: \"faction\", sourceId: \"aerial\" },\n  ownerPlayerId: playerId,\n  duration: { type: \"permanent\" },\n  hooks: {\n    getMoveMaxDistance: ({ modifier, playerId: movingPlayerId, state }, current) => {\n      if (modifier.ownerPlayerId && modifier.ownerPlayerId !== movingPlayerId) {\n        return current;\n      }\n      if (current <= 0) {\n        return current;\n      }\n      if (hasPlayerMovedThisRound(state, movingPlayerId)) {\n        return current;\n      }\n      return current + 1;\n    }\n  }\n});\n\nconst createAerialWingsModifier = (playerId: PlayerID): Modifier => ({\n  id: buildModifierId(\"aerial\", playerId, \"wings\"),\n  source: { type: \"faction\", sourceId: \"aerial\" },\n  ownerPlayerId: playerId,\n  duration: { type: \"permanent\" }\n});\n\nconst createCipherExpandedChoiceModifier = (playerId: PlayerID): Modifier => ({\n  id: buildModifierId(\"cipher\", playerId, \"expanded_choice\"),\n  source: { type: \"faction\", sourceId: \"cipher\" },\n  ownerPlayerId: playerId,\n  duration: { type: \"permanent\" },\n  hooks: {\n    getCardChoiceCount: ({ modifier, playerId: choosingPlayerId }, current) => {\n      if (modifier.ownerPlayerId && modifier.ownerPlayerId !== choosingPlayerId) {\n        return current;\n      }\n      if (current <= 0) {\n        return current;\n      }\n      return current + 1;\n    }\n  }\n});\n\nconst createCipherQuietStudyModifier = (playerId: PlayerID): Modifier => ({\n  id: buildModifierId(\"cipher\", playerId, \"quiet_study\"),\n  source: { type: \"faction\", sourceId: \"cipher\" },\n  ownerPlayerId: playerId,\n  duration: { type: \"permanent\" }\n});\n\nconst createVeilCleanExitModifier = (playerId: PlayerID): Modifier => ({\n  id: buildModifierId(\"veil\", playerId, \"clean_exit\"),\n  source: { type: \"faction\", sourceId: \"veil\" },\n  ownerPlayerId: playerId,\n  duration: { type: \"permanent\" },\n  hooks: {\n    afterBattle: ({ state, modifier, attackers, defenders }) => {\n      const ownerId = modifier.ownerPlayerId;\n      if (!ownerId) {\n        return state;\n      }\n\n      const unitIds = new Set<string>([...attackers, ...defenders]);\n      if (unitIds.size === 0) {\n        return state;\n      }\n\n      let updatedUnits: typeof state.board.units | null = null;\n      for (const unitId of unitIds) {\n        const unit = state.board.units[unitId];\n        if (!unit || unit.kind !== \"champion\") {\n          continue;\n        }\n        if (unit.ownerPlayerId !== ownerId) {\n          continue;\n        }\n        const nextHp = Math.min(unit.maxHp, unit.hp + 1);\n        if (nextHp === unit.hp) {\n          continue;\n        }\n        if (!updatedUnits) {\n          updatedUnits = { ...state.board.units };\n        }\n        updatedUnits[unitId] = {\n          ...unit,\n          hp: nextHp\n        };\n      }\n\n      if (!updatedUnits) {\n        return state;\n      }\n\n      return {\n        ...state,\n        board: {\n          ...state.board,\n          units: updatedUnits\n        }\n      };\n    }\n  }\n});\n\nconst createVeilContractsModifier = (playerId: PlayerID): Modifier => ({\n  id: buildModifierId(\"veil\", playerId, \"contracts\"),\n  source: { type: \"faction\", sourceId: \"veil\" },\n  ownerPlayerId: playerId,\n  duration: { type: \"permanent\" },\n  hooks: {\n    getChampionKillBonusGold: ({ modifier, killerPlayerId, killedChampions }, current) => {\n      if (modifier.ownerPlayerId && modifier.ownerPlayerId !== killerPlayerId) {\n        return current;\n      }\n      if (killedChampions.length === 0) {\n        return current;\n      }\n      return current + killedChampions.length * 2;\n    }\n  }\n});\n\nconst createGatewrightCapitalAssaultModifier = (playerId: PlayerID): Modifier => ({\n  id: buildModifierId(\"gatewright\", playerId, \"capital_assault\"),\n  source: { type: \"faction\", sourceId: \"gatewright\" },\n  ownerPlayerId: playerId,\n  duration: { type: \"permanent\" },\n  hooks: {\n    getForceHitFaces: ({ modifier, unit, hexKey, state }, current) => {\n      if (unit.kind !== \"force\") {\n        return current;\n      }\n      if (modifier.ownerPlayerId && modifier.ownerPlayerId !== unit.ownerPlayerId) {\n        return current;\n      }\n      const hex = state.board.hexes[hexKey];\n      if (!hex || hex.tile !== \"capital\") {\n        return current;\n      }\n      if (!hex.ownerPlayerId || hex.ownerPlayerId === unit.ownerPlayerId) {\n        return current;\n      }\n      return Math.max(current, 3);\n    }\n  }\n});\n\nconst createGatewrightCapitalVpBonusModifier = (playerId: PlayerID): Modifier => ({\n  id: buildModifierId(\"gatewright\", playerId, \"capital_vp_bonus\"),\n  source: { type: \"faction\", sourceId: \"gatewright\" },\n  ownerPlayerId: playerId,\n  duration: { type: \"permanent\" },\n  hooks: {\n    getControlValue: ({ modifier, playerId: occupantId, hexKey, tile, state }, current) => {\n      if (modifier.ownerPlayerId && modifier.ownerPlayerId !== occupantId) {\n        return current;\n      }\n      if (tile !== \"capital\") {\n        return current;\n      }\n      const hex = state.board.hexes[hexKey];\n      if (!hex || !hex.ownerPlayerId || hex.ownerPlayerId === occupantId) {\n        return current;\n      }\n      return Math.max(current, 2);\n    }\n  }\n});\n\nconst createGatewrightExtortionistsModifier = (playerId: PlayerID): Modifier => ({\n  id: buildModifierId(\"gatewright\", playerId, \"extortionists\"),\n  source: { type: \"faction\", sourceId: \"gatewright\" },\n  ownerPlayerId: playerId,\n  duration: { type: \"permanent\" },\n  hooks: {\n    afterBattle: ({ state, modifier, winnerPlayerId, attackerPlayerId, defenderPlayerId }) => {\n      const ownerId = modifier.ownerPlayerId;\n      if (!ownerId || winnerPlayerId !== ownerId) {\n        return state;\n      }\n\n      const loserId = winnerPlayerId === attackerPlayerId ? defenderPlayerId : attackerPlayerId;\n      const loser = state.players.find((player) => player.id === loserId);\n      if (!loser) {\n        return state;\n      }\n\n      const steal = Math.min(2, loser.resources.gold);\n      if (steal <= 0) {\n        return state;\n      }\n\n      const nextPlayers = state.players.map((player) => {\n        if (player.id === loserId) {\n          return {\n            ...player,\n            resources: {\n              ...player.resources,\n              gold: player.resources.gold - steal\n            }\n          };\n        }\n        if (player.id === ownerId) {\n          return {\n            ...player,\n            resources: {\n              ...player.resources,\n              gold: player.resources.gold + steal\n            }\n          };\n        }\n        return player;\n      });\n\n      return {\n        ...state,\n        players: nextPlayers\n      };\n    }\n  }\n});\n\nexport const createFactionModifiers = (factionId: string, playerId: PlayerID): Modifier[] => {\n  switch (factionId) {\n    case \"bastion\":\n      return [\n        createBastionShieldWallModifier(playerId),\n        createBastionHomeGuardModifier(playerId)\n      ];\n    case \"veil\":\n      return [createVeilCleanExitModifier(playerId), createVeilContractsModifier(playerId)];\n    case \"prospect\":\n      return [\n        createProspectOreCutModifier(playerId),\n        createProspectMineMilitiaModifier(playerId),\n        createProspectDeepTunnelsModifier(playerId)\n      ];\n    case \"aerial\":\n      return [createAerialTailwindModifier(playerId), createAerialWingsModifier(playerId)];\n    case \"cipher\":\n      return [\n        createCipherExpandedChoiceModifier(playerId),\n        createCipherQuietStudyModifier(playerId)\n      ];\n    case \"gatewright\":\n      return [\n        createGatewrightCapitalAssaultModifier(playerId),\n        createGatewrightCapitalVpBonusModifier(playerId),\n        createGatewrightExtortionistsModifier(playerId)\n      ];\n    default:\n      return [];\n  }\n};\n\nexport const hasAerialWings = (state: GameState, playerId: PlayerID): boolean => {\n  const targetId = buildModifierId(\"aerial\", playerId, \"wings\");\n  return state.modifiers.some((modifier) => modifier.id === targetId);\n};\n\nexport const hasCipherQuietStudy = (state: GameState, playerId: PlayerID): boolean => {\n  const targetId = buildModifierId(\"cipher\", playerId, \"quiet_study\");\n  return state.modifiers.some((modifier) => modifier.id === targetId);\n};\n\nexport const addFactionModifiers = (\n  state: GameState,\n  playerId: PlayerID,\n  factionId: string\n): GameState => {\n  const modifiers = createFactionModifiers(factionId, playerId);\n  if (modifiers.length === 0) {\n    return state;\n  }\n  const existing = new Set(state.modifiers.map((modifier) => modifier.id));\n  const nextModifiers = [...state.modifiers];\n  for (const modifier of modifiers) {\n    if (!existing.has(modifier.id)) {\n      nextModifiers.push(modifier);\n    }\n  }\n  if (nextModifiers.length === state.modifiers.length) {\n    return state;\n  }\n  return { ...state, modifiers: nextModifiers };\n};\n", "import type { BoardState, CardDefId, HexKey, PlayerID, UnitID } from \"./types\";\n\ntype ForceCountOptions = {\n  allowZero?: boolean;\n};\n\nconst normalizeForceCount = (\n  forceCount?: number,\n  options?: ForceCountOptions\n): number | null => {\n  if (typeof forceCount !== \"number\" || !Number.isFinite(forceCount)) {\n    return null;\n  }\n  const normalized = Math.floor(forceCount);\n  if (normalized > 0) {\n    return normalized;\n  }\n  if (options?.allowZero && normalized === 0) {\n    return 0;\n  }\n  return null;\n};\n\nconst getForceUnitsAtHex = (\n  board: BoardState,\n  playerId: PlayerID,\n  hexKey: HexKey\n): UnitID[] => {\n  const hex = board.hexes[hexKey];\n  if (!hex) {\n    return [];\n  }\n  const occupants = hex.occupants[playerId] ?? [];\n  const forceUnits: UnitID[] = [];\n  for (const unitId of occupants) {\n    if (board.units[unitId]?.kind === \"force\") {\n      forceUnits.push(unitId);\n    }\n  }\n  return forceUnits;\n};\n\nconst getChampionUnitsAtHex = (\n  board: BoardState,\n  playerId: PlayerID,\n  hexKey: HexKey\n): UnitID[] => {\n  const hex = board.hexes[hexKey];\n  if (!hex) {\n    return [];\n  }\n  const occupants = hex.occupants[playerId] ?? [];\n  const championUnits: UnitID[] = [];\n  for (const unitId of occupants) {\n    if (board.units[unitId]?.kind === \"champion\") {\n      championUnits.push(unitId);\n    }\n  }\n  return championUnits;\n};\n\nexport const selectMovingUnits = (\n  board: BoardState,\n  playerId: PlayerID,\n  from: HexKey,\n  forceCount?: number,\n  includeChampions?: boolean\n): UnitID[] => {\n  const fromHex = board.hexes[from];\n  if (!fromHex) {\n    return [];\n  }\n  const occupants = fromHex.occupants[playerId] ?? [];\n  const include =\n    typeof includeChampions === \"boolean\" ? includeChampions : forceCount == null;\n  if (forceCount === undefined || forceCount === null) {\n    return include ? occupants : getForceUnitsAtHex(board, playerId, from);\n  }\n  const normalized = normalizeForceCount(forceCount, { allowZero: include });\n  if (normalized === null) {\n    return [];\n  }\n  const forceUnits = getForceUnitsAtHex(board, playerId, from);\n  if (forceUnits.length < normalized) {\n    return [];\n  }\n  const selectedForces = forceUnits.slice(0, normalized);\n  if (!include) {\n    return selectedForces;\n  }\n  const championUnits = getChampionUnitsAtHex(board, playerId, from);\n  return [...selectedForces, ...championUnits];\n};\n\ntype ChampionDeployment = {\n  cardDefId: CardDefId;\n  hp: number;\n  attackDice: number;\n  hitFaces: number;\n  bounty: number;\n};\n\nexport const addForcesToHex = (\n  board: BoardState,\n  playerId: PlayerID,\n  hexKey: HexKey,\n  count: number\n): BoardState => {\n  if (count <= 0) {\n    return board;\n  }\n\n  const hex = board.hexes[hexKey];\n  if (!hex) {\n    throw new Error(\"hex does not exist\");\n  }\n\n  // Scan existing force ids to avoid collisions when units are removed.\n  let maxForceIndex = 0;\n  for (const unitId of Object.keys(board.units)) {\n    if (!unitId.startsWith(\"u_\")) {\n      continue;\n    }\n    const parsed = Number(unitId.slice(2));\n    if (Number.isInteger(parsed) && parsed > maxForceIndex) {\n      maxForceIndex = parsed;\n    }\n  }\n  let nextIndex = maxForceIndex + 1;\n  const units = { ...board.units };\n  const newUnitIds: UnitID[] = [];\n\n  for (let i = 0; i < count; i += 1) {\n    const unitId = `u_${nextIndex}`;\n    nextIndex += 1;\n    units[unitId] = {\n      id: unitId,\n      ownerPlayerId: playerId,\n      kind: \"force\",\n      hex: hexKey\n    };\n    newUnitIds.push(unitId);\n  }\n\n  return {\n    ...board,\n    units,\n    hexes: {\n      ...board.hexes,\n      [hexKey]: {\n        ...hex,\n        occupants: {\n          ...hex.occupants,\n          [playerId]: [...(hex.occupants[playerId] ?? []), ...newUnitIds]\n        }\n      }\n    }\n  };\n};\n\nexport const countPlayerChampions = (board: BoardState, playerId: PlayerID): number => {\n  return Object.values(board.units).filter(\n    (unit) => unit.kind === \"champion\" && unit.ownerPlayerId === playerId\n  ).length;\n};\n\nexport const addChampionToHex = (\n  board: BoardState,\n  playerId: PlayerID,\n  hexKey: HexKey,\n  champion: ChampionDeployment\n): { board: BoardState; unitId: UnitID } => {\n  const hex = board.hexes[hexKey];\n  if (!hex) {\n    throw new Error(\"hex does not exist\");\n  }\n\n  let maxChampionIndex = 0;\n  for (const unitId of Object.keys(board.units)) {\n    if (!unitId.startsWith(\"c_\")) {\n      continue;\n    }\n    const parsed = Number(unitId.slice(2));\n    if (Number.isInteger(parsed) && parsed > maxChampionIndex) {\n      maxChampionIndex = parsed;\n    }\n  }\n  const unitId = `c_${maxChampionIndex + 1}`;\n\n  return {\n    board: {\n      ...board,\n      units: {\n        ...board.units,\n        [unitId]: {\n          id: unitId,\n          ownerPlayerId: playerId,\n          kind: \"champion\",\n          hex: hexKey,\n          cardDefId: champion.cardDefId,\n          hp: champion.hp,\n          maxHp: champion.hp,\n          attackDice: champion.attackDice,\n          hitFaces: champion.hitFaces,\n          bounty: champion.bounty,\n          abilityUses: {}\n        }\n      },\n      hexes: {\n        ...board.hexes,\n        [hexKey]: {\n          ...hex,\n          occupants: {\n            ...hex.occupants,\n            [playerId]: [...(hex.occupants[playerId] ?? []), unitId]\n          }\n        }\n      }\n    },\n    unitId\n  };\n};\n\nexport const moveUnitToHex = (\n  board: BoardState,\n  unitId: UnitID,\n  to: HexKey\n): BoardState => {\n  const unit = board.units[unitId];\n  if (!unit) {\n    return board;\n  }\n  if (unit.hex === to) {\n    return board;\n  }\n  const fromHex = board.hexes[unit.hex];\n  const toHex = board.hexes[to];\n  if (!fromHex || !toHex) {\n    return board;\n  }\n\n  const fromUnits = fromHex.occupants[unit.ownerPlayerId] ?? [];\n  const nextFromUnits = fromUnits.filter((entry) => entry !== unitId);\n  const toUnits = toHex.occupants[unit.ownerPlayerId] ?? [];\n  const nextToUnits = toUnits.includes(unitId) ? toUnits : [...toUnits, unitId];\n\n  return {\n    ...board,\n    units: {\n      ...board.units,\n      [unitId]: {\n        ...unit,\n        hex: to\n      }\n    },\n    hexes: {\n      ...board.hexes,\n      [unit.hex]: {\n        ...fromHex,\n        occupants: {\n          ...fromHex.occupants,\n          [unit.ownerPlayerId]: nextFromUnits\n        }\n      },\n      [to]: {\n        ...toHex,\n        occupants: {\n          ...toHex.occupants,\n          [unit.ownerPlayerId]: nextToUnits\n        }\n      }\n    }\n  };\n};\n\nexport const moveStack = (\n  board: BoardState,\n  playerId: PlayerID,\n  from: HexKey,\n  to: HexKey,\n  forceCount?: number,\n  includeChampions?: boolean\n): BoardState => {\n  if (from === to) {\n    return board;\n  }\n\n  const fromHex = board.hexes[from];\n  const toHex = board.hexes[to];\n  if (!fromHex || !toHex) {\n    return board;\n  }\n\n  const movingUnits = selectMovingUnits(\n    board,\n    playerId,\n    from,\n    forceCount,\n    includeChampions\n  );\n  if (movingUnits.length === 0) {\n    return board;\n  }\n\n  const movingSet = new Set(movingUnits);\n  const fromUnits = fromHex.occupants[playerId] ?? [];\n  const remainingUnits = fromUnits.filter((unitId) => !movingSet.has(unitId));\n  const toUnits = [...(toHex.occupants[playerId] ?? []), ...movingUnits];\n\n  const units = { ...board.units };\n  for (const unitId of movingUnits) {\n    const unit = units[unitId];\n    if (!unit) {\n      continue;\n    }\n    units[unitId] = {\n      ...unit,\n      hex: to\n    };\n  }\n\n  return {\n    ...board,\n    units,\n    hexes: {\n      ...board.hexes,\n      [from]: {\n        ...fromHex,\n        occupants: {\n          ...fromHex.occupants,\n          [playerId]: remainingUnits\n        }\n      },\n      [to]: {\n        ...toHex,\n        occupants: {\n          ...toHex.occupants,\n          [playerId]: toUnits\n        }\n      }\n    }\n  };\n};\n", "import {\n  axialDistance,\n  parseEdgeKey,\n  parseHexKey,\n  shuffle\n} from \"@bridgefront/shared\";\n\nimport type {\n  BlockState,\n  CardDefId,\n  GameEvent,\n  GameState,\n  HexKey,\n  PlayerID,\n  PlayerState,\n  SetupChoice\n} from \"./types\";\nimport { getBridgeKey } from \"./board\";\nimport { placeRandomBridges, placeSpecialTiles } from \"./board-generation\";\nimport {\n  createCardInstance,\n  createCardInstances,\n  drawToHandSize,\n  insertCardIntoDrawPileRandom,\n  shuffleCardIds\n} from \"./cards\";\nimport { resolveStarterFactionCards } from \"./content/starter-decks\";\nimport { emit } from \"./events\";\nimport { addFactionModifiers } from \"./faction-passives\";\nimport { getCardChoiceCount } from \"./modifiers\";\nimport { addForcesToHex } from \"./units\";\n\nconst withUpdatedPlayer = (state: GameState, playerId: PlayerID, update: (player: PlayerState) => PlayerState) => {\n  return {\n    ...state,\n    players: state.players.map((player) => (player.id === playerId ? update(player) : player))\n  };\n};\n\nconst getCapitalDraftWaitingFor = (\n  players: PlayerState[],\n  choices: Record<PlayerID, HexKey | null>\n): PlayerID[] => {\n  return players.map((player) => player.id).filter((playerId) => !choices[playerId]);\n};\n\nconst getStartingBridgeWaitingFor = (\n  players: PlayerState[],\n  remaining: Record<PlayerID, number>\n): PlayerID[] => {\n  return players\n    .map((player) => player.id)\n    .filter((playerId) => (remaining[playerId] ?? 0) > 0);\n};\n\nconst getFreeStartingCardWaitingFor = (\n  players: PlayerState[],\n  chosen: Record<PlayerID, CardDefId | null>\n): PlayerID[] => {\n  return players.map((player) => player.id).filter((playerId) => !chosen[playerId]);\n};\n\nexport const createCapitalDraftBlock = (players: PlayerState[], availableSlots: HexKey[]): BlockState => ({\n  type: \"setup.capitalDraft\",\n  waitingFor: players.map((player) => player.id),\n  payload: {\n    availableSlots,\n    choices: Object.fromEntries(players.map((player) => [player.id, null]))\n  }\n});\n\nexport const createDeckPreviewBlock = (): BlockState => ({\n  type: \"setup.deckPreview\",\n  waitingFor: [],\n  payload: {}\n});\n\nexport const createStartingBridgesBlock = (players: PlayerState[]): BlockState => ({\n  type: \"setup.startingBridges\",\n  waitingFor: players.map((player) => player.id),\n  payload: {\n    remaining: Object.fromEntries(players.map((player) => [player.id, 2])),\n    selectedEdges: Object.fromEntries(players.map((player) => [player.id, []]))\n  }\n});\n\nexport const createFreeStartingCardBlock = (\n  state: GameState\n): { state: GameState; block: BlockState } => {\n  const pool = state.config.freeStartingCardPool;\n  const baseOfferCount = 3;\n  const offerCounts = state.players.map((player) => {\n    const rawCount = getCardChoiceCount(\n      state,\n      { playerId: player.id, kind: \"freeStartingCard\", baseCount: baseOfferCount },\n      baseOfferCount\n    );\n    const normalized = Number.isFinite(rawCount) ? Math.floor(rawCount) : baseOfferCount;\n    return {\n      playerId: player.id,\n      count: Math.max(baseOfferCount, normalized)\n    };\n  });\n  const maxOfferCount = offerCounts.reduce(\n    (max, entry) => Math.max(max, entry.count),\n    baseOfferCount\n  );\n  if (pool.length < maxOfferCount) {\n    throw new Error(`freeStartingCardPool must contain at least ${maxOfferCount} cards`);\n  }\n\n  let rngState = state.rngState;\n  const deck: CardDefId[] = [];\n  const minCards = offerCounts.reduce((total, entry) => total + entry.count, 0);\n  while (deck.length < minCards) {\n    deck.push(...pool);\n  }\n  const { value: shuffledDeck, next: shuffledState } = shuffle(rngState, deck);\n  rngState = shuffledState;\n\n  const offers: Record<PlayerID, CardDefId[]> = {};\n  let remainingDeck = shuffledDeck.slice();\n  for (const entry of offerCounts) {\n    const offer = remainingDeck.slice(0, entry.count);\n    if (offer.length < entry.count) {\n      throw new Error(\"freeStartingCardPool must have enough cards for all players\");\n    }\n    offers[entry.playerId] = offer;\n    remainingDeck = remainingDeck.slice(entry.count);\n  }\n\n  return {\n    state: { ...state, rngState },\n    block: {\n      type: \"setup.freeStartingCardPick\",\n      waitingFor: state.players.map((player) => player.id),\n      payload: {\n        offers,\n        chosen: Object.fromEntries(state.players.map((player) => [player.id, null])),\n        remainingDeck\n      }\n    }\n  };\n};\n\nexport const initializeStartingAssets = (state: GameState): GameState => {\n  let nextState = state;\n  const playerIds = state.players.map((player) => player.id);\n\n  for (const playerId of playerIds) {\n    const player = nextState.players.find((entry) => entry.id === playerId);\n    if (!player) {\n      throw new Error(`player not found: ${playerId}`);\n    }\n    if (!player.capitalHex) {\n      throw new Error(\"player has no capital to place starting forces\");\n    }\n\n    nextState = {\n      ...nextState,\n      board: addForcesToHex(nextState.board, playerId, player.capitalHex, 4)\n    };\n\n    const starter = resolveStarterFactionCards(player.factionId);\n    let workingState = nextState;\n    if (starter.factionId !== player.factionId) {\n      workingState = withUpdatedPlayer(workingState, playerId, (entry) => ({\n        ...entry,\n        factionId: starter.factionId\n      }));\n    }\n    workingState = addFactionModifiers(workingState, playerId, starter.factionId);\n\n    const { state: withDeckCards, instanceIds: deckInstances } = createCardInstances(\n      workingState,\n      [...starter.deck, starter.starterSpellId]\n    );\n    const { state: withChampion, instanceIds: championInstances } = createCardInstances(\n      withDeckCards,\n      [starter.championId]\n    );\n    const championInstanceId = championInstances[0];\n\n    const shuffled = shuffleCardIds(withChampion, deckInstances);\n    let updatedState = withUpdatedPlayer(shuffled.state, playerId, (entry) => ({\n      ...entry,\n      deck: {\n        drawPile: shuffled.cardIds,\n        discardPile: [],\n        hand: [championInstanceId],\n        scrapped: []\n      }\n    }));\n\n    updatedState = drawToHandSize(updatedState, playerId, 6);\n    nextState = updatedState;\n  }\n\n  return nextState;\n};\n\nexport const finalizeCapitalDraft = (state: GameState): GameState => {\n  const capitalHexes = state.players.map((player) => {\n    if (!player.capitalHex) {\n      throw new Error(\"player missing capital after draft\");\n    }\n    return player.capitalHex;\n  });\n  const uniqueCapitals = new Set(capitalHexes);\n  if (uniqueCapitals.size !== capitalHexes.length) {\n    throw new Error(\"capital draft resulted in duplicate capitals\");\n  }\n\n  const tileCounts = state.config.tileCountsByPlayerCount[state.players.length];\n  if (!tileCounts) {\n    throw new Error(\"missing tile counts for player count\");\n  }\n\n  const placement = placeSpecialTiles(state.board, state.rngState, {\n    capitalHexes,\n    forgeCount: tileCounts.forges,\n    mineCount: tileCounts.mines,\n    rules: state.config.boardGenerationRules\n  });\n\n  const bridged = placeRandomBridges(placement.board, placement.rngState, {\n    capitalHexes,\n    count: tileCounts.randomBridges,\n    rules: state.config.boardGenerationRules\n  });\n\n  const nextState = {\n    ...state,\n    board: bridged.board,\n    rngState: bridged.rngState\n  };\n\n  return initializeStartingAssets(nextState);\n};\n\nexport const finalizeStartingBridges = (state: GameState): GameState => {\n  const block = state.blocks;\n  if (!block || block.type !== \"setup.startingBridges\") {\n    return state;\n  }\n\n  const selectedEdges = block.payload.selectedEdges;\n  const existing = new Set(Object.keys(state.board.bridges));\n  const nextBridges = { ...state.board.bridges };\n  const events: GameEvent[] = [];\n\n  for (const player of state.players) {\n    const edges = selectedEdges[player.id] ?? [];\n    for (const edgeKey of edges) {\n      const [rawA, rawB] = parseEdgeKey(edgeKey);\n      const canonical = getBridgeKey(rawA, rawB);\n      const alreadyExists = existing.has(canonical);\n      if (!alreadyExists) {\n        existing.add(canonical);\n        nextBridges[canonical] = {\n          key: canonical,\n          from: rawA,\n          to: rawB,\n          ownerPlayerId: player.id\n        };\n      }\n      events.push({\n        type: \"setup.startingBridgePlaced\",\n        payload: { playerId: player.id, edgeKey: canonical, alreadyExists }\n      });\n    }\n  }\n\n  let nextState: GameState = {\n    ...state,\n    board: {\n      ...state.board,\n      bridges: nextBridges\n    }\n  };\n\n  for (const event of events) {\n    nextState = emit(nextState, event);\n  }\n\n  return nextState;\n};\n\nexport const finalizeFreeStartingCardPick = (state: GameState): GameState => {\n  const block = state.blocks;\n  if (!block || block.type !== \"setup.freeStartingCardPick\") {\n    return state;\n  }\n\n  let nextState = state;\n  let remainingDeck = [...block.payload.remainingDeck];\n\n  for (const player of state.players) {\n    const chosen = block.payload.chosen[player.id];\n    if (!chosen) {\n      throw new Error(\"player missing free starting card choice\");\n    }\n    const offers = block.payload.offers[player.id] ?? [];\n    const unchosen = offers.filter((cardId) => cardId !== chosen);\n    if (unchosen.length > 0) {\n      const { value: returnedCards, next } = shuffle(nextState.rngState, unchosen);\n      remainingDeck = [...remainingDeck, ...returnedCards];\n      nextState = { ...nextState, rngState: next };\n    }\n\n    const { state: stateWithCard, instanceId } = createCardInstance(nextState, chosen);\n    nextState = insertCardIntoDrawPileRandom(stateWithCard, player.id, instanceId);\n  }\n\n  return {\n    ...nextState,\n    blocks: {\n      ...block,\n      payload: {\n        ...block.payload,\n        remainingDeck\n      }\n    }\n  };\n};\n\nexport const applySetupChoice = (state: GameState, choice: SetupChoice, playerId: PlayerID): GameState => {\n  const block = state.blocks;\n  if (!block) {\n    throw new Error(\"no active block to accept setup choice\");\n  }\n\n  if (block.type === \"setup.capitalDraft\") {\n    if (choice.kind === \"unlockCapital\") {\n      const pickedHex = block.payload.choices[playerId];\n      if (!pickedHex) {\n        throw new Error(\"player has no capital to unlock\");\n      }\n\n      const hex = state.board.hexes[pickedHex];\n      if (!hex) {\n        throw new Error(\"capital hex does not exist\");\n      }\n\n      const updatedBoard = {\n        ...state.board,\n        hexes: {\n          ...state.board.hexes,\n          [pickedHex]: {\n            ...hex,\n            tile: hex.tile === \"capital\" ? \"normal\" : hex.tile,\n            ownerPlayerId: undefined\n          }\n        }\n      };\n\n      const updatedState = withUpdatedPlayer(state, playerId, (player) => ({\n        ...player,\n        capitalHex: undefined\n      }));\n\n      const updatedChoices = { ...block.payload.choices, [playerId]: null };\n      const nextState = {\n        ...updatedState,\n        board: updatedBoard,\n        blocks: {\n          ...block,\n          waitingFor: getCapitalDraftWaitingFor(state.players, updatedChoices),\n          payload: {\n            ...block.payload,\n            choices: updatedChoices\n          }\n        }\n      };\n\n      return emit(nextState, {\n        type: \"setup.capitalUnlocked\",\n        payload: { playerId, hexKey: pickedHex }\n      });\n    }\n\n    if (choice.kind !== \"pickCapital\") {\n      throw new Error(\"expected pickCapital during capital draft\");\n    }\n    if (block.payload.choices[playerId]) {\n      throw new Error(\"player already locked a capital\");\n    }\n\n    const hexKey = choice.hexKey;\n    if (!block.payload.availableSlots.includes(hexKey)) {\n      throw new Error(\"invalid capital slot\");\n    }\n    if (Object.values(block.payload.choices).includes(hexKey)) {\n      throw new Error(\"capital slot already taken\");\n    }\n\n    const hex = state.board.hexes[hexKey];\n    if (!hex) {\n      throw new Error(\"capital hex does not exist\");\n    }\n    if (hex.tile === \"capital\") {\n      throw new Error(\"hex already marked as capital\");\n    }\n\n    const updatedBoard = {\n      ...state.board,\n      hexes: {\n        ...state.board.hexes,\n        [hexKey]: {\n          ...hex,\n          tile: \"capital\",\n          ownerPlayerId: playerId\n        }\n      }\n    };\n\n    const updatedState = withUpdatedPlayer(state, playerId, (player) => {\n      if (player.capitalHex) {\n        throw new Error(\"player already has a capital\");\n      }\n      return { ...player, capitalHex: hexKey };\n    });\n\n    const updatedChoices = { ...block.payload.choices, [playerId]: hexKey };\n    const nextState = {\n      ...updatedState,\n      board: updatedBoard,\n      blocks: {\n        ...block,\n        waitingFor: getCapitalDraftWaitingFor(state.players, updatedChoices),\n        payload: {\n          ...block.payload,\n          choices: updatedChoices\n        }\n      }\n    };\n\n    return emit(nextState, {\n      type: \"setup.capitalPicked\",\n      payload: { playerId, hexKey }\n    });\n  }\n\n  if (block.type === \"setup.startingBridges\") {\n    if (choice.kind === \"removeStartingBridge\") {\n      const [rawA, rawB] = parseEdgeKey(choice.edgeKey);\n      const edgeKey = getBridgeKey(rawA, rawB);\n      const selected = block.payload.selectedEdges[playerId] ?? [];\n      if (!selected.includes(edgeKey)) {\n        throw new Error(\"starting bridge not selected by player\");\n      }\n\n      const nextSelected = {\n        ...block.payload.selectedEdges,\n        [playerId]: selected.filter((edge) => edge !== edgeKey)\n      };\n      const nextRemaining = {\n        ...block.payload.remaining,\n        [playerId]: Math.min(2, (block.payload.remaining[playerId] ?? 0) + 1)\n      };\n\n      return {\n        ...state,\n        blocks: {\n          ...block,\n          waitingFor: getStartingBridgeWaitingFor(state.players, nextRemaining),\n          payload: {\n            remaining: nextRemaining,\n            selectedEdges: nextSelected\n          }\n        }\n      };\n    }\n\n    if (choice.kind !== \"placeStartingBridge\") {\n      throw new Error(\"expected placeStartingBridge during starting bridge placement\");\n    }\n    if (!block.waitingFor.includes(playerId)) {\n      throw new Error(\"player has already placed starting bridges\");\n    }\n\n    const remaining = block.payload.remaining[playerId];\n    if (!remaining || remaining <= 0) {\n      throw new Error(\"no remaining starting bridges to place\");\n    }\n\n    const [rawA, rawB] = parseEdgeKey(choice.edgeKey);\n    const edgeKey = getBridgeKey(rawA, rawB);\n    if (!state.board.hexes[rawA] || !state.board.hexes[rawB]) {\n      throw new Error(\"bridge endpoints must be on the board\");\n    }\n\n    const dist = axialDistance(parseHexKey(rawA), parseHexKey(rawB));\n    if (dist !== 1) {\n      throw new Error(\"bridge endpoints must be adjacent\");\n    }\n\n    const player = state.players.find((entry) => entry.id === playerId);\n    if (!player?.capitalHex) {\n      throw new Error(\"player has no capital to anchor starting bridge\");\n    }\n\n    const capitalCoord = parseHexKey(player.capitalHex);\n    const withinRange =\n      axialDistance(capitalCoord, parseHexKey(rawA)) <= 2 ||\n      axialDistance(capitalCoord, parseHexKey(rawB)) <= 2;\n    if (!withinRange) {\n      throw new Error(\"starting bridge must touch within distance 2 of capital\");\n    }\n\n    if (block.payload.selectedEdges[playerId].includes(edgeKey)) {\n      throw new Error(\"starting bridge already selected by player\");\n    }\n\n    const nextRemaining = {\n      ...block.payload.remaining,\n      [playerId]: remaining - 1\n    };\n\n    const nextSelected = {\n      ...block.payload.selectedEdges,\n      [playerId]: [...block.payload.selectedEdges[playerId], edgeKey]\n    };\n\n    const nextState = {\n      ...state,\n      blocks: {\n        ...block,\n        waitingFor: getStartingBridgeWaitingFor(state.players, nextRemaining),\n        payload: {\n          remaining: nextRemaining,\n          selectedEdges: nextSelected\n        }\n      }\n    };\n\n    return nextState;\n  }\n\n  if (block.type === \"setup.freeStartingCardPick\") {\n    if (choice.kind === \"unpickFreeStartingCard\") {\n      if (!block.payload.chosen[playerId]) {\n        throw new Error(\"player has no free starting card to unpick\");\n      }\n      const nextChosen = { ...block.payload.chosen, [playerId]: null };\n\n      return {\n        ...state,\n        blocks: {\n          ...block,\n          waitingFor: getFreeStartingCardWaitingFor(state.players, nextChosen),\n          payload: {\n            ...block.payload,\n            chosen: nextChosen\n          }\n        }\n      };\n    }\n\n    if (choice.kind !== \"pickFreeStartingCard\") {\n      throw new Error(\"expected pickFreeStartingCard during free starting card pick\");\n    }\n\n    const offers = block.payload.offers[playerId];\n    if (!offers || !offers.includes(choice.cardId)) {\n      throw new Error(\"card is not in player's offer\");\n    }\n    const alreadyChosen = block.payload.chosen[playerId] ?? null;\n    if (!block.waitingFor.includes(playerId) && !alreadyChosen) {\n      throw new Error(\"player already picked a free starting card\");\n    }\n    if (alreadyChosen === choice.cardId) {\n      return state;\n    }\n\n    const nextChosen = {\n      ...block.payload.chosen,\n      [playerId]: choice.cardId\n    };\n\n    const nextState = {\n      ...state,\n      blocks: {\n        ...block,\n        waitingFor: getFreeStartingCardWaitingFor(state.players, nextChosen),\n        payload: {\n          ...block.payload,\n          chosen: nextChosen\n        }\n      }\n    };\n\n    return emit(nextState, {\n      type: \"setup.freeStartingCardPicked\",\n      payload: { playerId, cardId: choice.cardId }\n    });\n  }\n\n  return state;\n};\n", "import type { ChampionKillContext, GameState, PlayerID } from \"./types\";\nimport { getChampionKillBonusGold, getChampionKillStealGold } from \"./modifiers\";\n\nconst MARK_FOR_COIN_CARD_ID = \"faction.veil.marked_for_coin\";\n\nconst addGold = (state: GameState, playerId: PlayerID, amount: number): GameState => {\n  if (amount <= 0) {\n    return state;\n  }\n\n  return {\n    ...state,\n    players: state.players.map((player) =>\n      player.id === playerId\n        ? {\n            ...player,\n            resources: {\n              ...player.resources,\n              gold: player.resources.gold + amount\n            }\n          }\n        : player\n    )\n  };\n};\n\nconst transferGold = (\n  state: GameState,\n  fromPlayerId: PlayerID,\n  toPlayerId: PlayerID,\n  amount: number\n): GameState => {\n  if (amount <= 0 || fromPlayerId === toPlayerId) {\n    return state;\n  }\n\n  let changed = false;\n  const nextPlayers = state.players.map((player) => {\n    if (player.id === fromPlayerId) {\n      if (player.resources.gold === 0) {\n        return player;\n      }\n      const nextGold = Math.max(0, player.resources.gold - amount);\n      if (nextGold === player.resources.gold) {\n        return player;\n      }\n      changed = true;\n      return {\n        ...player,\n        resources: {\n          ...player.resources,\n          gold: nextGold\n        }\n      };\n    }\n    if (player.id === toPlayerId) {\n      changed = true;\n      return {\n        ...player,\n        resources: {\n          ...player.resources,\n          gold: player.resources.gold + amount\n        }\n      };\n    }\n    return player;\n  });\n\n  return changed ? { ...state, players: nextPlayers } : state;\n};\n\nconst applyMarkedForCoinRewards = (\n  state: GameState,\n  context: ChampionKillContext\n): GameState => {\n  if (context.killedChampions.length === 0) {\n    return state;\n  }\n\n  const killedIds = new Set(context.killedChampions.map((champion) => champion.id));\n  const bonusByPlayer: Record<PlayerID, number> = {} as Record<PlayerID, number>;\n  const removed = new Set<string>();\n\n  for (const modifier of state.modifiers) {\n    if (modifier.source.type !== \"card\" || modifier.source.sourceId !== MARK_FOR_COIN_CARD_ID) {\n      continue;\n    }\n    const ownerId = modifier.ownerPlayerId;\n    if (!ownerId) {\n      continue;\n    }\n    const markedId = modifier.attachedUnitId ?? modifier.data?.markedUnitId;\n    if (typeof markedId !== \"string\" || !killedIds.has(markedId)) {\n      continue;\n    }\n    const bonusRaw = modifier.data?.bonusGold;\n    const bonus = typeof bonusRaw === \"number\" ? Math.max(0, bonusRaw) : 0;\n    if (bonus <= 0) {\n      removed.add(modifier.id);\n      continue;\n    }\n    removed.add(modifier.id);\n    bonusByPlayer[ownerId] = (bonusByPlayer[ownerId] ?? 0) + bonus;\n  }\n\n  let nextState = state;\n  if (removed.size > 0) {\n    nextState = {\n      ...nextState,\n      modifiers: nextState.modifiers.filter((modifier) => !removed.has(modifier.id))\n    };\n  }\n\n  for (const [playerId, amount] of Object.entries(bonusByPlayer)) {\n    if (amount > 0) {\n      nextState = addGold(nextState, playerId, amount);\n    }\n  }\n\n  return nextState;\n};\n\nexport const applyChampionKillRewards = (\n  state: GameState,\n  context: ChampionKillContext\n): GameState => {\n  if (context.killedChampions.length === 0) {\n    return state;\n  }\n\n  let nextState = state;\n  if (context.killerPlayerId !== context.victimPlayerId) {\n    const bonus = getChampionKillBonusGold(nextState, context, 0);\n    const steal = getChampionKillStealGold(nextState, context, 0);\n    const total = context.bounty + bonus;\n    if (total > 0) {\n      nextState = addGold(nextState, context.killerPlayerId, total);\n    }\n    if (steal > 0) {\n      const victim = nextState.players.find((player) => player.id === context.victimPlayerId);\n      const available = victim?.resources.gold ?? 0;\n      const stealAmount = Math.min(steal, available);\n      if (stealAmount > 0) {\n        nextState = transferGold(\n          nextState,\n          context.victimPlayerId,\n          context.killerPlayerId,\n          stealAmount\n        );\n      }\n    }\n  }\n\n  return applyMarkedForCoinRewards(nextState, context);\n};\n", "import { neighborHexKeys, randInt } from \"@bridgefront/shared\";\n\nimport type {\n  CardDefId,\n  ChampionUnitState,\n  GameState,\n  Modifier,\n  PlayerID,\n  UnitID\n} from \"./types\";\nimport { getBridgeKey } from \"./board\";\nimport { applyChampionKillRewards } from \"./rewards\";\nimport { getCardsPlayedThisRound } from \"./player-flags\";\nimport { addForcesToHex } from \"./units\";\n\nconst BODYGUARD_CHAMPION_ID = \"champion.bastion.ironclad_warden\";\nconst ASSASSINS_EDGE_CHAMPION_ID = \"champion.veil.shadeblade\";\nconst FLIGHT_CHAMPION_ID = \"champion.aerial.skystriker_ace\";\nconst ARCHIVIST_PRIME_CHAMPION_ID = \"champion.cipher.archivist_prime\";\nconst WORMHOLE_ARTIFICER_CHAMPION_ID = \"champion.gatewright.wormhole_artificer\";\nconst SKIRMISHER_CAPTAIN_CHAMPION_ID = \"champion.age1.skirmisher_captain\";\nconst BRIDGE_RUNNER_CHAMPION_ID = \"champion.age1.bridge_runner\";\nconst INSPIRING_GEEZER_CHAMPION_ID = \"champion.age1.inspiring_geezer\";\nconst FIELD_SURGEON_CHAMPION_ID = \"champion.age1.field_surgeon\";\nconst BRUTE_CHAMPION_ID = \"champion.age1.brute\";\nconst BOUNTY_HUNTER_CHAMPION_ID = \"champion.age1.bounty_hunter\";\nconst TRAITOR_CHAMPION_ID = \"champion.age1.traitor\";\nconst DUELIST_EXEMPLAR_CHAMPION_ID = \"champion.age2.duelist_exemplar\";\nconst LONE_WOLF_CHAMPION_ID = \"champion.age2.lone_wolf\";\nconst RELIABLE_VETERAN_CHAMPION_ID = \"champion.age2.reliable_veteran\";\nconst SIEGE_ENGINEER_CHAMPION_ID = \"champion.age2.siege_engineer\";\nconst CAPTURER_CHAMPION_ID = \"champion.age2.capturer\";\nconst TAX_REAVER_CHAMPION_ID = \"champion.age2.tax_reaver\";\nconst BLOOD_BANKER_CHAMPION_ID = \"champion.age3.blood_banker\";\nconst STORMCALLER_CHAMPION_ID = \"champion.age3.stormcaller\";\nexport const GRAND_STRATEGIST_CHAMPION_ID = \"champion.age3.grand_strategist\";\nconst CAPITAL_BREAKER_CHAMPION_ID = \"champion.age3.capital_breaker\";\nconst BANNERMAN_CHAMPION_ID = \"champion.power.bannerman\";\nconst CENTER_BANNERMAN_CHAMPION_ID = \"champion.age3.center_bannerman\";\n\nconst ASSASSINS_EDGE_KEY = \"assassins_edge\";\nconst STITCHWORK_KEY = \"stitchwork\";\nconst BLOOD_LEDGER_KEY = \"blood_ledger\";\nconst TEMPEST_KEY = \"tempest\";\nexport const TACTICAL_HAND_KEY = \"tactical_hand\";\n\nconst BRIDGE_BYPASS_CHAMPION_IDS = new Set([FLIGHT_CHAMPION_ID, BRIDGE_RUNNER_CHAMPION_ID]);\n\nconst PER_ROUND_ABILITY_USES: Record<CardDefId, Record<string, number>> = {\n  [ASSASSINS_EDGE_CHAMPION_ID]: {\n    [ASSASSINS_EDGE_KEY]: 1\n  },\n  [FIELD_SURGEON_CHAMPION_ID]: {\n    [STITCHWORK_KEY]: 1\n  },\n  [BLOOD_BANKER_CHAMPION_ID]: {\n    [BLOOD_LEDGER_KEY]: 1\n  },\n  [STORMCALLER_CHAMPION_ID]: {\n    [TEMPEST_KEY]: 1\n  },\n  [GRAND_STRATEGIST_CHAMPION_ID]: {\n    [TACTICAL_HAND_KEY]: 1\n  }\n};\n\nconst buildChampionModifierId = (unitId: UnitID, key: string) => `champion.${unitId}.${key}`;\n\nconst getModifierUnitId = (modifier: Modifier): UnitID | null => {\n  const unitId = modifier.data?.unitId;\n  return typeof unitId === \"string\" && unitId.length > 0 ? unitId : null;\n};\n\nconst getPerRoundAbilityUses = (cardDefId: CardDefId): Record<string, number> | null => {\n  return PER_ROUND_ABILITY_USES[cardDefId] ?? null;\n};\n\nconst buildAbilityUses = (cardDefId: CardDefId): Record<string, { remaining: number }> => {\n  const perRound = getPerRoundAbilityUses(cardDefId);\n  if (!perRound) {\n    return {};\n  }\n  return Object.fromEntries(\n    Object.entries(perRound).map(([key, count]) => [key, { remaining: count }])\n  );\n};\n\nconst setChampionAbilityUses = (\n  state: GameState,\n  unitId: UnitID,\n  abilityUses: Record<string, { remaining: number }>\n): GameState => {\n  if (Object.keys(abilityUses).length === 0) {\n    return state;\n  }\n\n  const unit = state.board.units[unitId];\n  if (!unit || unit.kind !== \"champion\") {\n    return state;\n  }\n\n  return {\n    ...state,\n    board: {\n      ...state.board,\n      units: {\n        ...state.board.units,\n        [unitId]: {\n          ...unit,\n          abilityUses: {\n            ...unit.abilityUses,\n            ...abilityUses\n          }\n        }\n      }\n    }\n  };\n};\n\nconst getChampionAbilityRemaining = (unit: GameState[\"board\"][\"units\"][string], key: string) => {\n  if (unit.kind !== \"champion\") {\n    return 0;\n  }\n  const current = unit.abilityUses[key]?.remaining;\n  if (typeof current === \"number\") {\n    return current;\n  }\n  const perRound = getPerRoundAbilityUses(unit.cardDefId)?.[key];\n  return typeof perRound === \"number\" ? perRound : 0;\n};\n\nconst canChampionUseAbility = (unit: GameState[\"board\"][\"units\"][string], key: string) =>\n  getChampionAbilityRemaining(unit, key) > 0;\n\nexport const consumeChampionAbilityUse = (\n  state: GameState,\n  unitId: UnitID,\n  key: string\n): GameState => {\n  const unit = state.board.units[unitId];\n  if (!unit || unit.kind !== \"champion\") {\n    return state;\n  }\n  const remaining = getChampionAbilityRemaining(unit, key);\n  if (remaining <= 0) {\n    return state;\n  }\n  return setChampionAbilityUses(state, unitId, {\n    [key]: { remaining: remaining - 1 }\n  });\n};\n\nconst createBodyguardModifier = (unitId: UnitID, ownerPlayerId: PlayerID): Modifier => ({\n  id: buildChampionModifierId(unitId, \"bodyguard\"),\n  source: { type: \"champion\", sourceId: BODYGUARD_CHAMPION_ID },\n  ownerPlayerId,\n  duration: { type: \"permanent\" },\n  data: { unitId, bodyguard: true },\n  hooks: {\n    getHitAssignmentPolicy: ({ modifier, targetUnitIds, state }, current) => {\n      if (current === \"bodyguard\") {\n        return current;\n      }\n      const guardId = getModifierUnitId(modifier);\n      if (!guardId) {\n        return current;\n      }\n      if (!targetUnitIds.includes(guardId)) {\n        return current;\n      }\n      const hasForce = targetUnitIds.some(\n        (targetId) => state.board.units[targetId]?.kind === \"force\"\n      );\n      if (!hasForce) {\n        return current;\n      }\n      return \"bodyguard\";\n    }\n  }\n});\n\nconst createAssassinsEdgeModifier = (unitId: UnitID, ownerPlayerId: PlayerID): Modifier => ({\n  id: buildChampionModifierId(unitId, \"assassins_edge\"),\n  source: { type: \"champion\", sourceId: ASSASSINS_EDGE_CHAMPION_ID },\n  ownerPlayerId,\n  duration: { type: \"permanent\" },\n  data: { unitId },\n  hooks: {\n    beforeCombatRound: ({ state, modifier, round, attackers, defenders }) => {\n      if (round !== 1) {\n        return state;\n      }\n      const sourceUnitId = getModifierUnitId(modifier);\n      if (!sourceUnitId) {\n        return state;\n      }\n      const sourceUnit = state.board.units[sourceUnitId];\n      if (!sourceUnit || sourceUnit.kind !== \"champion\") {\n        return state;\n      }\n      if (!canChampionUseAbility(sourceUnit, ASSASSINS_EDGE_KEY)) {\n        return state;\n      }\n\n      const onAttackers = attackers.includes(sourceUnitId);\n      const onDefenders = defenders.includes(sourceUnitId);\n      if (!onAttackers && !onDefenders) {\n        return state;\n      }\n\n      const enemyUnitIds = (onAttackers ? defenders : attackers).filter((enemyId) => {\n        const unit = state.board.units[enemyId];\n        return unit?.kind === \"champion\";\n      });\n      if (enemyUnitIds.length === 0) {\n        return state;\n      }\n\n      const pick = randInt(state.rngState, 0, enemyUnitIds.length - 1);\n      const targetId = enemyUnitIds[pick.value] ?? enemyUnitIds[0];\n      let nextState: GameState = {\n        ...state,\n        rngState: pick.next\n      };\n      nextState = consumeChampionAbilityUse(nextState, sourceUnitId, ASSASSINS_EDGE_KEY);\n      return dealChampionDamage(nextState, sourceUnit.ownerPlayerId, targetId, 1);\n    }\n  }\n});\n\nconst createBridgeBypassModifier = (\n  unitId: UnitID,\n  ownerPlayerId: PlayerID,\n  sourceId: CardDefId\n): Modifier => ({\n  id: buildChampionModifierId(unitId, \"bridge_bypass\"),\n  source: { type: \"champion\", sourceId },\n  ownerPlayerId,\n  duration: { type: \"permanent\" },\n  data: { unitId },\n  hooks: {\n    getMoveRequiresBridge: ({ modifier, movingUnitIds, state }, current) => {\n      if (!current) {\n        return current;\n      }\n      const sourceUnitId = getModifierUnitId(modifier);\n      if (!sourceUnitId) {\n        return current;\n      }\n      if (!movingUnitIds.includes(sourceUnitId)) {\n        return current;\n      }\n      if (movingUnitIds.length === 0) {\n        return current;\n      }\n      const movingUnits = movingUnitIds\n        .map((id) => state.board.units[id])\n        .filter(Boolean);\n      if (movingUnits.some((unit) => unit?.kind !== \"champion\")) {\n        return current;\n      }\n      if (\n        movingUnits.some(\n          (unit) => unit?.kind === \"champion\" && !BRIDGE_BYPASS_CHAMPION_IDS.has(unit.cardDefId)\n        )\n      ) {\n        return current;\n      }\n      return false;\n    }\n  }\n});\n\nconst createArchivistPrimeModifier = (unitId: UnitID, ownerPlayerId: PlayerID): Modifier => ({\n  id: buildChampionModifierId(unitId, \"archivist_prime\"),\n  source: { type: \"champion\", sourceId: ARCHIVIST_PRIME_CHAMPION_ID },\n  ownerPlayerId,\n  duration: { type: \"permanent\" },\n  data: { unitId },\n  hooks: {\n    getChampionAttackDice: ({ modifier, unitId: contextUnitId, unit, state }, current) => {\n      const sourceUnitId = getModifierUnitId(modifier);\n      if (!sourceUnitId || sourceUnitId !== contextUnitId) {\n        return current;\n      }\n      if (modifier.ownerPlayerId && modifier.ownerPlayerId !== unit.ownerPlayerId) {\n        return current;\n      }\n      const bonus = getCardsPlayedThisRound(state, unit.ownerPlayerId);\n      return bonus > 0 ? current + bonus : current;\n    }\n  }\n});\n\nconst createWormholeArtificerModifier = (unitId: UnitID, ownerPlayerId: PlayerID): Modifier => ({\n  id: buildChampionModifierId(unitId, \"wormhole_artificer\"),\n  source: { type: \"champion\", sourceId: WORMHOLE_ARTIFICER_CHAMPION_ID },\n  ownerPlayerId,\n  duration: { type: \"permanent\" },\n  data: { unitId },\n  hooks: {\n    getMoveMaxDistance: ({ modifier, movingUnitIds }, current) => {\n      const sourceUnitId = getModifierUnitId(modifier);\n      if (!sourceUnitId) {\n        return current;\n      }\n      if (movingUnitIds.length !== 1 || movingUnitIds[0] !== sourceUnitId) {\n        return current;\n      }\n      return current + 1;\n    }\n  }\n});\n\nconst createInspiringGeezerModifier = (\n  unitId: UnitID,\n  ownerPlayerId: PlayerID\n): Modifier => ({\n  id: buildChampionModifierId(unitId, \"inspiring_geezer\"),\n  source: { type: \"champion\", sourceId: INSPIRING_GEEZER_CHAMPION_ID },\n  ownerPlayerId,\n  duration: { type: \"permanent\" },\n  data: { unitId },\n  hooks: {\n    getForceHitFaces: ({ modifier, unit, hexKey, state }, current) => {\n      if (unit.kind !== \"force\") {\n        return current;\n      }\n      if (modifier.ownerPlayerId && modifier.ownerPlayerId !== unit.ownerPlayerId) {\n        return current;\n      }\n      const sourceUnitId = getModifierUnitId(modifier);\n      if (!sourceUnitId) {\n        return current;\n      }\n      const sourceUnit = state.board.units[sourceUnitId];\n      if (!sourceUnit || sourceUnit.kind !== \"champion\") {\n        return current;\n      }\n      if (sourceUnit.hex !== hexKey) {\n        return current;\n      }\n      return Math.max(current, 3);\n    }\n  }\n});\n\nconst createFieldSurgeonModifier = (\n  unitId: UnitID,\n  ownerPlayerId: PlayerID\n): Modifier => ({\n  id: buildChampionModifierId(unitId, \"stitchwork\"),\n  source: { type: \"champion\", sourceId: FIELD_SURGEON_CHAMPION_ID },\n  ownerPlayerId,\n  duration: { type: \"permanent\" },\n  data: { unitId },\n  hooks: {\n    afterBattle: ({ state, modifier, hexKey }) => {\n      const sourceUnitId = getModifierUnitId(modifier);\n      if (!sourceUnitId) {\n        return state;\n      }\n      const sourceUnit = state.board.units[sourceUnitId];\n      if (!sourceUnit || sourceUnit.kind !== \"champion\") {\n        return state;\n      }\n      if (sourceUnit.hex !== hexKey) {\n        return state;\n      }\n      if (!canChampionUseAbility(sourceUnit, STITCHWORK_KEY)) {\n        return state;\n      }\n      const hex = state.board.hexes[hexKey];\n      if (!hex) {\n        return state;\n      }\n      const candidateIds = (hex.occupants[sourceUnit.ownerPlayerId] ?? [])\n        .map((unitId) => {\n          const unit = state.board.units[unitId];\n          if (!unit || unit.kind !== \"champion\") {\n            return null;\n          }\n          const missing = unit.maxHp - unit.hp;\n          if (missing <= 0) {\n            return null;\n          }\n          return { unitId, missing };\n        })\n        .filter((entry): entry is { unitId: UnitID; missing: number } => Boolean(entry));\n      if (candidateIds.length === 0) {\n        return state;\n      }\n\n      candidateIds.sort((a, b) => {\n        if (a.missing !== b.missing) {\n          return b.missing - a.missing;\n        }\n        return a.unitId.localeCompare(b.unitId);\n      });\n      const targetId = candidateIds[0]?.unitId;\n      if (!targetId) {\n        return state;\n      }\n\n      let nextState = consumeChampionAbilityUse(state, sourceUnitId, STITCHWORK_KEY);\n      nextState = healChampion(nextState, targetId, 2);\n      return nextState;\n    }\n  }\n});\n\nconst createBruteModifier = (unitId: UnitID, ownerPlayerId: PlayerID): Modifier => ({\n  id: buildChampionModifierId(unitId, \"brute\"),\n  source: { type: \"champion\", sourceId: BRUTE_CHAMPION_ID },\n  ownerPlayerId,\n  duration: { type: \"permanent\" },\n  data: { unitId },\n  hooks: {\n    getChampionAttackDice: ({ modifier, unitId: contextUnitId, unit, hexKey, state }, current) => {\n      const sourceUnitId = getModifierUnitId(modifier);\n      if (!sourceUnitId || sourceUnitId !== contextUnitId) {\n        return current;\n      }\n      if (modifier.ownerPlayerId && modifier.ownerPlayerId !== unit.ownerPlayerId) {\n        return current;\n      }\n      const hex = state.board.hexes[hexKey];\n      if (!hex) {\n        return current;\n      }\n      for (const [playerId, unitIds] of Object.entries(hex.occupants)) {\n        if (playerId === unit.ownerPlayerId) {\n          continue;\n        }\n        for (const occupantId of unitIds ?? []) {\n          if (state.board.units[occupantId]?.kind === \"champion\") {\n            return current;\n          }\n        }\n      }\n      return current + 2;\n    }\n  }\n});\n\nconst createDuelistExemplarModifier = (\n  unitId: UnitID,\n  ownerPlayerId: PlayerID\n): Modifier => ({\n  id: buildChampionModifierId(unitId, \"duelist_exemplar\"),\n  source: { type: \"champion\", sourceId: DUELIST_EXEMPLAR_CHAMPION_ID },\n  ownerPlayerId,\n  duration: { type: \"permanent\" },\n  data: { unitId },\n  hooks: {\n    getChampionAttackDice: ({ modifier, unitId: contextUnitId, unit, hexKey, state }, current) => {\n      const sourceUnitId = getModifierUnitId(modifier);\n      if (!sourceUnitId || sourceUnitId !== contextUnitId) {\n        return current;\n      }\n      if (modifier.ownerPlayerId && modifier.ownerPlayerId !== unit.ownerPlayerId) {\n        return current;\n      }\n      const hex = state.board.hexes[hexKey];\n      if (!hex) {\n        return current;\n      }\n      for (const [playerId, unitIds] of Object.entries(hex.occupants)) {\n        if (playerId === unit.ownerPlayerId) {\n          continue;\n        }\n        for (const occupantId of unitIds ?? []) {\n          if (state.board.units[occupantId]?.kind === \"champion\") {\n            return current + 1;\n          }\n        }\n      }\n      return current;\n    }\n  }\n});\n\nconst createLoneWolfModifier = (unitId: UnitID, ownerPlayerId: PlayerID): Modifier => ({\n  id: buildChampionModifierId(unitId, \"lone_wolf\"),\n  source: { type: \"champion\", sourceId: LONE_WOLF_CHAMPION_ID },\n  ownerPlayerId,\n  duration: { type: \"permanent\" },\n  data: { unitId },\n  hooks: {\n    getChampionAttackDice: ({ modifier, unitId: contextUnitId, unit, hexKey, state }, current) => {\n      const sourceUnitId = getModifierUnitId(modifier);\n      if (!sourceUnitId || sourceUnitId !== contextUnitId) {\n        return current;\n      }\n      if (modifier.ownerPlayerId && modifier.ownerPlayerId !== unit.ownerPlayerId) {\n        return current;\n      }\n      const hex = state.board.hexes[hexKey];\n      if (!hex) {\n        return current;\n      }\n      const friendly = hex.occupants[unit.ownerPlayerId] ?? [];\n      const hasFriendlyForces = friendly.some(\n        (unitId) => state.board.units[unitId]?.kind === \"force\"\n      );\n      if (hasFriendlyForces) {\n        return current;\n      }\n      return current + 3;\n    }\n  }\n});\n\nconst createReliableVeteranModifier = (\n  unitId: UnitID,\n  ownerPlayerId: PlayerID\n): Modifier => ({\n  id: buildChampionModifierId(unitId, \"reliable_veteran\"),\n  source: { type: \"champion\", sourceId: RELIABLE_VETERAN_CHAMPION_ID },\n  ownerPlayerId,\n  duration: { type: \"permanent\" },\n  data: { unitId },\n  hooks: {\n    getChampionHitFaces: ({ modifier, unitId: contextUnitId, unit }, current) => {\n      const sourceUnitId = getModifierUnitId(modifier);\n      if (!sourceUnitId || sourceUnitId !== contextUnitId) {\n        return current;\n      }\n      if (modifier.ownerPlayerId && modifier.ownerPlayerId !== unit.ownerPlayerId) {\n        return current;\n      }\n      return Math.max(current, 5);\n    }\n  }\n});\n\nconst createBountyHunterModifier = (\n  unitId: UnitID,\n  ownerPlayerId: PlayerID\n): Modifier => ({\n  id: buildChampionModifierId(unitId, \"bounty_hunter\"),\n  source: { type: \"champion\", sourceId: BOUNTY_HUNTER_CHAMPION_ID },\n  ownerPlayerId,\n  duration: { type: \"permanent\" },\n  data: { unitId },\n  hooks: {\n    getChampionKillBonusGold: (\n      { modifier, state, killerPlayerId, hexKey, source, killedChampions },\n      current\n    ) => {\n      if (source !== \"battle\") {\n        return current;\n      }\n      if (modifier.ownerPlayerId && modifier.ownerPlayerId !== killerPlayerId) {\n        return current;\n      }\n      if (killedChampions.length === 0) {\n        return current;\n      }\n      const sourceUnitId = getModifierUnitId(modifier);\n      if (!sourceUnitId) {\n        return current;\n      }\n      const sourceUnit = state.board.units[sourceUnitId];\n      if (!sourceUnit || sourceUnit.kind !== \"champion\") {\n        return current;\n      }\n      if (sourceUnit.hex !== hexKey) {\n        return current;\n      }\n      return current + killedChampions.length;\n    }\n  }\n});\n\nconst createTaxReaverModifier = (\n  unitId: UnitID,\n  ownerPlayerId: PlayerID\n): Modifier => ({\n  id: buildChampionModifierId(unitId, \"tax_reaver\"),\n  source: { type: \"champion\", sourceId: TAX_REAVER_CHAMPION_ID },\n  ownerPlayerId,\n  duration: { type: \"permanent\" },\n  data: { unitId },\n  hooks: {\n    getChampionKillStealGold: (\n      { modifier, state, killerPlayerId, hexKey, source, killedChampions },\n      current\n    ) => {\n      if (source !== \"battle\") {\n        return current;\n      }\n      if (modifier.ownerPlayerId && modifier.ownerPlayerId !== killerPlayerId) {\n        return current;\n      }\n      if (killedChampions.length === 0) {\n        return current;\n      }\n      const sourceUnitId = getModifierUnitId(modifier);\n      if (!sourceUnitId) {\n        return current;\n      }\n      const sourceUnit = state.board.units[sourceUnitId];\n      if (!sourceUnit || sourceUnit.kind !== \"champion\") {\n        return current;\n      }\n      if (sourceUnit.hex !== hexKey) {\n        return current;\n      }\n      return current + killedChampions.length * 2;\n    }\n  }\n});\n\nconst createCapturerModifier = (\n  unitId: UnitID,\n  ownerPlayerId: PlayerID\n): Modifier => ({\n  id: buildChampionModifierId(unitId, \"capturer\"),\n  source: { type: \"champion\", sourceId: CAPTURER_CHAMPION_ID },\n  ownerPlayerId,\n  duration: { type: \"permanent\" },\n  data: { unitId },\n  hooks: {\n    afterBattle: ({ state, modifier, winnerPlayerId, hexKey, attackers, defenders }) => {\n      const ownerId = modifier.ownerPlayerId;\n      if (!ownerId || winnerPlayerId !== ownerId) {\n        return state;\n      }\n      const sourceUnitId = getModifierUnitId(modifier);\n      if (!sourceUnitId) {\n        return state;\n      }\n      const sourceUnit = state.board.units[sourceUnitId];\n      if (!sourceUnit || sourceUnit.kind !== \"champion\") {\n        return state;\n      }\n      if (sourceUnit.hex !== hexKey) {\n        return state;\n      }\n      if (![...attackers, ...defenders].includes(sourceUnitId)) {\n        return state;\n      }\n      return {\n        ...state,\n        board: addForcesToHex(state.board, ownerId, hexKey, 1)\n      };\n    }\n  }\n});\n\nconst createStormcallerModifier = (\n  unitId: UnitID,\n  ownerPlayerId: PlayerID\n): Modifier => ({\n  id: buildChampionModifierId(unitId, \"stormcaller\"),\n  source: { type: \"champion\", sourceId: STORMCALLER_CHAMPION_ID },\n  ownerPlayerId,\n  duration: { type: \"permanent\" },\n  data: { unitId },\n  hooks: {\n    beforeCombatRound: ({ state, modifier, attackers, defenders }) => {\n      const sourceUnitId = getModifierUnitId(modifier);\n      if (!sourceUnitId) {\n        return state;\n      }\n      const sourceUnit = state.board.units[sourceUnitId];\n      if (!sourceUnit || sourceUnit.kind !== \"champion\") {\n        return state;\n      }\n      if (!canChampionUseAbility(sourceUnit, TEMPEST_KEY)) {\n        return state;\n      }\n      if (![...attackers, ...defenders].includes(sourceUnitId)) {\n        return state;\n      }\n\n      const neighborKeys = neighborHexKeys(sourceUnit.hex).filter(\n        (key) => Boolean(state.board.hexes[key])\n      );\n      if (neighborKeys.length === 0) {\n        return state;\n      }\n\n      const targetIds: UnitID[] = [];\n      for (const hexKey of neighborKeys) {\n        const hex = state.board.hexes[hexKey];\n        if (!hex) {\n          continue;\n        }\n        for (const [playerId, unitIds] of Object.entries(hex.occupants)) {\n          if (playerId === sourceUnit.ownerPlayerId) {\n            continue;\n          }\n          for (const targetId of unitIds ?? []) {\n            const unit = state.board.units[targetId];\n            if (unit?.kind === \"champion\") {\n              targetIds.push(targetId);\n            }\n          }\n        }\n      }\n\n      if (targetIds.length === 0) {\n        return state;\n      }\n\n      let nextState = consumeChampionAbilityUse(state, sourceUnitId, TEMPEST_KEY);\n      for (const targetId of targetIds) {\n        nextState = dealChampionDamage(nextState, sourceUnit.ownerPlayerId, targetId, 1);\n      }\n      return nextState;\n    }\n  }\n});\n\nconst createCapitalBreakerModifier = (\n  unitId: UnitID,\n  ownerPlayerId: PlayerID\n): Modifier => ({\n  id: buildChampionModifierId(unitId, \"capital_breaker\"),\n  source: { type: \"champion\", sourceId: CAPITAL_BREAKER_CHAMPION_ID },\n  ownerPlayerId,\n  duration: { type: \"permanent\" },\n  data: { unitId },\n  hooks: {\n    getForceHitFaces: ({ modifier, unit, hexKey, state, round }, current) => {\n      if (unit.kind !== \"force\") {\n        return current;\n      }\n      if (modifier.ownerPlayerId && modifier.ownerPlayerId !== unit.ownerPlayerId) {\n        return current;\n      }\n      if (round !== 1) {\n        return current;\n      }\n      const sourceUnitId = getModifierUnitId(modifier);\n      if (!sourceUnitId) {\n        return current;\n      }\n      const sourceUnit = state.board.units[sourceUnitId];\n      if (!sourceUnit || sourceUnit.kind !== \"champion\") {\n        return current;\n      }\n      if (sourceUnit.hex !== hexKey) {\n        return current;\n      }\n      const hex = state.board.hexes[hexKey];\n      if (!hex || hex.tile !== \"capital\") {\n        return current;\n      }\n      if (!hex.ownerPlayerId || hex.ownerPlayerId === unit.ownerPlayerId) {\n        return current;\n      }\n      return Math.max(current, 3);\n    }\n  }\n});\n\nconst createBannermanModifier = (unitId: UnitID, ownerPlayerId: PlayerID): Modifier => ({\n  id: buildChampionModifierId(unitId, \"bannerman\"),\n  source: { type: \"champion\", sourceId: BANNERMAN_CHAMPION_ID },\n  ownerPlayerId,\n  duration: { type: \"permanent\" },\n  data: { unitId },\n  hooks: {\n    getControlBonus: ({ modifier, state, playerId }, current) => {\n      if (modifier.ownerPlayerId && modifier.ownerPlayerId !== playerId) {\n        return current;\n      }\n      const sourceUnitId = getModifierUnitId(modifier);\n      if (!sourceUnitId) {\n        return current;\n      }\n      const sourceUnit = state.board.units[sourceUnitId];\n      if (!sourceUnit || sourceUnit.kind !== \"champion\") {\n        return current;\n      }\n      return current + 1;\n    }\n  }\n});\n\nconst createCenterBannermanModifier = (unitId: UnitID, ownerPlayerId: PlayerID): Modifier => ({\n  id: buildChampionModifierId(unitId, \"center_bannerman\"),\n  source: { type: \"champion\", sourceId: CENTER_BANNERMAN_CHAMPION_ID },\n  ownerPlayerId,\n  duration: { type: \"permanent\" },\n  data: { unitId },\n  hooks: {\n    getControlBonus: ({ modifier, state, playerId }, current) => {\n      if (modifier.ownerPlayerId && modifier.ownerPlayerId !== playerId) {\n        return current;\n      }\n      const sourceUnitId = getModifierUnitId(modifier);\n      if (!sourceUnitId) {\n        return current;\n      }\n      const sourceUnit = state.board.units[sourceUnitId];\n      if (!sourceUnit || sourceUnit.kind !== \"champion\") {\n        return current;\n      }\n      const hex = state.board.hexes[sourceUnit.hex];\n      if (!hex || hex.tile !== \"center\") {\n        return current;\n      }\n      return current + 1;\n    }\n  }\n});\n\nconst createChampionModifiers = (\n  unitId: UnitID,\n  cardDefId: CardDefId,\n  ownerPlayerId: PlayerID\n): Modifier[] => {\n  switch (cardDefId) {\n    case BODYGUARD_CHAMPION_ID:\n      return [createBodyguardModifier(unitId, ownerPlayerId)];\n    case ASSASSINS_EDGE_CHAMPION_ID:\n      return [createAssassinsEdgeModifier(unitId, ownerPlayerId)];\n    case FLIGHT_CHAMPION_ID:\n      return [createBridgeBypassModifier(unitId, ownerPlayerId, cardDefId)];\n    case ARCHIVIST_PRIME_CHAMPION_ID:\n      return [createArchivistPrimeModifier(unitId, ownerPlayerId)];\n    case WORMHOLE_ARTIFICER_CHAMPION_ID:\n      return [createWormholeArtificerModifier(unitId, ownerPlayerId)];\n    case BRIDGE_RUNNER_CHAMPION_ID:\n      return [createBridgeBypassModifier(unitId, ownerPlayerId, cardDefId)];\n    case INSPIRING_GEEZER_CHAMPION_ID:\n      return [createInspiringGeezerModifier(unitId, ownerPlayerId)];\n    case FIELD_SURGEON_CHAMPION_ID:\n      return [createFieldSurgeonModifier(unitId, ownerPlayerId)];\n    case BRUTE_CHAMPION_ID:\n      return [createBruteModifier(unitId, ownerPlayerId)];\n    case DUELIST_EXEMPLAR_CHAMPION_ID:\n      return [createDuelistExemplarModifier(unitId, ownerPlayerId)];\n    case LONE_WOLF_CHAMPION_ID:\n      return [createLoneWolfModifier(unitId, ownerPlayerId)];\n    case RELIABLE_VETERAN_CHAMPION_ID:\n      return [createReliableVeteranModifier(unitId, ownerPlayerId)];\n    case BOUNTY_HUNTER_CHAMPION_ID:\n      return [createBountyHunterModifier(unitId, ownerPlayerId)];\n    case TAX_REAVER_CHAMPION_ID:\n      return [createTaxReaverModifier(unitId, ownerPlayerId)];\n    case CAPTURER_CHAMPION_ID:\n      return [createCapturerModifier(unitId, ownerPlayerId)];\n    case STORMCALLER_CHAMPION_ID:\n      return [createStormcallerModifier(unitId, ownerPlayerId)];\n    case CAPITAL_BREAKER_CHAMPION_ID:\n      return [createCapitalBreakerModifier(unitId, ownerPlayerId)];\n    case BANNERMAN_CHAMPION_ID:\n      return [createBannermanModifier(unitId, ownerPlayerId)];\n    case CENTER_BANNERMAN_CHAMPION_ID:\n      return [createCenterBannermanModifier(unitId, ownerPlayerId)];\n    default:\n      return [];\n  }\n};\n\nconst getDeployForcesOnChampionDeploy = (cardDefId: CardDefId): number => {\n  switch (cardDefId) {\n    case SKIRMISHER_CAPTAIN_CHAMPION_ID:\n      return 1;\n    default:\n      return 0;\n  }\n};\n\nconst getAdjacentBridgeKeys = (state: GameState, hexKey: string): string[] => {\n  const neighbors = neighborHexKeys(hexKey).filter((key) => Boolean(state.board.hexes[key]));\n  const bridgeKeys: string[] = [];\n  for (const neighbor of neighbors) {\n    const edgeKey = getBridgeKey(hexKey, neighbor);\n    if (state.board.bridges[edgeKey]) {\n      bridgeKeys.push(edgeKey);\n    }\n  }\n  return bridgeKeys;\n};\n\nconst destroyAdjacentBridgeOnDeploy = (\n  state: GameState,\n  unitId: UnitID,\n  cardDefId: CardDefId\n): GameState => {\n  if (cardDefId !== SIEGE_ENGINEER_CHAMPION_ID) {\n    return state;\n  }\n  const unit = state.board.units[unitId];\n  if (!unit || unit.kind !== \"champion\") {\n    return state;\n  }\n  const bridgeKeys = getAdjacentBridgeKeys(state, unit.hex);\n  if (bridgeKeys.length === 0) {\n    return state;\n  }\n  const pick = randInt(state.rngState, 0, bridgeKeys.length - 1);\n  const edgeKey = bridgeKeys[pick.value] ?? bridgeKeys[0];\n  if (!edgeKey || !state.board.bridges[edgeKey]) {\n    return { ...state, rngState: pick.next };\n  }\n  const { [edgeKey]: _removed, ...bridges } = state.board.bridges;\n  return {\n    ...state,\n    rngState: pick.next,\n    board: {\n      ...state.board,\n      bridges\n    }\n  };\n};\n\nconst applyChampionOnDeploy = (\n  state: GameState,\n  unitId: UnitID,\n  cardDefId: CardDefId,\n  ownerPlayerId: PlayerID\n): GameState => {\n  let nextState = state;\n  const forceCount = getDeployForcesOnChampionDeploy(cardDefId);\n  const unit = state.board.units[unitId];\n  if (!unit || unit.kind !== \"champion\") {\n    return nextState;\n  }\n  if (forceCount > 0) {\n    nextState = {\n      ...nextState,\n      board: addForcesToHex(nextState.board, ownerPlayerId, unit.hex, forceCount)\n    };\n  }\n  return destroyAdjacentBridgeOnDeploy(nextState, unitId, cardDefId);\n};\n\nexport const applyChampionDeployment = (\n  state: GameState,\n  unitId: UnitID,\n  cardDefId: CardDefId,\n  ownerPlayerId: PlayerID\n): GameState => {\n  let nextState = setChampionAbilityUses(state, unitId, buildAbilityUses(cardDefId));\n  const modifiers = createChampionModifiers(unitId, cardDefId, ownerPlayerId);\n  if (modifiers.length === 0) {\n    return applyChampionOnDeploy(nextState, unitId, cardDefId, ownerPlayerId);\n  }\n  const existing = new Set(nextState.modifiers.map((modifier) => modifier.id));\n  const nextModifiers = [...nextState.modifiers];\n  for (const modifier of modifiers) {\n    if (!existing.has(modifier.id)) {\n      nextModifiers.push(modifier);\n    }\n  }\n  if (nextModifiers.length === nextState.modifiers.length) {\n    return applyChampionOnDeploy(nextState, unitId, cardDefId, ownerPlayerId);\n  }\n  nextState = { ...nextState, modifiers: nextModifiers };\n  return applyChampionOnDeploy(nextState, unitId, cardDefId, ownerPlayerId);\n};\n\nexport const refreshChampionAbilityUsesForRound = (state: GameState): GameState => {\n  let changed = false;\n  const nextUnits = { ...state.board.units };\n\n  for (const [unitId, unit] of Object.entries(state.board.units)) {\n    if (unit.kind !== \"champion\") {\n      continue;\n    }\n    const resetCounts = getPerRoundAbilityUses(unit.cardDefId);\n    if (!resetCounts) {\n      continue;\n    }\n    const nextUses = { ...unit.abilityUses };\n    let unitChanged = false;\n    for (const [key, count] of Object.entries(resetCounts)) {\n      if (nextUses[key]?.remaining !== count) {\n        nextUses[key] = { remaining: count };\n        unitChanged = true;\n      }\n    }\n    if (unitChanged) {\n      nextUnits[unitId] = { ...unit, abilityUses: nextUses };\n      changed = true;\n    }\n  }\n\n  if (!changed) {\n    return state;\n  }\n\n  return {\n    ...state,\n    board: {\n      ...state.board,\n      units: nextUnits\n    }\n  };\n};\n\nexport const removeChampionModifiers = (state: GameState, unitIds: UnitID[]): GameState => {\n  if (unitIds.length === 0) {\n    return state;\n  }\n  const idSet = new Set(unitIds);\n  const nextModifiers = state.modifiers.filter((modifier) => {\n    if (modifier.source.type !== \"champion\") {\n      return true;\n    }\n    const modifierUnitId = getModifierUnitId(modifier);\n    if (!modifierUnitId) {\n      return true;\n    }\n    return !idSet.has(modifierUnitId);\n  });\n\n  if (nextModifiers.length === state.modifiers.length) {\n    return state;\n  }\n  return { ...state, modifiers: nextModifiers };\n};\n\nconst setPlayerMana = (state: GameState, playerId: PlayerID, mana: number): GameState => {\n  let changed = false;\n  const players = state.players.map((player) => {\n    if (player.id !== playerId) {\n      return player;\n    }\n    if (player.resources.mana === mana) {\n      return player;\n    }\n    changed = true;\n    return {\n      ...player,\n      resources: {\n        ...player.resources,\n        mana\n      }\n    };\n  });\n\n  return changed ? { ...state, players } : state;\n};\n\nconst addGold = (state: GameState, playerId: PlayerID, amount: number): GameState => {\n  if (amount <= 0) {\n    return state;\n  }\n  let changed = false;\n  const players = state.players.map((player) => {\n    if (player.id !== playerId) {\n      return player;\n    }\n    changed = true;\n    return {\n      ...player,\n      resources: {\n        ...player.resources,\n        gold: player.resources.gold + amount\n      }\n    };\n  });\n  return changed ? { ...state, players } : state;\n};\n\nconst spendGold = (state: GameState, playerId: PlayerID, amount: number): GameState => {\n  if (amount <= 0) {\n    return state;\n  }\n  let changed = false;\n  const players = state.players.map((player) => {\n    if (player.id !== playerId) {\n      return player;\n    }\n    const nextGold = Math.max(0, player.resources.gold - amount);\n    if (nextGold === player.resources.gold) {\n      return player;\n    }\n    changed = true;\n    return {\n      ...player,\n      resources: {\n        ...player.resources,\n        gold: nextGold\n      }\n    };\n  });\n  return changed ? { ...state, players } : state;\n};\n\nconst isModifierActive = (modifier: Modifier): boolean => {\n  if (modifier.duration.type === \"uses\") {\n    return modifier.duration.remaining > 0;\n  }\n  return true;\n};\n\nexport const applyGoldArmorToDamage = (\n  state: GameState,\n  unitId: UnitID,\n  damage: number\n): { state: GameState; remainingDamage: number } => {\n  if (!Number.isFinite(damage) || damage <= 0) {\n    return { state, remainingDamage: damage };\n  }\n\n  const unit = state.board.units[unitId];\n  if (!unit || unit.kind !== \"champion\") {\n    return { state, remainingDamage: damage };\n  }\n\n  let costPerDamage: number | null = null;\n  for (const modifier of state.modifiers) {\n    if (!isModifierActive(modifier)) {\n      continue;\n    }\n    if (modifier.attachedUnitId !== unitId) {\n      continue;\n    }\n    const raw = modifier.data?.goldArmor;\n    if (!raw || typeof raw !== \"object\") {\n      continue;\n    }\n    const record = raw as Record<string, unknown>;\n    const cost =\n      typeof record.costPerDamage === \"number\" ? record.costPerDamage : 2;\n    if (!Number.isFinite(cost) || cost <= 0) {\n      continue;\n    }\n    costPerDamage = cost;\n    break;\n  }\n\n  if (costPerDamage === null) {\n    return { state, remainingDamage: damage };\n  }\n\n  const player = state.players.find((entry) => entry.id === unit.ownerPlayerId);\n  if (!player) {\n    return { state, remainingDamage: damage };\n  }\n\n  const maxPrevent = Math.floor(player.resources.gold / costPerDamage);\n  if (maxPrevent <= 0) {\n    return { state, remainingDamage: damage };\n  }\n  const prevented = Math.min(damage, maxPrevent);\n  const remainingDamage = damage - prevented;\n\n  const nextState = spendGold(state, unit.ownerPlayerId, prevented * costPerDamage);\n  return { state: nextState, remainingDamage };\n};\n\nexport const applyChampionDeathEffects = (\n  state: GameState,\n  killedChampions: ChampionUnitState[]\n): GameState => {\n  if (killedChampions.length === 0) {\n    return state;\n  }\n\n  let nextState = state;\n  for (const champion of killedChampions) {\n    if (champion.cardDefId !== TRAITOR_CHAMPION_ID) {\n      continue;\n    }\n    nextState = setPlayerMana(nextState, champion.ownerPlayerId, 0);\n  }\n\n  for (const champion of killedChampions) {\n    const hex = nextState.board.hexes[champion.hex];\n    if (!hex) {\n      continue;\n    }\n    const occupantGroups = Object.values(hex.occupants);\n    for (const unitIds of occupantGroups) {\n      for (const unitId of unitIds ?? []) {\n        const unit = nextState.board.units[unitId];\n        if (!unit || unit.kind !== \"champion\") {\n          continue;\n        }\n        if (unit.cardDefId !== BLOOD_BANKER_CHAMPION_ID) {\n          continue;\n        }\n        if (!canChampionUseAbility(unit, BLOOD_LEDGER_KEY)) {\n          continue;\n        }\n        nextState = consumeChampionAbilityUse(nextState, unitId, BLOOD_LEDGER_KEY);\n        nextState = addGold(nextState, unit.ownerPlayerId, 2);\n      }\n    }\n  }\n\n  return nextState;\n};\n\nexport const healChampion = (state: GameState, unitId: UnitID, amount: number): GameState => {\n  if (!Number.isFinite(amount) || amount <= 0) {\n    return state;\n  }\n\n  const unit = state.board.units[unitId];\n  if (!unit || unit.kind !== \"champion\") {\n    return state;\n  }\n\n  const nextHp = Math.min(unit.maxHp, unit.hp + amount);\n  if (nextHp === unit.hp) {\n    return state;\n  }\n\n  return {\n    ...state,\n    board: {\n      ...state.board,\n      units: {\n        ...state.board.units,\n        [unitId]: {\n          ...unit,\n          hp: nextHp\n        }\n      }\n    }\n  };\n};\n\nexport const dealChampionDamage = (\n  state: GameState,\n  sourcePlayerId: PlayerID,\n  unitId: UnitID,\n  amount: number\n): GameState => {\n  if (!Number.isFinite(amount) || amount <= 0) {\n    return state;\n  }\n\n  const initialUnit = state.board.units[unitId];\n  if (!initialUnit || initialUnit.kind !== \"champion\") {\n    return state;\n  }\n\n  const armored = applyGoldArmorToDamage(state, unitId, amount);\n  if (armored.remainingDamage <= 0) {\n    return armored.state;\n  }\n\n  const unit = armored.state.board.units[unitId];\n  if (!unit || unit.kind !== \"champion\") {\n    return armored.state;\n  }\n\n  const nextHp = unit.hp - armored.remainingDamage;\n  if (nextHp > 0) {\n    return {\n      ...armored.state,\n      board: {\n        ...armored.state.board,\n        units: {\n          ...armored.state.board.units,\n          [unitId]: {\n            ...unit,\n            hp: nextHp\n          }\n        }\n      }\n    };\n  }\n\n  const units = { ...armored.state.board.units };\n  delete units[unitId];\n\n  let nextState: GameState = {\n    ...armored.state,\n    board: {\n      ...armored.state.board,\n      units\n    }\n  };\n\n  const hex = armored.state.board.hexes[unit.hex];\n  if (hex) {\n    const updatedHex = {\n      ...hex,\n      occupants: {\n        ...hex.occupants,\n        [unit.ownerPlayerId]: (hex.occupants[unit.ownerPlayerId] ?? []).filter(\n          (id) => id !== unitId\n        )\n      }\n    };\n    nextState = {\n      ...nextState,\n      board: {\n        ...nextState.board,\n        hexes: {\n          ...nextState.board.hexes,\n          [unit.hex]: updatedHex\n        }\n      }\n    };\n  }\n\n  nextState = removeChampionModifiers(nextState, [unitId]);\n  nextState = applyChampionDeathEffects(nextState, [unit]);\n\n  if (unit.ownerPlayerId !== sourcePlayerId) {\n    nextState = applyChampionKillRewards(nextState, {\n      killerPlayerId: sourcePlayerId,\n      victimPlayerId: unit.ownerPlayerId,\n      killedChampions: [unit],\n      bounty: unit.bounty,\n      hexKey: unit.hex,\n      source: \"effect\"\n    });\n  }\n\n  return nextState;\n};\n", "import { shuffle } from \"@bridgefront/shared\";\n\nimport type {\n  BlockState,\n  CardDefId,\n  CardInstanceID,\n  CollectionChoice,\n  CollectionPrompt,\n  GameState,\n  HexKey,\n  PlayerID,\n  PlayerState,\n  RoundEndContext\n} from \"./types\";\nimport { getPlayerIdsOnHex, hasEnemyUnits } from \"./board\";\nimport {\n  createCardInstance,\n  discardCardFromHand,\n  drawToHandSize,\n  insertCardIntoDrawPileRandom,\n  scrapCardFromHand\n} from \"./cards\";\nimport { refreshChampionAbilityUsesForRound } from \"./champions\";\nimport { hasCipherQuietStudy } from \"./faction-passives\";\nimport {\n  applyModifierQuery,\n  expireEndOfRoundModifiers,\n  getCardChoiceCount,\n  getControlBonus,\n  getControlValue,\n  runModifierEvents\n} from \"./modifiers\";\nimport {\n  CARDS_DISCARDED_THIS_ROUND_FLAG,\n  CARDS_PLAYED_THIS_ROUND_FLAG,\n  MOVED_THIS_ROUND_FLAG\n} from \"./player-flags\";\n\nconst MINE_OVERSEER_CHAMPION_ID = \"champion.prospect.mine_overseer\";\nconst QUIET_STUDY_MAX_DISCARD = 2;\n\nexport const applyRoundReset = (state: GameState): GameState => {\n  const nextRound = state.round + 1;\n  const playerCount = state.players.length;\n  let nextState: GameState = {\n    ...state,\n    round: nextRound,\n    leadSeatIndex: playerCount > 0 ? (nextRound - 1) % playerCount : 0,\n    players: state.players.map((player) => ({\n      ...player,\n      resources: {\n        ...player.resources,\n        gold: player.resources.gold + state.config.BASE_INCOME,\n        mana: state.config.MAX_MANA\n      },\n      doneThisRound: false,\n      flags: {\n        ...player.flags,\n        [MOVED_THIS_ROUND_FLAG]: false,\n        [CARDS_PLAYED_THIS_ROUND_FLAG]: 0,\n        [CARDS_DISCARDED_THIS_ROUND_FLAG]: 0\n      }\n    }))\n  };\n\n  nextState = refreshChampionAbilityUsesForRound(nextState);\n\n  for (const player of nextState.players) {\n    nextState = drawToHandSize(nextState, player.id, 6);\n  }\n\n  return {\n    ...nextState,\n    phase: \"round.market\"\n  };\n};\n\nexport const createQuietStudyBlock = (state: GameState): BlockState | null => {\n  const quietStudyPlayers = state.players\n    .filter((player) => hasCipherQuietStudy(state, player.id))\n    .map((player) => player.id);\n\n  if (quietStudyPlayers.length === 0) {\n    return null;\n  }\n\n  return {\n    type: \"round.quietStudy\",\n    waitingFor: quietStudyPlayers,\n    payload: {\n      maxDiscard: QUIET_STUDY_MAX_DISCARD,\n      choices: Object.fromEntries(quietStudyPlayers.map((playerId) => [playerId, null]))\n    }\n  };\n};\n\nconst isQuietStudyChoiceValid = (\n  state: GameState,\n  playerId: PlayerID,\n  cardInstanceIds: CardInstanceID[],\n  maxDiscard: number\n): boolean => {\n  if (cardInstanceIds.length > maxDiscard) {\n    return false;\n  }\n\n  const uniqueIds = new Set(cardInstanceIds);\n  if (uniqueIds.size !== cardInstanceIds.length) {\n    return false;\n  }\n\n  const player = state.players.find((entry) => entry.id === playerId);\n  if (!player) {\n    return false;\n  }\n\n  return cardInstanceIds.every((id) => player.deck.hand.includes(id));\n};\n\nexport const applyQuietStudyChoice = (\n  state: GameState,\n  cardInstanceIds: CardInstanceID[],\n  playerId: PlayerID\n): GameState => {\n  if (state.phase !== \"round.study\") {\n    return state;\n  }\n\n  const block = state.blocks;\n  if (!block || block.type !== \"round.quietStudy\") {\n    return state;\n  }\n\n  if (!block.waitingFor.includes(playerId)) {\n    return state;\n  }\n\n  if (block.payload.choices[playerId]) {\n    return state;\n  }\n\n  if (!isQuietStudyChoiceValid(state, playerId, cardInstanceIds, block.payload.maxDiscard)) {\n    return state;\n  }\n\n  return {\n    ...state,\n    blocks: {\n      ...block,\n      waitingFor: block.waitingFor.filter((id) => id !== playerId),\n      payload: {\n        ...block.payload,\n        choices: {\n          ...block.payload.choices,\n          [playerId]: cardInstanceIds\n        }\n      }\n    }\n  };\n};\n\nexport const resolveQuietStudyChoices = (state: GameState): GameState => {\n  const block = state.blocks;\n  if (!block || block.type !== \"round.quietStudy\") {\n    return state;\n  }\n\n  let nextState = state;\n  for (const player of state.players) {\n    const selected = block.payload.choices[player.id] ?? [];\n    if (selected.length === 0) {\n      continue;\n    }\n    for (const cardInstanceId of selected) {\n      nextState = discardCardFromHand(nextState, player.id, cardInstanceId, {\n        countAsDiscard: true\n      });\n    }\n    nextState = drawToHandSize(nextState, player.id, 6);\n  }\n\n  return nextState;\n};\n\ntype DeckDraw = {\n  drawn: CardDefId[];\n  remaining: CardDefId[];\n};\n\nconst takeFromDeck = (deck: CardDefId[], count: number): DeckDraw => {\n  if (count <= 0 || deck.length === 0) {\n    return { drawn: [], remaining: deck };\n  }\n  const drawn = deck.slice(0, count);\n  const remaining = deck.slice(count);\n  return { drawn, remaining };\n};\n\nconst getSeatOrderedPlayers = (players: PlayerState[]): PlayerState[] => {\n  return [...players].sort((a, b) => a.seatIndex - b.seatIndex);\n};\n\nconst getPromptKey = (kind: CollectionPrompt[\"kind\"], hexKey: string) => `${kind}:${hexKey}`;\n\nconst getPlayer = (state: GameState, playerId: PlayerID) => {\n  const player = state.players.find((entry) => entry.id === playerId);\n  if (!player) {\n    throw new Error(`player not found: ${playerId}`);\n  }\n  return player;\n};\n\nconst addGold = (state: GameState, playerId: PlayerID, amount: number): GameState => {\n  if (amount <= 0) {\n    return state;\n  }\n  return {\n    ...state,\n    players: state.players.map((player) =>\n      player.id === playerId\n        ? {\n            ...player,\n            resources: {\n              ...player.resources,\n              gold: player.resources.gold + amount\n            }\n          }\n        : player\n    )\n  };\n};\n\nconst hasMineOverseer = (state: GameState, playerId: PlayerID, hexKey: HexKey): boolean => {\n  const hex = state.board.hexes[hexKey];\n  if (!hex) {\n    return false;\n  }\n  const unitIds = hex.occupants[playerId] ?? [];\n  return unitIds.some((unitId) => {\n    const unit = state.board.units[unitId];\n    return unit?.kind === \"champion\" && unit.cardDefId === MINE_OVERSEER_CHAMPION_ID;\n  });\n};\n\nconst getMineGoldValue = (\n  state: GameState,\n  playerId: PlayerID,\n  hexKey: HexKey,\n  mineValue: number\n): number => {\n  const baseValue = mineValue + (hasMineOverseer(state, playerId, hexKey) ? 1 : 0);\n  return applyModifierQuery(\n    state,\n    state.modifiers,\n    (hooks) => hooks.getMineGoldValue,\n    { playerId, hexKey, mineValue },\n    baseValue\n  );\n};\n\nconst getChoiceCount = (\n  state: GameState,\n  playerId: PlayerID,\n  kind: \"freeStartingCard\" | \"forgeDraft\" | \"centerPick\",\n  baseCount: number\n): number => {\n  const rawCount = getCardChoiceCount(\n    state,\n    { playerId, kind, baseCount },\n    baseCount\n  );\n  const normalized = Number.isFinite(rawCount) ? Math.floor(rawCount) : baseCount;\n  return Math.max(baseCount, normalized);\n};\n\nconst returnToBottomRandom = (\n  state: GameState,\n  deck: CardDefId[],\n  cardIds: CardDefId[]\n): { state: GameState; deck: CardDefId[] } => {\n  if (cardIds.length === 0) {\n    return { state, deck };\n  }\n  if (cardIds.length === 1) {\n    return { state, deck: [...deck, ...cardIds] };\n  }\n  const { value, next } = shuffle(state.rngState, cardIds);\n  return { state: { ...state, rngState: next }, deck: [...deck, ...value] };\n};\n\nconst buildCollectionPrompts = (state: GameState): Record<PlayerID, CollectionPrompt[]> => {\n  const prompts: Record<PlayerID, CollectionPrompt[]> = Object.fromEntries(\n    state.players.map((player) => [player.id, []])\n  );\n\n  const specialHexes = Object.values(state.board.hexes)\n    .filter((hex) => hex.tile === \"forge\" || hex.tile === \"center\")\n    .sort((a, b) => a.key.localeCompare(b.key));\n\n  for (const hex of specialHexes) {\n    const occupants = getPlayerIdsOnHex(hex);\n    if (occupants.length !== 1) {\n      continue;\n    }\n    const playerId = occupants[0];\n    if (!prompts[playerId]) {\n      continue;\n    }\n    if (hex.tile === \"forge\") {\n      prompts[playerId].push({\n        kind: \"forge\",\n        hexKey: hex.key,\n        revealed: []\n      });\n    } else if (hex.tile === \"center\") {\n      prompts[playerId].push({\n        kind: \"center\",\n        hexKey: hex.key,\n        revealed: []\n      });\n    }\n  }\n\n  return prompts;\n};\n\nconst applyMineGoldCollection = (state: GameState): GameState => {\n  const mineHexes = Object.values(state.board.hexes)\n    .filter((hex) => hex.tile === \"mine\")\n    .sort((a, b) => a.key.localeCompare(b.key));\n\n  let nextState = state;\n  for (const hex of mineHexes) {\n    const occupants = getPlayerIdsOnHex(hex);\n    if (occupants.length !== 1) {\n      continue;\n    }\n    const playerId = occupants[0];\n    const mineGold = getMineGoldValue(nextState, playerId, hex.key, hex.mineValue ?? 0);\n    nextState = addGold(nextState, playerId, mineGold);\n  }\n\n  return nextState;\n};\n\nexport const createCollectionBlock = (\n  state: GameState\n): { state: GameState; block: BlockState | null } => {\n  const stateWithMineGold = applyMineGoldCollection(state);\n  const promptsByPlayer = buildCollectionPrompts(stateWithMineGold);\n  const playersInSeatOrder = getSeatOrderedPlayers(stateWithMineGold.players);\n\n  const currentAge = stateWithMineGold.market.age;\n  let marketDeck = stateWithMineGold.marketDecks[currentAge] ?? [];\n  let powerDeck = stateWithMineGold.powerDecks[currentAge] ?? [];\n  const nextPrompts: Record<PlayerID, CollectionPrompt[]> = { ...promptsByPlayer };\n\n  for (const player of playersInSeatOrder) {\n    const prompts = promptsByPlayer[player.id] ?? [];\n    if (prompts.length === 0) {\n      continue;\n    }\n    const resolved: CollectionPrompt[] = [];\n    for (const prompt of prompts) {\n      let drawn: CardDefId[] = [];\n      if (prompt.kind === \"forge\") {\n        const drawCount = getChoiceCount(stateWithMineGold, player.id, \"forgeDraft\", 3);\n        const draw = takeFromDeck(marketDeck, drawCount);\n        drawn = draw.drawn;\n        marketDeck = draw.remaining;\n      } else if (prompt.kind === \"center\") {\n        const drawCount = getChoiceCount(stateWithMineGold, player.id, \"centerPick\", 2);\n        const draw = takeFromDeck(powerDeck, drawCount);\n        drawn = draw.drawn;\n        powerDeck = draw.remaining;\n      }\n      if (prompt.kind === \"center\" && drawn.length === 0) {\n        continue;\n      }\n      resolved.push({ ...prompt, revealed: drawn });\n    }\n    nextPrompts[player.id] = resolved;\n  }\n\n  const waitingFor = playersInSeatOrder\n    .filter((player) => (nextPrompts[player.id] ?? []).length > 0)\n    .map((player) => player.id);\n\n  if (waitingFor.length === 0) {\n    return {\n      state: {\n        ...stateWithMineGold,\n        marketDecks: {\n          ...stateWithMineGold.marketDecks,\n          [currentAge]: marketDeck\n        },\n        powerDecks: {\n          ...stateWithMineGold.powerDecks,\n          [currentAge]: powerDeck\n        }\n      },\n      block: null\n    };\n  }\n\n  const nextState: GameState = {\n    ...stateWithMineGold,\n    marketDecks: {\n      ...stateWithMineGold.marketDecks,\n      [currentAge]: marketDeck\n    },\n    powerDecks: {\n      ...stateWithMineGold.powerDecks,\n      [currentAge]: powerDeck\n    }\n  };\n\n  return {\n    state: nextState,\n    block: {\n      type: \"collection.choices\",\n      waitingFor,\n      payload: {\n        prompts: nextPrompts,\n        choices: Object.fromEntries(\n          stateWithMineGold.players.map((player) => [player.id, null])\n        ) as Record<PlayerID, CollectionChoice[] | null>\n      }\n    }\n  };\n};\n\nconst isCollectionChoiceValid = (\n  state: GameState,\n  playerId: PlayerID,\n  prompt: CollectionPrompt,\n  choice: CollectionChoice\n): boolean => {\n  if (prompt.kind !== choice.kind || prompt.hexKey !== choice.hexKey) {\n    return false;\n  }\n\n  if (choice.kind === \"forge\") {\n    if (choice.choice === \"reforge\") {\n      const player = getPlayer(state, playerId);\n      return player.deck.hand.includes(choice.scrapCardId);\n    }\n    return prompt.revealed.includes(choice.cardId);\n  }\n\n  if (choice.kind === \"center\") {\n    return prompt.revealed.includes(choice.cardId);\n  }\n\n  return false;\n};\n\nconst areCollectionChoicesValid = (\n  state: GameState,\n  playerId: PlayerID,\n  prompts: CollectionPrompt[],\n  choices: CollectionChoice[]\n): boolean => {\n  if (choices.length !== prompts.length) {\n    return false;\n  }\n\n  const promptMap = new Map<string, CollectionPrompt>(\n    prompts.map((prompt) => [getPromptKey(prompt.kind, prompt.hexKey), prompt])\n  );\n  const seen = new Set<string>();\n\n  for (const choice of choices) {\n    const key = getPromptKey(choice.kind, choice.hexKey);\n    if (seen.has(key)) {\n      return false;\n    }\n    const prompt = promptMap.get(key);\n    if (!prompt) {\n      return false;\n    }\n    if (!isCollectionChoiceValid(state, playerId, prompt, choice)) {\n      return false;\n    }\n    seen.add(key);\n  }\n\n  return seen.size === prompts.length;\n};\n\nexport const applyCollectionChoice = (\n  state: GameState,\n  choices: CollectionChoice[],\n  playerId: PlayerID\n): GameState => {\n  if (state.phase !== \"round.collection\") {\n    return state;\n  }\n\n  const block = state.blocks;\n  if (!block || block.type !== \"collection.choices\") {\n    return state;\n  }\n\n  if (!block.waitingFor.includes(playerId)) {\n    return state;\n  }\n\n  if (block.payload.choices[playerId]) {\n    return state;\n  }\n\n  const prompts = block.payload.prompts[playerId] ?? [];\n  if (prompts.length === 0) {\n    return state;\n  }\n\n  if (!areCollectionChoicesValid(state, playerId, prompts, choices)) {\n    return state;\n  }\n\n  return {\n    ...state,\n    blocks: {\n      ...block,\n      waitingFor: block.waitingFor.filter((id) => id !== playerId),\n      payload: {\n        ...block.payload,\n        choices: {\n          ...block.payload.choices,\n          [playerId]: choices\n        }\n      }\n    }\n  };\n};\n\nexport const resolveCollectionChoices = (state: GameState): GameState => {\n  const block = state.blocks;\n  if (!block || block.type !== \"collection.choices\") {\n    return state;\n  }\n\n  const currentAge = state.market.age;\n  let marketDeck = state.marketDecks[currentAge] ?? [];\n  let powerDeck = state.powerDecks[currentAge] ?? [];\n  let nextState: GameState = state;\n  const playersInSeatOrder = getSeatOrderedPlayers(state.players);\n\n  for (const player of playersInSeatOrder) {\n    const prompts = block.payload.prompts[player.id] ?? [];\n    const choices = block.payload.choices[player.id] ?? [];\n    if (prompts.length === 0) {\n      continue;\n    }\n    const choiceMap = new Map(\n      choices.map((choice) => [getPromptKey(choice.kind, choice.hexKey), choice])\n    );\n\n    for (const prompt of prompts) {\n      const choice = choiceMap.get(getPromptKey(prompt.kind, prompt.hexKey));\n      if (!choice) {\n        continue;\n      }\n\n      if (choice.kind === \"forge\") {\n        if (choice.choice === \"reforge\") {\n          nextState = scrapCardFromHand(nextState, player.id, choice.scrapCardId);\n          const returned = returnToBottomRandom(nextState, marketDeck, prompt.revealed);\n          nextState = returned.state;\n          marketDeck = returned.deck;\n        } else if (prompt.revealed.includes(choice.cardId)) {\n          const leftovers = prompt.revealed.filter((cardId) => cardId !== choice.cardId);\n          const returned = returnToBottomRandom(nextState, marketDeck, leftovers);\n          nextState = returned.state;\n          marketDeck = returned.deck;\n          const created = createCardInstance(nextState, choice.cardId);\n          nextState = insertCardIntoDrawPileRandom(\n            created.state,\n            player.id,\n            created.instanceId\n          );\n        }\n      } else if (choice.kind === \"center\") {\n        if (prompt.revealed.includes(choice.cardId)) {\n          const leftovers = prompt.revealed.filter((cardId) => cardId !== choice.cardId);\n          const returned = returnToBottomRandom(nextState, powerDeck, leftovers);\n          nextState = returned.state;\n          powerDeck = returned.deck;\n          const created = createCardInstance(nextState, choice.cardId);\n          nextState = insertCardIntoDrawPileRandom(\n            created.state,\n            player.id,\n            created.instanceId\n          );\n        }\n      }\n    }\n  }\n\n  return {\n    ...nextState,\n    marketDecks: {\n      ...nextState.marketDecks,\n      [currentAge]: marketDeck\n    },\n    powerDecks: {\n      ...nextState.powerDecks,\n      [currentAge]: powerDeck\n    }\n  };\n};\n\ntype ControlTotals = Record<PlayerID, number>;\n\nconst addControl = (totals: ControlTotals, playerId: PlayerID, amount: number) => {\n  if (amount <= 0) {\n    return totals;\n  }\n  return {\n    ...totals,\n    [playerId]: (totals[playerId] ?? 0) + amount\n  };\n};\n\nexport const getControlTotals = (state: GameState): ControlTotals => {\n  let controlTotals: ControlTotals = {};\n\n  for (const hex of Object.values(state.board.hexes)) {\n    if (hex.tile !== \"center\" && hex.tile !== \"forge\" && hex.tile !== \"capital\") {\n      continue;\n    }\n    const occupants = getPlayerIdsOnHex(hex);\n    if (occupants.length !== 1) {\n      continue;\n    }\n    const occupant = occupants[0];\n    let baseControl = 0;\n    if (hex.tile === \"center\" || hex.tile === \"forge\") {\n      baseControl = 1;\n    } else if (hex.tile === \"capital\" && hex.ownerPlayerId && hex.ownerPlayerId !== occupant) {\n      baseControl = 1;\n    }\n    if (baseControl <= 0) {\n      continue;\n    }\n    const adjusted = getControlValue(\n      state,\n      { playerId: occupant, hexKey: hex.key, tile: hex.tile, baseValue: baseControl },\n      baseControl\n    );\n    controlTotals = addControl(controlTotals, occupant, adjusted);\n  }\n\n  return controlTotals;\n};\n\nconst resolveTiebreak = (players: GameState[\"players\"]): PlayerID | null => {\n  if (players.length === 0) {\n    return null;\n  }\n\n  const sorted = [...players].sort((a, b) => {\n    if (a.vp.total !== b.vp.total) {\n      return b.vp.total - a.vp.total;\n    }\n    if (a.vp.permanent !== b.vp.permanent) {\n      return b.vp.permanent - a.vp.permanent;\n    }\n    if (a.resources.gold !== b.resources.gold) {\n      return b.resources.gold - a.resources.gold;\n    }\n    return a.seatIndex - b.seatIndex;\n  });\n\n  return sorted[0]?.id ?? null;\n};\n\nconst capitalIsSafe = (state: GameState, playerId: PlayerID): boolean => {\n  const player = state.players.find((entry) => entry.id === playerId);\n  if (!player?.capitalHex) {\n    return false;\n  }\n  const capital = state.board.hexes[player.capitalHex];\n  if (!capital) {\n    return false;\n  }\n  return !hasEnemyUnits(capital, playerId);\n};\n\nexport const applyScoring = (state: GameState): GameState => {\n  const controlTotals = getControlTotals(state);\n\n  const players = state.players.map((player) => {\n    const controlBonus = getControlBonus(state, { playerId: player.id }, 0);\n    const control = (controlTotals[player.id] ?? 0) + controlBonus;\n    const total = player.vp.permanent + control;\n    return {\n      ...player,\n      vp: {\n        ...player.vp,\n        control,\n        total\n      }\n    };\n  });\n\n  let winnerPlayerId: PlayerID | null = null;\n  const eligibleWinners = players.filter(\n    (player) =>\n      player.vp.total >= state.config.VP_TO_WIN && capitalIsSafe(state, player.id)\n  );\n\n  if (eligibleWinners.length > 0) {\n    winnerPlayerId = resolveTiebreak(eligibleWinners);\n  } else if (state.round >= state.config.ROUNDS_MAX) {\n    winnerPlayerId = resolveTiebreak(players);\n  }\n\n  return {\n    ...state,\n    players,\n    winnerPlayerId\n  };\n};\n\nexport const applyCleanup = (state: GameState): GameState => {\n  const players = state.players.map((player) => ({\n    ...player,\n    deck: {\n      ...player.deck,\n      discardPile: [...player.deck.discardPile, ...player.deck.hand],\n      hand: []\n    },\n    doneThisRound: false\n  }));\n\n  let nextState: GameState = {\n    ...state,\n    players\n  };\n\n  const roundEndContext: RoundEndContext = { round: state.round };\n  nextState = runModifierEvents(\n    nextState,\n    nextState.modifiers,\n    (hooks) => hooks.onRoundEnd,\n    roundEndContext\n  );\n\n  const bridges = Object.fromEntries(\n    Object.entries(nextState.board.bridges).filter(([, bridge]) => !bridge.temporary)\n  );\n\n  const modifiers = expireEndOfRoundModifiers(nextState).modifiers;\n\n  return {\n    ...nextState,\n    board: {\n      ...nextState.board,\n      bridges\n    },\n    modifiers,\n    market: {\n      ...nextState.market,\n      currentRow: [],\n      rowIndexResolving: 0,\n      passPot: 0,\n      bids: Object.fromEntries(nextState.players.map((player) => [player.id, null])),\n      playersOut: Object.fromEntries(nextState.players.map((player) => [player.id, false])),\n      rollOff: null\n    }\n  };\n};\n\nexport const applyAgeUpdate = (state: GameState): GameState => {\n  const upcomingAge = state.config.ageByRound[state.round + 1];\n  if (!upcomingAge) {\n    return state;\n  }\n\n  return {\n    ...state,\n    market: {\n      ...state.market,\n      age: upcomingAge\n    }\n  };\n};\n", "import type { GameState, HexKey, PlayerID } from \"./types\";\nimport { getCenterHexKey, isOccupiedByPlayer, wouldExceedTwoPlayers } from \"./board\";\nimport { hasAerialWings } from \"./faction-passives\";\n\nconst LOGISTICS_OFFICER_CHAMPION_ID = \"champion.age3.logistics_officer\";\n\nconst getCapitalHexKey = (state: GameState, playerId: PlayerID): HexKey | null => {\n  const player = state.players.find((entry) => entry.id === playerId);\n  if (!player?.capitalHex) {\n    return null;\n  }\n  if (!state.board.hexes[player.capitalHex]) {\n    return null;\n  }\n  return player.capitalHex;\n};\n\nconst getAerialCenterHexKey = (state: GameState, playerId: PlayerID): HexKey | null => {\n  if (!hasAerialWings(state, playerId)) {\n    return null;\n  }\n  const centerHexKey = getCenterHexKey(state.board);\n  if (!centerHexKey) {\n    return null;\n  }\n  const centerHex = state.board.hexes[centerHexKey];\n  if (!centerHex) {\n    return null;\n  }\n  if (!isOccupiedByPlayer(centerHex, playerId)) {\n    return null;\n  }\n  return centerHexKey;\n};\n\nconst getLogisticsOfficerHexKeys = (state: GameState, playerId: PlayerID): HexKey[] => {\n  const hexKeys = new Set<HexKey>();\n  for (const unit of Object.values(state.board.units)) {\n    if (unit.kind !== \"champion\") {\n      continue;\n    }\n    if (unit.ownerPlayerId !== playerId) {\n      continue;\n    }\n    if (unit.cardDefId !== LOGISTICS_OFFICER_CHAMPION_ID) {\n      continue;\n    }\n    if (state.board.hexes[unit.hex]) {\n      hexKeys.add(unit.hex);\n    }\n  }\n  return [...hexKeys];\n};\n\nconst isDeployable = (state: GameState, playerId: PlayerID, hexKey: HexKey): boolean => {\n  const hex = state.board.hexes[hexKey];\n  if (!hex) {\n    return false;\n  }\n  return !wouldExceedTwoPlayers(hex, playerId);\n};\n\nexport const resolveCapitalDeployHex = (\n  state: GameState,\n  playerId: PlayerID,\n  preferredHex?: HexKey | null\n): HexKey | null => {\n  const capitalHexKey = getCapitalHexKey(state, playerId);\n  const centerHexKey = getAerialCenterHexKey(state, playerId);\n  const candidates: HexKey[] = [];\n\n  if (capitalHexKey) {\n    candidates.push(capitalHexKey);\n  }\n  if (centerHexKey && centerHexKey !== capitalHexKey) {\n    candidates.push(centerHexKey);\n  }\n  for (const hexKey of getLogisticsOfficerHexKeys(state, playerId)) {\n    if (!candidates.includes(hexKey)) {\n      candidates.push(hexKey);\n    }\n  }\n\n  if (preferredHex) {\n    if (!candidates.includes(preferredHex)) {\n      return null;\n    }\n    return isDeployable(state, playerId, preferredHex) ? preferredHex : null;\n  }\n\n  for (const hexKey of candidates) {\n    if (isDeployable(state, playerId, hexKey)) {\n      return hexKey;\n    }\n  }\n\n  return null;\n};\n", "import type { CardDef } from \"./content/cards\";\nimport {\n  areAdjacent,\n  axialDistance,\n  neighborHexKeys,\n  parseEdgeKey,\n  parseHexKey,\n  randInt\n} from \"@bridgefront/shared\";\n\nimport type {\n  BlockState,\n  CardInstanceID,\n  CardPlayTargets,\n  GameState,\n  Modifier,\n  PlayerID,\n  TileType\n} from \"./types\";\nimport {\n  countPlayersOnHex,\n  getCenterHexKey,\n  getBridgeKey,\n  hasBridge,\n  hasEnemyUnits,\n  isOccupiedByPlayer,\n  wouldExceedTwoPlayers\n} from \"./board\";\nimport {\n  addCardToBurned,\n  addCardToDiscardPile,\n  addCardToHandWithOverflow,\n  createCardInstance,\n  discardCardFromHand,\n  drawCards,\n  removeCardFromHand,\n  takeTopCards,\n  topdeckCardFromHand\n} from \"./cards\";\nimport {\n  applyChampionDeployment,\n  dealChampionDamage,\n  healChampion,\n  removeChampionModifiers\n} from \"./champions\";\nimport {\n  addChampionToHex,\n  addForcesToHex,\n  countPlayerChampions,\n  moveUnitToHex,\n  selectMovingUnits\n} from \"./units\";\nimport {\n  getDeployForcesCount,\n  getMoveAdjacency,\n  getMoveMaxDistance,\n  getMoveRequiresBridge,\n  runMoveEvents\n} from \"./modifiers\";\nimport { resolveCapitalDeployHex } from \"./deploy-utils\";\nimport { markPlayerMovedThisRound } from \"./player-flags\";\n\nconst SUPPORTED_TARGET_KINDS = new Set([\n  \"none\",\n  \"edge\",\n  \"multiEdge\",\n  \"stack\",\n  \"path\",\n  \"multiPath\",\n  \"champion\",\n  \"choice\",\n  \"hex\",\n  \"hexPair\"\n]);\nconst SUPPORTED_EFFECTS = new Set([\n  \"gainGold\",\n  \"gainMana\",\n  \"gainManaIfTile\",\n  \"drawCards\",\n  \"drawCardsOtherPlayers\",\n  \"rollGold\",\n  \"drawCardsIfTile\",\n  \"drawCardsIfHandEmpty\",\n  \"discardFromHand\",\n  \"burnFromHand\",\n  \"scoutReport\",\n  \"prospecting\",\n  \"gainGoldIfEnemyCapital\",\n  \"buildBridge\",\n  \"moveStack\",\n  \"moveStacks\",\n  \"deployForces\",\n  \"recruitByHandSize\",\n  \"deployForcesOnMines\",\n  \"increaseMineValue\",\n  \"healChampion\",\n  \"healChampions\",\n  \"dealChampionDamage\",\n  \"goldPlatedArmor\",\n  \"patchUp\",\n  \"recruit\",\n  \"holdTheLine\",\n  \"markForCoin\",\n  \"topdeckFromHand\",\n  \"ward\",\n  \"immunityField\",\n  \"lockBridge\",\n  \"trapBridge\",\n  \"destroyBridge\",\n  \"bridgePivot\",\n  \"battleWinDraw\",\n  \"destroyConnectedBridges\",\n  \"linkHexes\",\n  \"linkCapitalToCenter\",\n  \"battleCry\",\n  \"smokeScreen\",\n  \"frenzy\",\n  \"shockDrill\",\n  \"focusFire\",\n  \"encirclement\",\n  \"mortarShot\",\n  \"setToSkirmish\",\n  \"evacuateChampion\",\n  \"recallChampion\"\n]);\n\ntype TargetRecord = Record<string, unknown>;\n\ntype BuildBridgePlan = {\n  from: string;\n  to: string;\n  key: string;\n};\n\ntype MoveValidation = {\n  maxDistance?: number;\n  requiresBridge: boolean;\n  requireStartOccupied: boolean;\n  forceCount?: number;\n  includeChampions?: boolean;\n  movingUnitIds?: string[];\n  stopOnOccupied?: boolean;\n};\n\nconst getTargetRecord = (targets: CardPlayTargets): TargetRecord | null => {\n  if (!targets || typeof targets !== \"object\") {\n    return null;\n  }\n  return targets as TargetRecord;\n};\n\nconst getForceCountTarget = (targets: CardPlayTargets): number | null => {\n  const record = getTargetRecord(targets);\n  const forceCount = record?.forceCount;\n  return typeof forceCount === \"number\" && Number.isFinite(forceCount) ? forceCount : null;\n};\n\nconst getBooleanTarget = (targets: CardPlayTargets, key: string): boolean | null => {\n  const record = getTargetRecord(targets);\n  const value = record?.[key];\n  return typeof value === \"boolean\" ? value : null;\n};\n\nconst getMoveStackForceCount = (\n  card: CardDef,\n  effect?: TargetRecord,\n  targets?: CardPlayTargets\n): number | undefined => {\n  const targetCount = getForceCountTarget(targets ?? null);\n  if (targetCount !== null) {\n    return targetCount;\n  }\n  const effectCount = effect?.forceCount;\n  if (typeof effectCount === \"number\") {\n    return effectCount;\n  }\n  const specCount = (card.targetSpec as TargetRecord | undefined)?.forceCount;\n  if (typeof specCount === \"number\") {\n    return specCount;\n  }\n  return undefined;\n};\n\nconst getMoveStackIncludeChampions = (\n  card: CardDef,\n  effect?: TargetRecord,\n  targets?: CardPlayTargets\n): boolean | undefined => {\n  const targetInclude = getBooleanTarget(targets ?? null, \"includeChampions\");\n  if (targetInclude !== null) {\n    return targetInclude;\n  }\n  const effectInclude = effect?.includeChampions;\n  if (typeof effectInclude === \"boolean\") {\n    return effectInclude;\n  }\n  const specInclude = (card.targetSpec as TargetRecord | undefined)?.includeChampions;\n  if (typeof specInclude === \"boolean\") {\n    return specInclude;\n  }\n  return undefined;\n};\n\nconst getEdgeKeyTarget = (targets: CardPlayTargets): string | null => {\n  const record = getTargetRecord(targets);\n  const edgeKey = record?.edgeKey;\n  return typeof edgeKey === \"string\" && edgeKey.length > 0 ? edgeKey : null;\n};\n\nconst getEdgeKeyTargets = (targets: CardPlayTargets): string[] | null => {\n  const record = getTargetRecord(targets);\n  const raw = record?.edgeKeys ?? record?.edges ?? record?.edgeKey;\n  if (!raw) {\n    return null;\n  }\n  if (typeof raw === \"string\") {\n    return raw.length > 0 ? [raw] : null;\n  }\n  if (!Array.isArray(raw) || raw.length === 0) {\n    return null;\n  }\n  const edges: string[] = [];\n  for (const entry of raw) {\n    if (typeof entry !== \"string\" || entry.length === 0) {\n      return null;\n    }\n    edges.push(entry);\n  }\n  return edges;\n};\n\nconst getHexKeyTarget = (targets: CardPlayTargets): string | null => {\n  const record = getTargetRecord(targets);\n  const hexKey = record?.hexKey;\n  return typeof hexKey === \"string\" && hexKey.length > 0 ? hexKey : null;\n};\n\nconst getPathTarget = (targets: CardPlayTargets): string[] | null => {\n  const record = getTargetRecord(targets);\n  const path = record?.path;\n  if (!Array.isArray(path) || path.length < 2) {\n    return null;\n  }\n  if (!path.every((entry) => typeof entry === \"string\" && entry.length > 0)) {\n    return null;\n  }\n  return path;\n};\n\nconst getStackTarget = (targets: CardPlayTargets): { from: string; to: string } | null => {\n  const record = getTargetRecord(targets);\n  const from = record?.from;\n  const to = record?.to;\n  if (typeof from !== \"string\" || typeof to !== \"string\") {\n    return null;\n  }\n  if (from.length === 0 || to.length === 0) {\n    return null;\n  }\n  return { from, to };\n};\n\nconst getMovePathTarget = (targets: CardPlayTargets): string[] | null => {\n  const path = getPathTarget(targets);\n  if (path) {\n    return path;\n  }\n  const stack = getStackTarget(targets);\n  if (!stack) {\n    return null;\n  }\n  return [stack.from, stack.to];\n};\n\nconst normalizePath = (value: unknown): string[] | null => {\n  if (!Array.isArray(value) || value.length < 2) {\n    return null;\n  }\n  if (!value.every((entry) => typeof entry === \"string\" && entry.length > 0)) {\n    return null;\n  }\n  return value as string[];\n};\n\nconst getMultiPathTargets = (targets: CardPlayTargets): string[][] | null => {\n  const record = getTargetRecord(targets);\n  const raw = record?.paths ?? record?.path;\n  if (!raw) {\n    return null;\n  }\n  if (!Array.isArray(raw) || raw.length === 0) {\n    return null;\n  }\n  if (raw.every((entry) => typeof entry === \"string\")) {\n    const single = normalizePath(raw);\n    return single ? [single] : null;\n  }\n  const paths: string[][] = [];\n  for (const entry of raw) {\n    const path = normalizePath(entry);\n    if (!path) {\n      return null;\n    }\n    paths.push(path);\n  }\n  return paths.length > 0 ? paths : null;\n};\n\nconst getChoiceTarget = (\n  targets: CardPlayTargets\n):\n  | { kind: \"capital\"; hexKey?: string }\n  | { kind: \"occupiedHex\"; hexKey: string }\n  | null => {\n  const record = getTargetRecord(targets);\n  const choice = record?.choice ?? record?.kind;\n  if (choice === \"capital\") {\n    const hexKey = record?.hexKey;\n    if (typeof hexKey === \"string\" && hexKey.length > 0) {\n      return { kind: \"capital\", hexKey };\n    }\n    return { kind: \"capital\" };\n  }\n  if (choice === \"occupiedHex\") {\n    const hexKey = record?.hexKey;\n    if (typeof hexKey !== \"string\" || hexKey.length === 0) {\n      return null;\n    }\n    return { kind: \"occupiedHex\", hexKey };\n  }\n  return null;\n};\n\nconst getChampionTargetId = (targets: CardPlayTargets): string | null => {\n  const record = getTargetRecord(targets);\n  const unitId = record?.unitId ?? record?.championId;\n  return typeof unitId === \"string\" && unitId.length > 0 ? unitId : null;\n};\n\nconst getCardInstanceTargets = (targets: CardPlayTargets): string[] => {\n  const record = getTargetRecord(targets);\n  const ids = record?.cardInstanceIds;\n  if (Array.isArray(ids)) {\n    return ids.filter((entry) => typeof entry === \"string\" && entry.length > 0);\n  }\n  const id = record?.cardInstanceId;\n  return typeof id === \"string\" && id.length > 0 ? [id] : [];\n};\n\nconst isWithinDistance = (from: string, to: string, maxDistance: number): boolean => {\n  if (!Number.isFinite(maxDistance) || maxDistance < 0) {\n    return false;\n  }\n  try {\n    return axialDistance(parseHexKey(from), parseHexKey(to)) <= maxDistance;\n  } catch {\n    return false;\n  }\n};\n\nconst hasFriendlyChampionWithinRange = (\n  state: GameState,\n  playerId: PlayerID,\n  targetHex: string,\n  maxDistance: number\n): boolean => {\n  return Object.values(state.board.units).some(\n    (unit) =>\n      unit.kind === \"champion\" &&\n      unit.ownerPlayerId === playerId &&\n      isWithinDistance(unit.hex, targetHex, maxDistance)\n  );\n};\n\nconst hasFriendlyForceWithinRange = (\n  state: GameState,\n  playerId: PlayerID,\n  targetHex: string,\n  maxDistance: number\n): boolean => {\n  return Object.values(state.board.units).some(\n    (unit) =>\n      unit.kind === \"force\" &&\n      unit.ownerPlayerId === playerId &&\n      isWithinDistance(unit.hex, targetHex, maxDistance)\n  );\n};\n\ntype TargetingGuard = {\n  blockEnemyCards: boolean;\n  blockEnemySpells: boolean;\n  scope: \"attachedUnit\" | \"ownerChampions\";\n};\n\nconst isModifierActive = (modifier: Modifier): boolean => {\n  if (modifier.duration.type === \"uses\") {\n    return modifier.duration.remaining > 0;\n  }\n  return true;\n};\n\nconst removeModifierById = (state: GameState, modifierId: string): GameState => {\n  const nextModifiers = state.modifiers.filter((modifier) => modifier.id !== modifierId);\n  return nextModifiers.length === state.modifiers.length\n    ? state\n    : { ...state, modifiers: nextModifiers };\n};\n\nconst getTargetingGuard = (modifier: Modifier): TargetingGuard | null => {\n  if (!isModifierActive(modifier)) {\n    return null;\n  }\n  const raw = modifier.data?.targeting;\n  if (!raw || typeof raw !== \"object\") {\n    return null;\n  }\n  const record = raw as Record<string, unknown>;\n  const blockEnemyCards = record.blockEnemyCards === true;\n  const blockEnemySpells = record.blockEnemySpells === true;\n  if (!blockEnemyCards && !blockEnemySpells) {\n    return null;\n  }\n  const scope = record.scope === \"ownerChampions\" ? \"ownerChampions\" : \"attachedUnit\";\n  return { blockEnemyCards, blockEnemySpells, scope };\n};\n\nconst guardAppliesToChampion = (\n  modifier: Modifier,\n  guard: TargetingGuard,\n  unitId: string,\n  unitOwnerId: PlayerID\n): boolean => {\n  if (guard.scope === \"ownerChampions\") {\n    return modifier.ownerPlayerId === unitOwnerId;\n  }\n  return modifier.attachedUnitId === unitId;\n};\n\nconst isChampionTargetableByCard = (\n  state: GameState,\n  playerId: PlayerID,\n  card: CardDef,\n  unit: GameState[\"board\"][\"units\"][string]\n): boolean => {\n  if (playerId === unit.ownerPlayerId) {\n    return true;\n  }\n  const isSpell = card.type === \"Spell\";\n\n  for (const modifier of state.modifiers) {\n    const guard = getTargetingGuard(modifier);\n    if (!guard) {\n      continue;\n    }\n    if (!guardAppliesToChampion(modifier, guard, unit.id, unit.ownerPlayerId)) {\n      continue;\n    }\n    if (guard.blockEnemyCards) {\n      return false;\n    }\n    if (guard.blockEnemySpells && isSpell) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nconst getChampionTarget = (\n  state: GameState,\n  playerId: PlayerID,\n  targetSpec: TargetRecord,\n  targets: CardPlayTargets,\n  card?: CardDef\n): { unitId: string; unit: GameState[\"board\"][\"units\"][string] } | null => {\n  const unitId = getChampionTargetId(targets);\n  if (!unitId) {\n    return null;\n  }\n\n  const unit = state.board.units[unitId];\n  if (!unit || unit.kind !== \"champion\") {\n    return null;\n  }\n\n  if (!state.board.hexes[unit.hex]) {\n    return null;\n  }\n\n  const owner = typeof targetSpec.owner === \"string\" ? targetSpec.owner : \"self\";\n  if (owner !== \"self\" && owner !== \"enemy\" && owner !== \"any\") {\n    return null;\n  }\n  if (owner === \"self\" && unit.ownerPlayerId !== playerId) {\n    return null;\n  }\n  if (owner === \"enemy\" && unit.ownerPlayerId === playerId) {\n    return null;\n  }\n\n  if (targetSpec.requiresFriendlyChampion === true) {\n    const maxDistance =\n      typeof targetSpec.maxDistance === \"number\" ? targetSpec.maxDistance : NaN;\n    if (!hasFriendlyChampionWithinRange(state, playerId, unit.hex, maxDistance)) {\n      return null;\n    }\n  }\n\n  if (card && !isChampionTargetableByCard(state, playerId, card, unit)) {\n    return null;\n  }\n\n  return { unitId, unit };\n};\n\nconst resolveHexTarget = (\n  state: GameState,\n  playerId: PlayerID,\n  targetSpec: TargetRecord,\n  hexKey: string\n): { hexKey: string; hex: GameState[\"board\"][\"hexes\"][string] } | null => {\n  const hex = state.board.hexes[hexKey];\n  if (!hex) {\n    return null;\n  }\n\n  const owner = typeof targetSpec.owner === \"string\" ? targetSpec.owner : \"any\";\n  if (owner !== \"self\" && owner !== \"enemy\" && owner !== \"any\") {\n    return null;\n  }\n  const allowEmpty = targetSpec.allowEmpty === true;\n  const requiresEmpty = targetSpec.requiresEmpty === true;\n  const isEmpty = countPlayersOnHex(hex) === 0;\n\n  if (owner === \"self\" && !isOccupiedByPlayer(hex, playerId)) {\n    if (!(allowEmpty || requiresEmpty) || !isEmpty) {\n      return null;\n    }\n  }\n\n  if (owner === \"enemy\" && !hasEnemyUnits(hex, playerId)) {\n    return null;\n  }\n\n  const requiresOccupied = targetSpec.occupied === true;\n  if (requiresOccupied && isEmpty) {\n    return null;\n  }\n\n  const tile = typeof targetSpec.tile === \"string\" ? targetSpec.tile : null;\n  if (tile && hex.tile !== tile) {\n    return null;\n  }\n\n  if (targetSpec.allowCapital === false && hex.tile === \"capital\") {\n    return null;\n  }\n\n  if (requiresEmpty && !isEmpty) {\n    return null;\n  }\n\n  const maxDistanceFromCapital =\n    typeof targetSpec.maxDistanceFromCapital === \"number\"\n      ? targetSpec.maxDistanceFromCapital\n      : NaN;\n  if (Number.isFinite(maxDistanceFromCapital)) {\n    const player = state.players.find((entry) => entry.id === playerId);\n    if (!player?.capitalHex) {\n      return null;\n    }\n    if (!state.board.hexes[player.capitalHex]) {\n      return null;\n    }\n    if (!isWithinDistance(player.capitalHex, hexKey, maxDistanceFromCapital)) {\n      return null;\n    }\n  }\n\n  const maxDistance =\n    typeof targetSpec.maxDistanceFromFriendlyChampion === \"number\"\n      ? targetSpec.maxDistanceFromFriendlyChampion\n      : NaN;\n  if (Number.isFinite(maxDistance)) {\n    if (!hasFriendlyChampionWithinRange(state, playerId, hexKey, maxDistance)) {\n      return null;\n    }\n  }\n\n  return { hexKey, hex };\n};\n\nconst getHexTarget = (\n  state: GameState,\n  playerId: PlayerID,\n  targetSpec: TargetRecord,\n  targets: CardPlayTargets\n): { hexKey: string; hex: GameState[\"board\"][\"hexes\"][string] } | null => {\n  const hexKey = getHexKeyTarget(targets);\n  if (!hexKey) {\n    return null;\n  }\n  return resolveHexTarget(state, playerId, targetSpec, hexKey);\n};\n\nconst getHexPairTarget = (\n  state: GameState,\n  playerId: PlayerID,\n  targetSpec: TargetRecord,\n  targets: CardPlayTargets\n): { from: string; to: string } | null => {\n  const record = getTargetRecord(targets);\n  const explicitKeys = Array.isArray(record?.hexKeys) ? record?.hexKeys : null;\n  const rawKeys =\n    explicitKeys && explicitKeys.length > 0\n      ? explicitKeys\n      : typeof record?.from === \"string\" && typeof record?.to === \"string\"\n        ? [record.from, record.to]\n        : null;\n  if (!rawKeys || rawKeys.length !== 2) {\n    return null;\n  }\n  const [rawFrom, rawTo] = rawKeys;\n  if (typeof rawFrom !== \"string\" || typeof rawTo !== \"string\") {\n    return null;\n  }\n  if (rawFrom.length === 0 || rawTo.length === 0) {\n    return null;\n  }\n  const allowSame = targetSpec.allowSame === true;\n  if (!allowSame && rawFrom === rawTo) {\n    return null;\n  }\n  const fromTarget = resolveHexTarget(state, playerId, targetSpec, rawFrom);\n  if (!fromTarget) {\n    return null;\n  }\n  const toTarget = resolveHexTarget(state, playerId, targetSpec, rawTo);\n  if (!toTarget) {\n    return null;\n  }\n  return { from: fromTarget.hexKey, to: toTarget.hexKey };\n};\n\nconst addHexLinkModifier = (\n  state: GameState,\n  playerId: PlayerID,\n  cardId: string,\n  from: string,\n  to: string\n): GameState => {\n  if (from === to) {\n    return state;\n  }\n  const modifierId = `card.${cardId}.${playerId}.${state.revision}.${from}.${to}.link`;\n  return {\n    ...state,\n    modifiers: [\n      ...state.modifiers,\n      {\n        id: modifierId,\n        source: { type: \"card\", sourceId: cardId },\n        ownerPlayerId: playerId,\n        duration: { type: \"endOfRound\" },\n        data: { link: { from, to } },\n        hooks: {\n          getMoveAdjacency: ({ modifier, playerId: movingPlayerId, from, to }, current) => {\n            if (current) {\n              return true;\n            }\n            if (modifier.ownerPlayerId && modifier.ownerPlayerId !== movingPlayerId) {\n              return current;\n            }\n            const link = modifier.data?.link as { from?: string; to?: string } | undefined;\n            if (!link?.from || !link?.to) {\n              return current;\n            }\n            if (link.from === from && link.to === to) {\n              return true;\n            }\n            if (link.from === to && link.to === from) {\n              return true;\n            }\n            return current;\n          }\n        }\n      }\n    ]\n  };\n};\n\nconst getBuildBridgePlan = (\n  state: GameState,\n  playerId: PlayerID,\n  targetSpec: TargetRecord,\n  targets: CardPlayTargets\n): BuildBridgePlan | null => {\n  const edgeKey = getEdgeKeyTarget(targets);\n  if (!edgeKey) {\n    return null;\n  }\n\n  let rawA: string;\n  let rawB: string;\n  try {\n    [rawA, rawB] = parseEdgeKey(edgeKey);\n  } catch {\n    return null;\n  }\n\n  const fromHex = state.board.hexes[rawA];\n  const toHex = state.board.hexes[rawB];\n  if (!fromHex || !toHex) {\n    return null;\n  }\n\n  try {\n    if (!areAdjacent(parseHexKey(rawA), parseHexKey(rawB))) {\n      return null;\n    }\n  } catch {\n    return null;\n  }\n\n  const canonicalKey = getBridgeKey(rawA, rawB);\n  if (state.board.bridges[canonicalKey]) {\n    return null;\n  }\n\n  const allowAnywhere = targetSpec.anywhere === true;\n  const requiresOccupiedEndpoint = allowAnywhere ? false : targetSpec.requiresOccupiedEndpoint !== false;\n  if (\n    requiresOccupiedEndpoint &&\n    !isOccupiedByPlayer(fromHex, playerId) &&\n    !isOccupiedByPlayer(toHex, playerId)\n  ) {\n    return null;\n  }\n\n  return { from: rawA, to: rawB, key: canonicalKey };\n};\n\nconst getBuildBridgePlans = (\n  state: GameState,\n  playerId: PlayerID,\n  targetSpec: TargetRecord,\n  targets: CardPlayTargets\n): BuildBridgePlan[] | null => {\n  const edgeKeys = getEdgeKeyTargets(targets);\n  if (!edgeKeys || edgeKeys.length === 0) {\n    return null;\n  }\n  const plans: BuildBridgePlan[] = [];\n  const seen = new Set<string>();\n  for (const edgeKey of edgeKeys) {\n    const plan = getBuildBridgePlan(state, playerId, targetSpec, { edgeKey });\n    if (!plan || seen.has(plan.key)) {\n      return null;\n    }\n    seen.add(plan.key);\n    plans.push(plan);\n  }\n  return plans;\n};\n\nconst getExistingBridgePlan = (\n  state: GameState,\n  playerId: PlayerID,\n  targetSpec: TargetRecord,\n  targets: CardPlayTargets\n): BuildBridgePlan | null => {\n  const edgeKey = getEdgeKeyTarget(targets);\n  if (!edgeKey) {\n    return null;\n  }\n\n  let rawA: string;\n  let rawB: string;\n  try {\n    [rawA, rawB] = parseEdgeKey(edgeKey);\n  } catch {\n    return null;\n  }\n\n  const fromHex = state.board.hexes[rawA];\n  const toHex = state.board.hexes[rawB];\n  if (!fromHex || !toHex) {\n    return null;\n  }\n\n  try {\n    if (!areAdjacent(parseHexKey(rawA), parseHexKey(rawB))) {\n      return null;\n    }\n  } catch {\n    return null;\n  }\n\n  const canonicalKey = getBridgeKey(rawA, rawB);\n  if (!state.board.bridges[canonicalKey]) {\n    return null;\n  }\n\n  const allowAnywhere = targetSpec.anywhere === true;\n  const requiresOccupiedEndpoint = allowAnywhere ? false : targetSpec.requiresOccupiedEndpoint !== false;\n  if (\n    requiresOccupiedEndpoint &&\n    !isOccupiedByPlayer(fromHex, playerId) &&\n    !isOccupiedByPlayer(toHex, playerId)\n  ) {\n    return null;\n  }\n\n  return { from: rawA, to: rawB, key: canonicalKey };\n};\n\nconst getExistingBridgePlans = (\n  state: GameState,\n  playerId: PlayerID,\n  targetSpec: TargetRecord,\n  targets: CardPlayTargets\n): BuildBridgePlan[] | null => {\n  const edgeKeys = getEdgeKeyTargets(targets);\n  if (!edgeKeys || edgeKeys.length === 0) {\n    return null;\n  }\n  const plans: BuildBridgePlan[] = [];\n  const seen = new Set<string>();\n  for (const edgeKey of edgeKeys) {\n    const plan = getExistingBridgePlan(state, playerId, targetSpec, { edgeKey });\n    if (!plan || seen.has(plan.key)) {\n      return null;\n    }\n    seen.add(plan.key);\n    plans.push(plan);\n  }\n  return plans;\n};\n\nconst getBridgePivotPlans = (\n  state: GameState,\n  playerId: PlayerID,\n  targetSpec: TargetRecord,\n  targets: CardPlayTargets\n): { existing: BuildBridgePlan; build: BuildBridgePlan; sharedHex: string } | null => {\n  const edgeKeys = getEdgeKeyTargets(targets);\n  if (!edgeKeys || edgeKeys.length === 0) {\n    return null;\n  }\n  const minEdges =\n    typeof targetSpec.minEdges === \"number\" ? Math.max(0, Math.floor(targetSpec.minEdges)) : 2;\n  const maxEdges =\n    typeof targetSpec.maxEdges === \"number\"\n      ? Math.max(0, Math.floor(targetSpec.maxEdges))\n      : 2;\n  if (edgeKeys.length < minEdges || edgeKeys.length > maxEdges) {\n    return null;\n  }\n\n  let existing: BuildBridgePlan | null = null;\n  let build: BuildBridgePlan | null = null;\n\n  for (const edgeKey of edgeKeys) {\n    let rawA: string;\n    let rawB: string;\n    try {\n      [rawA, rawB] = parseEdgeKey(edgeKey);\n    } catch {\n      return null;\n    }\n    const canonicalKey = getBridgeKey(rawA, rawB);\n    if (state.board.bridges[canonicalKey]) {\n      const plan = getExistingBridgePlan(state, playerId, targetSpec, { edgeKey });\n      if (!plan || existing) {\n        return null;\n      }\n      existing = plan;\n    } else {\n      const plan = getBuildBridgePlan(state, playerId, targetSpec, { edgeKey });\n      if (!plan || build) {\n        return null;\n      }\n      build = plan;\n    }\n  }\n\n  if (!existing || !build) {\n    return null;\n  }\n\n  const sharedHex =\n    existing.from === build.from || existing.from === build.to\n      ? existing.from\n      : existing.to === build.from || existing.to === build.to\n        ? existing.to\n        : null;\n  if (!sharedHex) {\n    return null;\n  }\n\n  const allowAnywhere = targetSpec.anywhere === true;\n  if (!allowAnywhere) {\n    const shared = state.board.hexes[sharedHex];\n    if (!shared || !isOccupiedByPlayer(shared, playerId)) {\n      return null;\n    }\n  }\n\n  return { existing, build, sharedHex };\n};\n\nexport const validateMovePath = (\n  state: GameState,\n  playerId: PlayerID,\n  path: string[],\n  options: MoveValidation\n): string[] | null => {\n  if (path.length < 2) {\n    return null;\n  }\n\n  for (const hexKey of path) {\n    if (!state.board.hexes[hexKey]) {\n      return null;\n    }\n  }\n\n  const fromHex = state.board.hexes[path[0]];\n  if (!fromHex) {\n    return null;\n  }\n  const providedUnits =\n    Array.isArray(options.movingUnitIds) && options.movingUnitIds.length > 0\n      ? options.movingUnitIds\n      : null;\n  const movingUnitIds = providedUnits\n    ? providedUnits\n    : selectMovingUnits(\n        state.board,\n        playerId,\n        path[0],\n        options.forceCount,\n        options.includeChampions\n      );\n  if (providedUnits) {\n    const occupantSet = new Set(fromHex.occupants[playerId] ?? []);\n    if (!providedUnits.every((unitId) => occupantSet.has(unitId))) {\n      return null;\n    }\n  }\n  if (options.requireStartOccupied && movingUnitIds.length === 0) {\n    return null;\n  }\n  let maxDistance = options.maxDistance;\n  if (typeof maxDistance === \"number\") {\n    maxDistance = getMoveMaxDistance(\n      state,\n      {\n        playerId,\n        from: path[0],\n        to: path[path.length - 1],\n        path,\n        movingUnitIds\n      },\n      maxDistance\n    );\n    if (maxDistance <= 0 || path.length - 1 > maxDistance) {\n      return null;\n    }\n  }\n  const requiresBridge = getMoveRequiresBridge(\n    state,\n    {\n      playerId,\n      from: path[0],\n      to: path[path.length - 1],\n      path,\n      movingUnitIds\n    },\n    options.requiresBridge\n  );\n\n  for (let index = 0; index < path.length - 1; index += 1) {\n    const from = path[index];\n    const to = path[index + 1];\n    let baseAdjacent = false;\n    try {\n      baseAdjacent = areAdjacent(parseHexKey(from), parseHexKey(to));\n    } catch {\n      return null;\n    }\n    const isAdjacent = getMoveAdjacency(\n      state,\n      { playerId, from, to, path, movingUnitIds },\n      baseAdjacent\n    );\n    if (!isAdjacent) {\n      return null;\n    }\n    if (requiresBridge && baseAdjacent && !hasBridge(state.board, from, to)) {\n      return null;\n    }\n    if (index < path.length - 2) {\n      const hex = state.board.hexes[to];\n      if (hex && hasEnemyUnits(hex, playerId)) {\n        return null;\n      }\n      if (hex && options.stopOnOccupied && countPlayersOnHex(hex) > 0) {\n        return null;\n      }\n    }\n  }\n\n  const destination = state.board.hexes[path[path.length - 1]];\n  if (destination && wouldExceedTwoPlayers(destination, playerId)) {\n    return null;\n  }\n\n  return path;\n};\n\nconst moveUnits = (\n  state: GameState,\n  playerId: PlayerID,\n  unitIds: string[],\n  from: string,\n  to: string\n): GameState => {\n  if (unitIds.length === 0 || from === to) {\n    return state;\n  }\n\n  const fromHex = state.board.hexes[from];\n  const toHex = state.board.hexes[to];\n  if (!fromHex || !toHex) {\n    return state;\n  }\n\n  const movingSet = new Set(unitIds);\n  const fromUnits = fromHex.occupants[playerId] ?? [];\n  const movingUnits = fromUnits.filter((unitId) => movingSet.has(unitId));\n  if (movingUnits.length === 0) {\n    return state;\n  }\n\n  const remainingUnits = fromUnits.filter((unitId) => !movingSet.has(unitId));\n  const toUnits = [...(toHex.occupants[playerId] ?? []), ...movingUnits];\n\n  const units = { ...state.board.units };\n  for (const unitId of movingUnits) {\n    const unit = units[unitId];\n    if (!unit) {\n      continue;\n    }\n    units[unitId] = {\n      ...unit,\n      hex: to\n    };\n  }\n\n  return {\n    ...state,\n    board: {\n      ...state.board,\n      units,\n      hexes: {\n        ...state.board.hexes,\n        [from]: {\n          ...fromHex,\n          occupants: {\n            ...fromHex.occupants,\n            [playerId]: remainingUnits\n          }\n        },\n        [to]: {\n          ...toHex,\n          occupants: {\n            ...toHex.occupants,\n            [playerId]: toUnits\n          }\n        }\n      }\n    }\n  };\n};\n\nconst removeForcesFromHex = (\n  state: GameState,\n  playerId: PlayerID,\n  hexKey: string,\n  unitIds: string[],\n  count: number\n): GameState => {\n  if (!Number.isFinite(count) || count <= 0) {\n    return state;\n  }\n  const hex = state.board.hexes[hexKey];\n  if (!hex) {\n    return state;\n  }\n  const occupants = hex.occupants[playerId] ?? [];\n  if (occupants.length === 0) {\n    return state;\n  }\n\n  const occupantSet = new Set(occupants);\n  const eligible = unitIds.filter((unitId) => {\n    if (!occupantSet.has(unitId)) {\n      return false;\n    }\n    const unit = state.board.units[unitId];\n    return unit?.kind === \"force\" && unit.ownerPlayerId === playerId;\n  });\n  if (eligible.length === 0) {\n    return state;\n  }\n\n  const removeCount = Math.min(Math.floor(count), eligible.length);\n  const removeIds = new Set(eligible.slice(0, removeCount));\n  const nextUnits = { ...state.board.units };\n  for (const unitId of removeIds) {\n    delete nextUnits[unitId];\n  }\n  const nextOccupants = occupants.filter((unitId) => !removeIds.has(unitId));\n\n  return {\n    ...state,\n    board: {\n      ...state.board,\n      units: nextUnits,\n      hexes: {\n        ...state.board.hexes,\n        [hexKey]: {\n          ...hex,\n          occupants: {\n            ...hex.occupants,\n            [playerId]: nextOccupants\n          }\n        }\n      }\n    }\n  };\n};\n\nconst removeChampionFromBoard = (state: GameState, unitId: string): GameState => {\n  const unit = state.board.units[unitId];\n  if (!unit || unit.kind !== \"champion\") {\n    return state;\n  }\n\n  const hex = state.board.hexes[unit.hex];\n  const nextUnits = { ...state.board.units };\n  delete nextUnits[unitId];\n\n  let nextState: GameState = {\n    ...state,\n    board: {\n      ...state.board,\n      units: nextUnits\n    }\n  };\n\n  if (hex) {\n    const occupants = (hex.occupants[unit.ownerPlayerId] ?? []).filter(\n      (entry) => entry !== unitId\n    );\n    nextState = {\n      ...nextState,\n      board: {\n        ...nextState.board,\n        hexes: {\n          ...nextState.board.hexes,\n          [unit.hex]: {\n            ...hex,\n            occupants: {\n              ...hex.occupants,\n              [unit.ownerPlayerId]: occupants\n            }\n          }\n        }\n      }\n    };\n  }\n\n  nextState = removeChampionModifiers(nextState, [unitId]);\n  const nextModifiers = nextState.modifiers.filter(\n    (modifier) => modifier.attachedUnitId !== unitId\n  );\n  return nextModifiers.length === nextState.modifiers.length\n    ? nextState\n    : { ...nextState, modifiers: nextModifiers };\n};\n\nconst moveUnitsAlongPath = (\n  state: GameState,\n  playerId: PlayerID,\n  path: string[],\n  forceCount?: number,\n  includeChampions?: boolean\n): GameState => {\n  const movingUnitIds = selectMovingUnits(\n    state.board,\n    playerId,\n    path[0],\n    forceCount,\n    includeChampions\n  );\n  if (movingUnitIds.length === 0) {\n    return state;\n  }\n\n  let nextState = state;\n  for (let index = 0; index < path.length - 1; index += 1) {\n    const from = path[index];\n    const to = path[index + 1];\n    nextState = moveUnits(nextState, playerId, movingUnitIds, from, to);\n    nextState = runMoveEvents(nextState, { playerId, from, to, path, movingUnitIds });\n  }\n\n  return nextState;\n};\n\nconst moveUnitIdsAlongPath = (\n  state: GameState,\n  playerId: PlayerID,\n  path: string[],\n  movingUnitIds: string[]\n): GameState => {\n  if (movingUnitIds.length === 0) {\n    return state;\n  }\n\n  let nextState = state;\n  for (let index = 0; index < path.length - 1; index += 1) {\n    const from = path[index];\n    const to = path[index + 1];\n    nextState = moveUnits(nextState, playerId, movingUnitIds, from, to);\n    nextState = runMoveEvents(nextState, { playerId, from, to, path, movingUnitIds });\n  }\n\n  return nextState;\n};\n\nexport const isCardPlayable = (\n  state: GameState,\n  playerId: PlayerID,\n  card: CardDef,\n  targets?: CardPlayTargets\n): boolean => {\n  if (!SUPPORTED_TARGET_KINDS.has(card.targetSpec.kind)) {\n    return false;\n  }\n\n  const hasEffects = Array.isArray(card.effects) && card.effects.length > 0;\n  const isChampionCard = card.type === \"Champion\";\n  if (!isChampionCard && !hasEffects) {\n    return false;\n  }\n  if (hasEffects && !card.effects?.every((effect) => SUPPORTED_EFFECTS.has(effect.kind))) {\n    return false;\n  }\n  if (isChampionCard) {\n    if (!card.champion) {\n      return false;\n    }\n    if (countPlayerChampions(state.board, playerId) >= state.config.CHAMPION_LIMIT) {\n      return false;\n    }\n  }\n\n  if (card.targetSpec.kind === \"none\") {\n    const getHandEffectCount = (kind: string, defaultCount: number) => {\n      const effect = card.effects?.find((entry) => entry.kind === kind) as\n        | TargetRecord\n        | undefined;\n      if (!effect) {\n        return 0;\n      }\n      const rawCount = typeof effect.count === \"number\" ? effect.count : defaultCount;\n      return Math.max(0, Math.floor(rawCount));\n    };\n\n    const discardCount = getHandEffectCount(\"discardFromHand\", 1);\n    const burnCount = getHandEffectCount(\"burnFromHand\", 1);\n    const topdeckCount = getHandEffectCount(\"topdeckFromHand\", 1);\n\n    if (targets == null) {\n      if (discardCount > 0 || burnCount > 0) {\n        return false;\n      }\n      return true;\n    }\n\n    if (discardCount === 0 && burnCount === 0 && topdeckCount === 0) {\n      return false;\n    }\n\n    const player = state.players.find((entry) => entry.id === playerId);\n    if (!player) {\n      return false;\n    }\n\n    const targetIds = getCardInstanceTargets(targets);\n    if (targetIds.length === 0) {\n      return false;\n    }\n    const uniqueIds = new Set(targetIds);\n    if (uniqueIds.size !== targetIds.length) {\n      return false;\n    }\n    if (!targetIds.every((id) => player.deck.hand.includes(id))) {\n      return false;\n    }\n\n    const requiredCount = Math.max(discardCount, burnCount);\n    if (requiredCount > 0) {\n      return targetIds.length === requiredCount;\n    }\n    return targetIds.length <= topdeckCount;\n  }\n\n  if (card.targetSpec.kind === \"hex\") {\n    const target = getHexTarget(\n      state,\n      playerId,\n      card.targetSpec as TargetRecord,\n      targets ?? null\n    );\n    if (!target) {\n      return false;\n    }\n    const mortarEffect = card.effects?.find(\n      (effect) => effect.kind === \"mortarShot\"\n    ) as TargetRecord | undefined;\n    if (mortarEffect) {\n      const maxDistance =\n        typeof mortarEffect.maxDistance === \"number\" ? mortarEffect.maxDistance : 2;\n      if (!hasFriendlyForceWithinRange(state, playerId, target.hexKey, maxDistance)) {\n        return false;\n      }\n    }\n    if (card.effects?.some((effect) => effect.kind === \"deployForces\")) {\n      return !wouldExceedTwoPlayers(target.hex, playerId);\n    }\n    return true;\n  }\n\n  if (card.targetSpec.kind === \"hexPair\") {\n    return Boolean(\n      getHexPairTarget(state, playerId, card.targetSpec as TargetRecord, targets ?? null)\n    );\n  }\n\n  if (card.targetSpec.kind === \"edge\") {\n    const hasBuildBridge = card.effects?.some((effect) => effect.kind === \"buildBridge\") ?? false;\n    const hasExistingBridgeEffect =\n      card.effects?.some(\n        (effect) =>\n          effect.kind === \"lockBridge\" ||\n          effect.kind === \"trapBridge\" ||\n          effect.kind === \"destroyBridge\"\n      ) ?? false;\n    const plan = hasBuildBridge\n      ? getBuildBridgePlan(state, playerId, card.targetSpec as TargetRecord, targets ?? null)\n      : hasExistingBridgeEffect\n        ? getExistingBridgePlan(state, playerId, card.targetSpec as TargetRecord, targets ?? null)\n        : getBuildBridgePlan(state, playerId, card.targetSpec as TargetRecord, targets ?? null);\n    if (!plan) {\n      return false;\n    }\n\n    if (!hasBuildBridge) {\n      return true;\n    }\n\n    const movePath = getMovePathTarget(targets ?? null);\n    if (!movePath) {\n      return true;\n    }\n\n    const moveEffect = card.effects?.find(\n      (effect) => effect.kind === \"moveStack\"\n    ) as TargetRecord | undefined;\n    if (!moveEffect) {\n      return true;\n    }\n\n    const maxDistance =\n      typeof moveEffect.maxDistance === \"number\"\n        ? moveEffect.maxDistance\n        : typeof card.targetSpec.maxDistance === \"number\"\n          ? card.targetSpec.maxDistance\n          : undefined;\n    const requiresBridge =\n      moveEffect.requiresBridge === false ? false : card.targetSpec.requiresBridge !== false;\n    const forceCount = getMoveStackForceCount(card, moveEffect, targets ?? null);\n    const stopOnOccupied =\n      moveEffect.stopOnOccupied === true ||\n      (card.targetSpec as TargetRecord | undefined)?.stopOnOccupied === true;\n\n    let moveState = state;\n    if (card.effects?.some((effect) => effect.kind === \"buildBridge\")) {\n      moveState = {\n        ...state,\n        board: {\n          ...state.board,\n          bridges: {\n            ...state.board.bridges,\n            [plan.key]: {\n              key: plan.key,\n              from: plan.from,\n              to: plan.to\n            }\n          }\n        }\n      };\n    }\n\n    return Boolean(\n      validateMovePath(moveState, playerId, movePath, {\n        maxDistance,\n        requiresBridge,\n        requireStartOccupied: true,\n        forceCount,\n        stopOnOccupied\n      })\n    );\n  }\n\n  if (card.targetSpec.kind === \"multiEdge\") {\n    const targetSpec = card.targetSpec as TargetRecord;\n    const edgeKeys = getEdgeKeyTargets(targets ?? null);\n    if (!edgeKeys || edgeKeys.length === 0) {\n      return false;\n    }\n    const minEdges =\n      typeof targetSpec.minEdges === \"number\" ? Math.max(0, Math.floor(targetSpec.minEdges)) : 1;\n    const maxEdges =\n      typeof targetSpec.maxEdges === \"number\"\n        ? Math.max(0, Math.floor(targetSpec.maxEdges))\n        : Number.POSITIVE_INFINITY;\n    if (edgeKeys.length < minEdges || edgeKeys.length > maxEdges) {\n      return false;\n    }\n    const hasBridgePivot =\n      card.effects?.some((effect) => effect.kind === \"bridgePivot\") ?? false;\n    if (hasBridgePivot) {\n      return Boolean(getBridgePivotPlans(state, playerId, targetSpec, targets ?? null));\n    }\n    const hasBuildBridge = card.effects?.some((effect) => effect.kind === \"buildBridge\") ?? false;\n    const hasExistingBridgeEffect =\n      card.effects?.some(\n        (effect) =>\n          effect.kind === \"lockBridge\" ||\n          effect.kind === \"trapBridge\" ||\n          effect.kind === \"destroyBridge\"\n      ) ?? false;\n    const planResolver = hasBuildBridge\n      ? getBuildBridgePlan\n      : hasExistingBridgeEffect\n        ? getExistingBridgePlan\n        : getBuildBridgePlan;\n    const seen = new Set<string>();\n    for (const edgeKey of edgeKeys) {\n      const plan = planResolver(state, playerId, targetSpec, { edgeKey });\n      if (!plan || seen.has(plan.key)) {\n        return false;\n      }\n      seen.add(plan.key);\n    }\n    return true;\n  }\n\n  if (card.targetSpec.kind === \"multiPath\") {\n    const targetSpec = card.targetSpec as TargetRecord;\n    const owner = typeof targetSpec.owner === \"string\" ? targetSpec.owner : \"self\";\n    if (owner !== \"self\") {\n      return false;\n    }\n    const paths = getMultiPathTargets(targets ?? null);\n    if (!paths || paths.length === 0) {\n      return false;\n    }\n    const minPaths =\n      typeof targetSpec.minPaths === \"number\" ? Math.max(0, Math.floor(targetSpec.minPaths)) : 1;\n    const maxPaths =\n      typeof targetSpec.maxPaths === \"number\"\n        ? Math.max(0, Math.floor(targetSpec.maxPaths))\n        : Number.POSITIVE_INFINITY;\n    if (paths.length < minPaths || paths.length > maxPaths) {\n      return false;\n    }\n    const moveEffect = card.effects?.find(\n      (effect) => effect.kind === \"moveStacks\"\n    ) as TargetRecord | undefined;\n    const maxDistance =\n      typeof moveEffect?.maxDistance === \"number\"\n        ? moveEffect.maxDistance\n        : typeof targetSpec.maxDistance === \"number\"\n          ? targetSpec.maxDistance\n          : undefined;\n    const requiresBridge =\n      moveEffect?.requiresBridge === false ? false : targetSpec.requiresBridge !== false;\n    const stopOnOccupied =\n      moveEffect?.stopOnOccupied === true || targetSpec.stopOnOccupied === true;\n    const seenStarts = new Set<string>();\n    let moveState = state;\n    for (const path of paths) {\n      const start = path[0];\n      if (seenStarts.has(start)) {\n        return false;\n      }\n      seenStarts.add(start);\n      if (\n        !validateMovePath(moveState, playerId, path, {\n          maxDistance,\n          requiresBridge,\n          requireStartOccupied: true,\n          stopOnOccupied\n        })\n      ) {\n        return false;\n      }\n      moveState = markPlayerMovedThisRound(moveState, playerId);\n    }\n    return true;\n  }\n\n  if (card.targetSpec.kind === \"stack\" || card.targetSpec.kind === \"path\") {\n    const owner = typeof card.targetSpec.owner === \"string\" ? card.targetSpec.owner : \"self\";\n    if (owner !== \"self\") {\n      return false;\n    }\n    const movePath = getMovePathTarget(targets ?? null);\n    if (!movePath) {\n      return false;\n    }\n    const maxDistance =\n      typeof card.targetSpec.maxDistance === \"number\" ? card.targetSpec.maxDistance : undefined;\n    const requiresBridge = card.targetSpec.requiresBridge !== false;\n    const moveEffect = card.effects?.find(\n      (effect) => effect.kind === \"moveStack\"\n    ) as TargetRecord | undefined;\n    const forceCount = getMoveStackForceCount(card, moveEffect, targets ?? null);\n    const stopOnOccupied =\n      moveEffect?.stopOnOccupied === true || card.targetSpec.stopOnOccupied === true;\n    return Boolean(\n      validateMovePath(state, playerId, movePath, {\n        maxDistance,\n        requiresBridge,\n        requireStartOccupied: true,\n        forceCount,\n        stopOnOccupied\n      })\n    );\n  }\n\n  if (card.targetSpec.kind === \"champion\") {\n    const target = getChampionTarget(\n      state,\n      playerId,\n      card.targetSpec as TargetRecord,\n      targets ?? null,\n      card\n    );\n    if (!target) {\n      return false;\n    }\n    const needsCapital = card.effects?.some(\n      (effect) => effect.kind === \"evacuateChampion\"\n    );\n    if (!needsCapital) {\n      return true;\n    }\n    const player = state.players.find((entry) => entry.id === playerId);\n    if (!player?.capitalHex) {\n      return false;\n    }\n    const capitalHex = state.board.hexes[player.capitalHex];\n    if (!capitalHex) {\n      return false;\n    }\n    return !wouldExceedTwoPlayers(capitalHex, playerId);\n  }\n\n  if (card.targetSpec.kind === \"choice\") {\n    const choice = getChoiceTarget(targets ?? null);\n    if (!choice) {\n      return false;\n    }\n    const options = Array.isArray(card.targetSpec.options)\n      ? (card.targetSpec.options as TargetRecord[])\n      : [];\n    const matchingOptions = options.filter((option) => option.kind === choice.kind);\n    if (matchingOptions.length === 0) {\n      return false;\n    }\n\n    if (choice.kind === \"capital\") {\n      return Boolean(resolveCapitalDeployHex(state, playerId, choice.hexKey ?? null));\n    }\n\n    if (choice.kind === \"occupiedHex\") {\n      const hex = state.board.hexes[choice.hexKey];\n      if (!hex) {\n        return false;\n      }\n      if (!isOccupiedByPlayer(hex, playerId)) {\n        return false;\n      }\n      const tileAllowed = matchingOptions.some((option) => {\n        const tile = typeof option.tile === \"string\" ? option.tile : null;\n        return !tile || tile === hex.tile;\n      });\n      if (!tileAllowed) {\n        return false;\n      }\n      return !wouldExceedTwoPlayers(hex, playerId);\n    }\n  }\n\n  return false;\n};\n\nconst addGold = (state: GameState, playerId: PlayerID, amount: number): GameState => {\n  if (!Number.isFinite(amount) || amount <= 0) {\n    return state;\n  }\n\n  return {\n    ...state,\n    players: state.players.map((player) =>\n      player.id === playerId\n        ? {\n            ...player,\n            resources: {\n              ...player.resources,\n              gold: player.resources.gold + amount\n            }\n          }\n        : player\n    )\n  };\n};\n\nconst addMana = (state: GameState, playerId: PlayerID, amount: number): GameState => {\n  if (!Number.isFinite(amount) || amount <= 0) {\n    return state;\n  }\n\n  return {\n    ...state,\n    players: state.players.map((player) =>\n      player.id === playerId\n        ? {\n            ...player,\n            resources: {\n              ...player.resources,\n              mana: player.resources.mana + amount\n            }\n          }\n        : player\n    )\n  };\n};\n\nconst playerOccupiesTile = (\n  state: GameState,\n  playerId: PlayerID,\n  tileType: TileType\n): boolean => {\n  return Object.values(state.board.hexes).some(\n    (hex) => hex.tile === tileType && (hex.occupants[playerId]?.length ?? 0) > 0\n  );\n};\n\nconst playerOccupiesEnemyCapital = (state: GameState, playerId: PlayerID): boolean => {\n  return Object.values(state.board.hexes).some((hex) => {\n    if (hex.tile !== \"capital\") {\n      return false;\n    }\n    if (!hex.ownerPlayerId || hex.ownerPlayerId === playerId) {\n      return false;\n    }\n    return (hex.occupants[playerId]?.length ?? 0) > 0;\n  });\n};\n\nexport const resolveCardEffects = (\n  state: GameState,\n  playerId: PlayerID,\n  card: CardDef,\n  targets?: CardPlayTargets\n): GameState => {\n  let nextState = state;\n\n  if (card.type === \"Champion\" && card.champion) {\n    const target = getHexTarget(\n      nextState,\n      playerId,\n      card.targetSpec as TargetRecord,\n      targets ?? null\n    );\n    if (target) {\n      const deployed = addChampionToHex(nextState.board, playerId, target.hexKey, {\n        cardDefId: card.id,\n        hp: card.champion.hp,\n        attackDice: card.champion.attackDice,\n        hitFaces: card.champion.hitFaces,\n        bounty: card.champion.bounty\n      });\n      nextState = {\n        ...nextState,\n        board: deployed.board\n      };\n      nextState = applyChampionDeployment(nextState, deployed.unitId, card.id, playerId);\n    }\n  }\n\n  for (const effect of card.effects ?? []) {\n    switch (effect.kind) {\n      case \"gainGold\": {\n        const amount = typeof effect.amount === \"number\" ? effect.amount : 0;\n        nextState = addGold(nextState, playerId, amount);\n        break;\n      }\n      case \"gainGoldIfEnemyCapital\": {\n        const amount = typeof effect.amount === \"number\" ? effect.amount : 0;\n        if (amount <= 0) {\n          break;\n        }\n        if (!playerOccupiesEnemyCapital(nextState, playerId)) {\n          break;\n        }\n        nextState = addGold(nextState, playerId, amount);\n        break;\n      }\n      case \"gainMana\": {\n        const amount = typeof effect.amount === \"number\" ? effect.amount : 0;\n        nextState = addMana(nextState, playerId, amount);\n        break;\n      }\n      case \"gainManaIfTile\": {\n        const tile = typeof effect.tile === \"string\" ? effect.tile : null;\n        const amount = typeof effect.amount === \"number\" ? effect.amount : 0;\n        if (!tile || amount <= 0) {\n          break;\n        }\n        if (playerOccupiesTile(nextState, playerId, tile as TileType)) {\n          nextState = addMana(nextState, playerId, amount);\n        }\n        break;\n      }\n      case \"drawCards\": {\n        const count = typeof effect.count === \"number\" ? effect.count : 0;\n        nextState = drawCards(nextState, playerId, count);\n        break;\n      }\n      case \"discardFromHand\": {\n        const count = typeof effect.count === \"number\" ? effect.count : 1;\n        if (count <= 0) {\n          break;\n        }\n        const targetIds = getCardInstanceTargets(targets ?? null);\n        if (targetIds.length === 0) {\n          break;\n        }\n        const player = nextState.players.find((entry) => entry.id === playerId);\n        if (!player) {\n          break;\n        }\n        const uniqueTargets = [...new Set(targetIds)];\n        const validTargets = uniqueTargets.filter((id) => player.deck.hand.includes(id));\n        if (validTargets.length < count) {\n          break;\n        }\n        for (const cardInstanceId of validTargets.slice(0, count)) {\n          nextState = discardCardFromHand(nextState, playerId, cardInstanceId, {\n            countAsDiscard: true\n          });\n        }\n        break;\n      }\n      case \"burnFromHand\": {\n        const count = typeof effect.count === \"number\" ? effect.count : 1;\n        if (count <= 0) {\n          break;\n        }\n        const targetIds = getCardInstanceTargets(targets ?? null);\n        if (targetIds.length === 0) {\n          break;\n        }\n        const player = nextState.players.find((entry) => entry.id === playerId);\n        if (!player) {\n          break;\n        }\n        const uniqueTargets = [...new Set(targetIds)];\n        const validTargets = uniqueTargets.filter((id) => player.deck.hand.includes(id));\n        if (validTargets.length < count) {\n          break;\n        }\n        for (const cardInstanceId of validTargets.slice(0, count)) {\n          const removed = removeCardFromHand(nextState, playerId, cardInstanceId);\n          nextState = addCardToBurned(removed, playerId, cardInstanceId);\n        }\n        break;\n      }\n      case \"drawCardsOtherPlayers\": {\n        const count = typeof effect.count === \"number\" ? effect.count : 0;\n        if (count <= 0) {\n          break;\n        }\n        for (const player of nextState.players) {\n          if (player.id === playerId) {\n            continue;\n          }\n          nextState = drawCards(nextState, player.id, count);\n        }\n        break;\n      }\n      case \"rollGold\": {\n        const sides = Number.isFinite(effect.sides) ? Math.max(1, Math.floor(effect.sides)) : 6;\n        const highMin =\n          Number.isFinite(effect.highMin) && Number(effect.highMin) >= 1\n            ? Math.floor(effect.highMin)\n            : 5;\n        const lowGain = typeof effect.lowGain === \"number\" ? effect.lowGain : 0;\n        const highGain = typeof effect.highGain === \"number\" ? effect.highGain : 0;\n        if (sides <= 0 || (lowGain <= 0 && highGain <= 0)) {\n          break;\n        }\n        const threshold = Math.min(highMin, sides);\n        const roll = randInt(nextState.rngState, 1, sides);\n        nextState = { ...nextState, rngState: roll.next };\n        const amount = roll.value >= threshold ? highGain : lowGain;\n        if (amount > 0) {\n          nextState = addGold(nextState, playerId, amount);\n        }\n        break;\n      }\n      case \"drawCardsIfTile\": {\n        const tile = typeof effect.tile === \"string\" ? effect.tile : null;\n        const count = typeof effect.count === \"number\" ? Math.max(0, Math.floor(effect.count)) : 0;\n        if (!tile || count <= 0) {\n          break;\n        }\n        if (playerOccupiesTile(nextState, playerId, tile as TileType)) {\n          nextState = drawCards(nextState, playerId, count);\n        }\n        break;\n      }\n      case \"drawCardsIfHandEmpty\": {\n        const count = typeof effect.count === \"number\" ? effect.count : 0;\n        if (count <= 0) {\n          break;\n        }\n        const player = nextState.players.find((entry) => entry.id === playerId);\n        if (!player) {\n          break;\n        }\n        if (player.deck.hand.length > 0) {\n          break;\n        }\n        nextState = drawCards(nextState, playerId, count);\n        break;\n      }\n      case \"topdeckFromHand\": {\n        const count = typeof effect.count === \"number\" ? Math.max(0, Math.floor(effect.count)) : 1;\n        if (count <= 0) {\n          break;\n        }\n        const targetIds = getCardInstanceTargets(targets ?? null);\n        if (targetIds.length === 0) {\n          break;\n        }\n        const player = nextState.players.find((entry) => entry.id === playerId);\n        if (!player) {\n          break;\n        }\n        const validTargets = targetIds.filter((id) => player.deck.hand.includes(id));\n        if (validTargets.length === 0) {\n          break;\n        }\n        for (const cardInstanceId of validTargets.slice(0, count)) {\n          nextState = topdeckCardFromHand(nextState, playerId, cardInstanceId);\n        }\n        break;\n      }\n      case \"scoutReport\": {\n        const lookCount = Math.max(0, Number(effect.lookCount) || 0);\n        const keepCount = Math.max(0, Number(effect.keepCount) || 0);\n        if (lookCount <= 0) {\n          break;\n        }\n        const taken = takeTopCards(nextState, playerId, lookCount);\n        nextState = taken.state;\n        const maxKeep = Math.min(keepCount, taken.cards.length);\n        if (maxKeep <= 0) {\n          for (const cardId of taken.cards) {\n            nextState = addCardToDiscardPile(nextState, playerId, cardId, {\n              countAsDiscard: true\n            });\n          }\n          break;\n        }\n        if (maxKeep >= taken.cards.length || nextState.blocks) {\n          const keep = taken.cards.slice(0, maxKeep);\n          const discard = taken.cards.filter((cardId) => !keep.includes(cardId));\n          for (const cardId of keep) {\n            nextState = addCardToHandWithOverflow(nextState, playerId, cardId);\n          }\n          for (const cardId of discard) {\n            nextState = addCardToDiscardPile(nextState, playerId, cardId, {\n              countAsDiscard: true\n            });\n          }\n          break;\n        }\n        nextState = {\n          ...nextState,\n          blocks: {\n            type: \"action.scoutReport\",\n            waitingFor: [playerId],\n            payload: {\n              playerId,\n              offers: taken.cards,\n              keepCount: maxKeep,\n              chosen: null\n            }\n          }\n        };\n        break;\n      }\n      case \"prospecting\": {\n        const baseGold = typeof effect.baseGold === \"number\" ? effect.baseGold : 0;\n        const bonusIfMine = typeof effect.bonusIfMine === \"number\" ? effect.bonusIfMine : 0;\n        const amount =\n          baseGold +\n          (bonusIfMine > 0 && playerOccupiesTile(nextState, playerId, \"mine\")\n            ? bonusIfMine\n            : 0);\n        nextState = addGold(nextState, playerId, amount);\n        break;\n      }\n      case \"recruit\": {\n        const choice = getChoiceTarget(targets ?? null);\n        if (!choice) {\n          break;\n        }\n        const options = Array.isArray(card.targetSpec.options)\n          ? (card.targetSpec.options as TargetRecord[])\n          : [];\n        const capitalCountRaw =\n          typeof effect.capitalCount === \"number\" ? effect.capitalCount : 2;\n        const occupiedCountRaw =\n          typeof effect.occupiedCount === \"number\" ? effect.occupiedCount : 1;\n        const capitalCount = Math.max(0, Math.floor(capitalCountRaw));\n        const occupiedCount = Math.max(0, Math.floor(occupiedCountRaw));\n        if (choice.kind === \"capital\") {\n          if (!options.some((option) => option.kind === \"capital\")) {\n            break;\n          }\n          const deployHex = resolveCapitalDeployHex(nextState, playerId, choice.hexKey ?? null);\n          if (!deployHex) {\n            break;\n          }\n          const baseCount = capitalCount;\n          const count = getDeployForcesCount(\n            nextState,\n            { playerId, hexKey: deployHex, baseCount },\n            baseCount\n          );\n          nextState = {\n            ...nextState,\n            board: addForcesToHex(nextState.board, playerId, deployHex, count)\n          };\n          break;\n        }\n        if (choice.kind === \"occupiedHex\") {\n          const hex = nextState.board.hexes[choice.hexKey];\n          if (!hex) {\n            break;\n          }\n          if (!isOccupiedByPlayer(hex, playerId)) {\n            break;\n          }\n          const tileAllowed = options.some((option) => {\n            if (option.kind !== \"occupiedHex\") {\n              return false;\n            }\n            const tile = typeof option.tile === \"string\" ? option.tile : null;\n            return !tile || tile === hex.tile;\n          });\n          if (!tileAllowed) {\n            break;\n          }\n          if (wouldExceedTwoPlayers(hex, playerId)) {\n            break;\n          }\n          const baseCount = occupiedCount;\n          const count = getDeployForcesCount(\n            nextState,\n            { playerId, hexKey: choice.hexKey, baseCount },\n            baseCount\n          );\n          nextState = {\n            ...nextState,\n            board: addForcesToHex(nextState.board, playerId, choice.hexKey, count)\n          };\n        }\n        break;\n      }\n      case \"recruitByHandSize\": {\n        const choice = getChoiceTarget(targets ?? null);\n        if (!choice || choice.kind !== \"capital\") {\n          break;\n        }\n        const options = Array.isArray(card.targetSpec.options)\n          ? (card.targetSpec.options as TargetRecord[])\n          : [];\n        if (!options.some((option) => option.kind === \"capital\")) {\n          break;\n        }\n        const deployHex = resolveCapitalDeployHex(nextState, playerId, choice.hexKey ?? null);\n        if (!deployHex) {\n          break;\n        }\n        const player = nextState.players.find((entry) => entry.id === playerId);\n        if (!player) {\n          break;\n        }\n        const baseCount = Math.max(0, Math.floor(player.deck.hand.length));\n        const count = getDeployForcesCount(\n          nextState,\n          { playerId, hexKey: deployHex, baseCount },\n          baseCount\n        );\n        if (count <= 0) {\n          break;\n        }\n        nextState = {\n          ...nextState,\n          board: addForcesToHex(nextState.board, playerId, deployHex, count)\n        };\n        break;\n      }\n      case \"deployForces\": {\n        let targetHexKey: string | null = null;\n        if (card.targetSpec.kind === \"champion\") {\n          const target = getChampionTarget(\n            nextState,\n            playerId,\n            card.targetSpec as TargetRecord,\n            targets ?? null,\n            card\n          );\n          if (!target) {\n            break;\n          }\n          targetHexKey = target.unit.hex;\n        } else {\n          const target = getHexTarget(\n            nextState,\n            playerId,\n            card.targetSpec as TargetRecord,\n            targets ?? null\n          );\n          if (!target) {\n            break;\n          }\n          targetHexKey = target.hexKey;\n        }\n        if (!targetHexKey) {\n          break;\n        }\n        const targetHex = nextState.board.hexes[targetHexKey];\n        if (!targetHex) {\n          break;\n        }\n        if (wouldExceedTwoPlayers(targetHex, playerId)) {\n          break;\n        }\n        const baseCount = typeof effect.count === \"number\" ? effect.count : 0;\n        if (baseCount <= 0) {\n          break;\n        }\n        const count = getDeployForcesCount(\n          nextState,\n          { playerId, hexKey: targetHexKey, baseCount },\n          baseCount\n        );\n        if (count <= 0) {\n          break;\n        }\n        nextState = {\n          ...nextState,\n          board: addForcesToHex(nextState.board, playerId, targetHexKey, count)\n        };\n        break;\n      }\n      case \"deployForcesOnMines\": {\n        const count = typeof effect.count === \"number\" ? Math.max(0, Math.floor(effect.count)) : 0;\n        if (count <= 0) {\n          break;\n        }\n        for (const hex of Object.values(nextState.board.hexes)) {\n          if (hex.tile !== \"mine\") {\n            continue;\n          }\n          if (!isOccupiedByPlayer(hex, playerId)) {\n            continue;\n          }\n          nextState = {\n            ...nextState,\n            board: addForcesToHex(nextState.board, playerId, hex.key, count)\n          };\n        }\n        break;\n      }\n      case \"evacuateChampion\": {\n        const target = getChampionTarget(\n          nextState,\n          playerId,\n          card.targetSpec as TargetRecord,\n          targets ?? null,\n          card\n        );\n        if (!target) {\n          break;\n        }\n        const player = nextState.players.find((entry) => entry.id === playerId);\n        if (!player?.capitalHex) {\n          break;\n        }\n        const capitalHex = nextState.board.hexes[player.capitalHex];\n        if (!capitalHex) {\n          break;\n        }\n        if (wouldExceedTwoPlayers(capitalHex, playerId)) {\n          break;\n        }\n        nextState = {\n          ...nextState,\n          board: moveUnitToHex(nextState.board, target.unitId, player.capitalHex)\n        };\n        break;\n      }\n      case \"recallChampion\": {\n        const target = getChampionTarget(\n          nextState,\n          playerId,\n          card.targetSpec as TargetRecord,\n          targets ?? null,\n          card\n        );\n        if (!target) {\n          break;\n        }\n        const cardDefId = target.unit.cardDefId;\n        nextState = removeChampionFromBoard(nextState, target.unitId);\n        const player = nextState.players.find((entry) => entry.id === playerId);\n        if (!player) {\n          break;\n        }\n        let recalledInstanceId: string | null = null;\n        for (const instanceId of player.burned) {\n          const defId = nextState.cardsByInstanceId[instanceId]?.defId;\n          if (defId === cardDefId) {\n            recalledInstanceId = instanceId;\n            break;\n          }\n        }\n        if (recalledInstanceId) {\n          nextState = {\n            ...nextState,\n            players: nextState.players.map((entry) =>\n              entry.id === playerId\n                ? {\n                    ...entry,\n                    burned: entry.burned.filter((id) => id !== recalledInstanceId)\n                  }\n                : entry\n            )\n          };\n        } else {\n          const created = createCardInstance(nextState, cardDefId);\n          nextState = created.state;\n          recalledInstanceId = created.instanceId;\n        }\n        if (recalledInstanceId) {\n          nextState = addCardToHandWithOverflow(nextState, playerId, recalledInstanceId);\n        }\n        break;\n      }\n      case \"increaseMineValue\": {\n        const target = getHexTarget(\n          nextState,\n          playerId,\n          card.targetSpec as TargetRecord,\n          targets ?? null\n        );\n        if (!target) {\n          break;\n        }\n        const current = target.hex.mineValue;\n        if (typeof current !== \"number\") {\n          break;\n        }\n        const amount = typeof effect.amount === \"number\" ? effect.amount : NaN;\n        if (!Number.isFinite(amount) || amount <= 0) {\n          break;\n        }\n        const maxValue =\n          typeof effect.maxValue === \"number\" ? effect.maxValue : Number.POSITIVE_INFINITY;\n        const nextValue = Math.min(current + amount, maxValue);\n        if (nextValue === current) {\n          break;\n        }\n        nextState = {\n          ...nextState,\n          board: {\n            ...nextState.board,\n            hexes: {\n              ...nextState.board.hexes,\n              [target.hexKey]: {\n                ...target.hex,\n                mineValue: nextValue\n              }\n            }\n          }\n        };\n        break;\n      }\n      case \"healChampion\": {\n        const target = getChampionTarget(\n          nextState,\n          playerId,\n          card.targetSpec as TargetRecord,\n          targets ?? null,\n          card\n        );\n        if (!target) {\n          break;\n        }\n        const amount = typeof effect.amount === \"number\" ? effect.amount : 0;\n        nextState = healChampion(nextState, target.unitId, amount);\n        break;\n      }\n      case \"healChampions\": {\n        const amount = typeof effect.amount === \"number\" ? effect.amount : 0;\n        if (amount <= 0) {\n          break;\n        }\n        const unitIds = Object.keys(nextState.board.units);\n        for (const unitId of unitIds) {\n          const unit = nextState.board.units[unitId];\n          if (!unit || unit.kind !== \"champion\") {\n            continue;\n          }\n          if (unit.ownerPlayerId !== playerId) {\n            continue;\n          }\n          nextState = healChampion(nextState, unitId, amount);\n        }\n        break;\n      }\n      case \"dealChampionDamage\": {\n        const target = getChampionTarget(\n          nextState,\n          playerId,\n          card.targetSpec as TargetRecord,\n          targets ?? null,\n          card\n        );\n        if (!target) {\n          break;\n        }\n        const amount = typeof effect.amount === \"number\" ? effect.amount : 0;\n        nextState = dealChampionDamage(nextState, playerId, target.unitId, amount);\n        break;\n      }\n      case \"encirclement\": {\n        const target = getHexTarget(\n          nextState,\n          playerId,\n          card.targetSpec as TargetRecord,\n          targets ?? null\n        );\n        if (!target) {\n          break;\n        }\n        const minAdjacent =\n          typeof effect.minAdjacent === \"number\" ? Math.max(0, Math.floor(effect.minAdjacent)) : 3;\n        const maxForces =\n          typeof effect.maxForces === \"number\" ? Math.max(0, Math.floor(effect.maxForces)) : 6;\n        if (maxForces <= 0) {\n          break;\n        }\n        const neighbors = neighborHexKeys(target.hexKey).filter(\n          (hexKey) => Boolean(nextState.board.hexes[hexKey])\n        );\n        const adjacentCount = neighbors.reduce((count, hexKey) => {\n          const hex = nextState.board.hexes[hexKey];\n          if (!hex) {\n            return count;\n          }\n          return isOccupiedByPlayer(hex, playerId) ? count + 1 : count;\n        }, 0);\n        if (adjacentCount < minAdjacent) {\n          break;\n        }\n        const hex = nextState.board.hexes[target.hexKey];\n        if (!hex) {\n          break;\n        }\n        const enemyEntry = Object.entries(hex.occupants).find(\n          ([occupantId, units]) => occupantId !== playerId && units.length > 0\n        );\n        if (!enemyEntry) {\n          break;\n        }\n        const [enemyId, unitIds] = enemyEntry;\n        const enemyForces = unitIds.filter(\n          (unitId) => nextState.board.units[unitId]?.kind === \"force\"\n        );\n        if (enemyForces.length === 0) {\n          break;\n        }\n        const removeCount = Math.min(maxForces, enemyForces.length);\n        nextState = removeForcesFromHex(nextState, enemyId, target.hexKey, unitIds, removeCount);\n        break;\n      }\n      case \"mortarShot\": {\n        const target = getHexTarget(\n          nextState,\n          playerId,\n          card.targetSpec as TargetRecord,\n          targets ?? null\n        );\n        if (!target) {\n          break;\n        }\n        const maxDistance =\n          typeof effect.maxDistance === \"number\" ? effect.maxDistance : 2;\n        if (!hasFriendlyForceWithinRange(nextState, playerId, target.hexKey, maxDistance)) {\n          break;\n        }\n\n        const neighbors = neighborHexKeys(target.hexKey).filter(\n          (hexKey) => Boolean(nextState.board.hexes[hexKey])\n        );\n        const roll = randInt(nextState.rngState, 0, 99);\n        nextState = { ...nextState, rngState: roll.next };\n\n        let strikeHexKey = target.hexKey;\n        if (neighbors.length > 0 && roll.value >= 50) {\n          const pick = randInt(nextState.rngState, 0, neighbors.length - 1);\n          nextState = { ...nextState, rngState: pick.next };\n          strikeHexKey = neighbors[pick.value] ?? neighbors[0];\n        }\n\n        const forceLoss = typeof effect.forceLoss === \"number\" ? effect.forceLoss : 4;\n        let remainingLoss = Math.max(0, Math.floor(forceLoss));\n        for (const player of nextState.players) {\n          if (remainingLoss <= 0) {\n            break;\n          }\n          const hex = nextState.board.hexes[strikeHexKey];\n          if (!hex) {\n            break;\n          }\n          const occupants = hex.occupants[player.id] ?? [];\n          const available = occupants.filter(\n            (unitId) => nextState.board.units[unitId]?.kind === \"force\"\n          ).length;\n          if (available <= 0) {\n            continue;\n          }\n          const removeCount = Math.min(remainingLoss, available);\n          nextState = removeForcesFromHex(\n            nextState,\n            player.id,\n            strikeHexKey,\n            occupants,\n            removeCount\n          );\n          remainingLoss -= removeCount;\n        }\n\n        const damage = typeof effect.damage === \"number\" ? effect.damage : 2;\n        if (damage > 0) {\n          for (const unit of Object.values(nextState.board.units)) {\n            if (unit.kind !== \"champion\") {\n              continue;\n            }\n            if (unit.hex !== strikeHexKey) {\n              continue;\n            }\n            nextState = dealChampionDamage(nextState, playerId, unit.id, damage);\n          }\n        }\n        break;\n      }\n      case \"patchUp\": {\n        const target = getChampionTarget(\n          nextState,\n          playerId,\n          card.targetSpec as TargetRecord,\n          targets ?? null,\n          card\n        );\n        if (!target) {\n          break;\n        }\n        const baseHeal = typeof effect.baseHeal === \"number\" ? effect.baseHeal : 0;\n        const capitalBonus = typeof effect.capitalBonus === \"number\" ? effect.capitalBonus : 0;\n        let amount = baseHeal;\n        const player = nextState.players.find((entry) => entry.id === playerId);\n        if (player?.capitalHex && target.unit.hex === player.capitalHex) {\n          amount += capitalBonus;\n        }\n        nextState = healChampion(nextState, target.unitId, amount);\n        break;\n      }\n      case \"holdTheLine\": {\n        const target = getHexTarget(\n          nextState,\n          playerId,\n          card.targetSpec as TargetRecord,\n          targets ?? null\n        );\n        if (!target) {\n          break;\n        }\n        const modifierId = `card.${card.id}.${playerId}.${nextState.revision}.${target.hexKey}`;\n        nextState = {\n          ...nextState,\n          modifiers: [\n            ...nextState.modifiers,\n            {\n              id: modifierId,\n              source: { type: \"card\", sourceId: card.id },\n              ownerPlayerId: playerId,\n              attachedHex: target.hexKey,\n              duration: { type: \"endOfRound\" },\n              hooks: {\n                getForceHitFaces: ({ modifier, unit, defenderPlayerId }, current) => {\n                  if (unit.kind !== \"force\") {\n                    return current;\n                  }\n                  if (modifier.ownerPlayerId && modifier.ownerPlayerId !== unit.ownerPlayerId) {\n                    return current;\n                  }\n                  if (defenderPlayerId !== unit.ownerPlayerId) {\n                    return current;\n                  }\n                  return Math.max(current, 3);\n                }\n              }\n            }\n          ]\n        };\n        break;\n      }\n      case \"markForCoin\": {\n        const target = getChampionTarget(\n          nextState,\n          playerId,\n          card.targetSpec as TargetRecord,\n          targets ?? null,\n          card\n        );\n        if (!target) {\n          break;\n        }\n        const bounty = typeof effect.bounty === \"number\" ? Math.max(0, effect.bounty) : 0;\n        const modifierId = `card.${card.id}.${playerId}.${nextState.revision}.${target.unitId}`;\n        nextState = {\n          ...nextState,\n          modifiers: [\n            ...nextState.modifiers,\n            {\n              id: modifierId,\n              source: { type: \"card\", sourceId: card.id },\n              ownerPlayerId: playerId,\n              attachedUnitId: target.unitId,\n              duration: { type: \"endOfRound\" },\n              data: {\n                markedUnitId: target.unitId,\n                bonusGold: bounty\n              }\n            }\n          ]\n        };\n        break;\n      }\n      case \"ward\": {\n        const target = getChampionTarget(\n          nextState,\n          playerId,\n          card.targetSpec as TargetRecord,\n          targets ?? null,\n          card\n        );\n        if (!target) {\n          break;\n        }\n        const modifierId = `card.${card.id}.${playerId}.${nextState.revision}.${target.unitId}`;\n        nextState = {\n          ...nextState,\n          modifiers: [\n            ...nextState.modifiers,\n            {\n              id: modifierId,\n              source: { type: \"card\", sourceId: card.id },\n              ownerPlayerId: playerId,\n              attachedUnitId: target.unitId,\n              duration: { type: \"endOfRound\" },\n              data: {\n                targeting: {\n                  blockEnemyCards: true,\n                  scope: \"attachedUnit\"\n                }\n              }\n            }\n          ]\n        };\n        break;\n      }\n      case \"immunityField\": {\n        const modifierId = `card.${card.id}.${playerId}.${nextState.revision}`;\n        nextState = {\n          ...nextState,\n          modifiers: [\n            ...nextState.modifiers,\n            {\n              id: modifierId,\n              source: { type: \"card\", sourceId: card.id },\n              ownerPlayerId: playerId,\n              duration: { type: \"endOfRound\" },\n              data: {\n                targeting: {\n                  blockEnemySpells: true,\n                  scope: \"ownerChampions\"\n                }\n              }\n            }\n          ]\n        };\n        break;\n      }\n      case \"goldPlatedArmor\": {\n        const target = getChampionTarget(\n          nextState,\n          playerId,\n          card.targetSpec as TargetRecord,\n          targets ?? null,\n          card\n        );\n        if (!target) {\n          break;\n        }\n        const costPerDamage =\n          typeof effect.costPerDamage === \"number\" ? effect.costPerDamage : 2;\n        if (!Number.isFinite(costPerDamage) || costPerDamage <= 0) {\n          break;\n        }\n        const modifierId = `card.${card.id}.${playerId}.${nextState.revision}.${target.unitId}.gold_armor`;\n        nextState = {\n          ...nextState,\n          modifiers: [\n            ...nextState.modifiers,\n            {\n              id: modifierId,\n              source: { type: \"card\", sourceId: card.id },\n              ownerPlayerId: playerId,\n              attachedUnitId: target.unitId,\n              duration: { type: \"endOfRound\" },\n              data: {\n                goldArmor: {\n                  costPerDamage\n                }\n              }\n            }\n          ]\n        };\n        break;\n      }\n      case \"battleCry\": {\n        const modifierId = `card.${card.id}.${playerId}.${nextState.revision}.battle_cry`;\n        nextState = {\n          ...nextState,\n          modifiers: [\n            ...nextState.modifiers,\n            {\n              id: modifierId,\n              source: { type: \"card\", sourceId: card.id },\n              ownerPlayerId: playerId,\n              duration: { type: \"endOfRound\" },\n              hooks: {\n                beforeCombatRound: ({\n                  state,\n                  modifier,\n                  hexKey,\n                  round,\n                  attackerPlayerId,\n                  defenderPlayerId\n                }) => {\n                  if (round !== 1) {\n                    return state;\n                  }\n                  const ownerId = modifier.ownerPlayerId;\n                  if (!ownerId) {\n                    return state;\n                  }\n                  if (ownerId !== attackerPlayerId && ownerId !== defenderPlayerId) {\n                    return state;\n                  }\n                  const tempModifier: Modifier = {\n                    id: `${modifier.id}.battle`,\n                    source: { type: \"card\", sourceId: card.id },\n                    ownerPlayerId: ownerId,\n                    attachedHex: hexKey,\n                    duration: { type: \"endOfBattle\" },\n                    hooks: {\n                      getChampionAttackDice: ({ unit, round }, current) => {\n                        if (round !== 1 || unit.kind !== \"champion\") {\n                          return current;\n                        }\n                        if (unit.ownerPlayerId !== ownerId) {\n                          return current;\n                        }\n                        return current + 1;\n                      }\n                    }\n                  };\n                  const cleaned = removeModifierById(state, modifier.id);\n                  return { ...cleaned, modifiers: [...cleaned.modifiers, tempModifier] };\n                }\n              }\n            }\n          ]\n        };\n        break;\n      }\n      case \"smokeScreen\": {\n        const modifierId = `card.${card.id}.${playerId}.${nextState.revision}.smoke_screen`;\n        nextState = {\n          ...nextState,\n          modifiers: [\n            ...nextState.modifiers,\n            {\n              id: modifierId,\n              source: { type: \"card\", sourceId: card.id },\n              ownerPlayerId: playerId,\n              duration: { type: \"endOfRound\" },\n              hooks: {\n                beforeCombatRound: ({\n                  state,\n                  modifier,\n                  hexKey,\n                  round,\n                  attackerPlayerId,\n                  defenderPlayerId\n                }) => {\n                  if (round !== 1) {\n                    return state;\n                  }\n                  const ownerId = modifier.ownerPlayerId;\n                  if (!ownerId) {\n                    return state;\n                  }\n                  if (ownerId !== attackerPlayerId && ownerId !== defenderPlayerId) {\n                    return state;\n                  }\n                  const tempModifier: Modifier = {\n                    id: `${modifier.id}.battle`,\n                    source: { type: \"card\", sourceId: card.id },\n                    ownerPlayerId: ownerId,\n                    attachedHex: hexKey,\n                    duration: { type: \"endOfBattle\" },\n                    hooks: {\n                      getForceHitFaces: ({ unit, round }, current) => {\n                        if (round !== 1 || unit.kind !== \"force\") {\n                          return current;\n                        }\n                        if (unit.ownerPlayerId === ownerId) {\n                          return current;\n                        }\n                        return Math.min(current, 1);\n                      }\n                    }\n                  };\n                  const cleaned = removeModifierById(state, modifier.id);\n                  return { ...cleaned, modifiers: [...cleaned.modifiers, tempModifier] };\n                }\n              }\n            }\n          ]\n        };\n        break;\n      }\n      case \"shockDrill\": {\n        const modifierId = `card.${card.id}.${playerId}.${nextState.revision}.shock_drill`;\n        nextState = {\n          ...nextState,\n          modifiers: [\n            ...nextState.modifiers,\n            {\n              id: modifierId,\n              source: { type: \"card\", sourceId: card.id },\n              ownerPlayerId: playerId,\n              duration: { type: \"endOfRound\" },\n              hooks: {\n                beforeCombatRound: ({\n                  state,\n                  modifier,\n                  hexKey,\n                  round,\n                  attackerPlayerId,\n                  defenderPlayerId\n                }) => {\n                  if (round !== 1) {\n                    return state;\n                  }\n                  const ownerId = modifier.ownerPlayerId;\n                  if (!ownerId) {\n                    return state;\n                  }\n                  if (ownerId !== attackerPlayerId && ownerId !== defenderPlayerId) {\n                    return state;\n                  }\n                  const tempModifier: Modifier = {\n                    id: `${modifier.id}.battle`,\n                    source: { type: \"card\", sourceId: card.id },\n                    ownerPlayerId: ownerId,\n                    attachedHex: hexKey,\n                    duration: { type: \"endOfBattle\" },\n                    hooks: {\n                      getForceHitFaces: ({ unit, round }, current) => {\n                        if (round !== 1 || unit.kind !== \"force\") {\n                          return current;\n                        }\n                        if (unit.ownerPlayerId !== ownerId) {\n                          return current;\n                        }\n                        return Math.max(current, 5);\n                      }\n                    }\n                  };\n                  const cleaned = removeModifierById(state, modifier.id);\n                  return { ...cleaned, modifiers: [...cleaned.modifiers, tempModifier] };\n                }\n              }\n            }\n          ]\n        };\n        break;\n      }\n      case \"frenzy\": {\n        const target = getChampionTarget(\n          nextState,\n          playerId,\n          card.targetSpec as TargetRecord,\n          targets ?? null,\n          card\n        );\n        if (!target) {\n          break;\n        }\n        const diceBonus = typeof effect.diceBonus === \"number\" ? effect.diceBonus : 0;\n        const damage = typeof effect.damage === \"number\" ? effect.damage : 0;\n        nextState = dealChampionDamage(nextState, playerId, target.unitId, damage);\n        const updated = nextState.board.units[target.unitId];\n        if (!updated || updated.kind !== \"champion\") {\n          break;\n        }\n        if (diceBonus <= 0) {\n          break;\n        }\n        const modifierId = `card.${card.id}.${playerId}.${nextState.revision}.${target.unitId}.frenzy`;\n        nextState = {\n          ...nextState,\n          modifiers: [\n            ...nextState.modifiers,\n            {\n              id: modifierId,\n              source: { type: \"card\", sourceId: card.id },\n              ownerPlayerId: playerId,\n              attachedUnitId: target.unitId,\n              duration: { type: \"endOfRound\" },\n              hooks: {\n                getChampionAttackDice: ({ unit }, current) => {\n                  if (unit.kind !== \"champion\") {\n                    return current;\n                  }\n                  if (unit.id !== target.unitId) {\n                    return current;\n                  }\n                  return current + diceBonus;\n                }\n              }\n            }\n          ]\n        };\n        break;\n      }\n      case \"slow\": {\n        const target = getChampionTarget(\n          nextState,\n          playerId,\n          card.targetSpec as TargetRecord,\n          targets ?? null,\n          card\n        );\n        if (!target) {\n          break;\n        }\n        const modifierId = `card.${card.id}.${playerId}.${nextState.revision}.${target.unitId}.slow`;\n        nextState = {\n          ...nextState,\n          modifiers: [\n            ...nextState.modifiers,\n            {\n              id: modifierId,\n              source: { type: \"card\", sourceId: card.id },\n              ownerPlayerId: playerId,\n              attachedUnitId: target.unitId,\n              duration: { type: \"endOfRound\" },\n              hooks: {\n                beforeCombatRound: ({ state, modifier, hexKey }) => {\n                  const unitId = modifier.attachedUnitId;\n                  if (!unitId) {\n                    return state;\n                  }\n                  const unit = state.board.units[unitId];\n                  if (!unit || unit.kind !== \"champion\") {\n                    return state;\n                  }\n                  if (unit.hex !== hexKey) {\n                    return state;\n                  }\n                  const tempModifier: Modifier = {\n                    id: `${modifier.id}.battle`,\n                    source: { type: \"card\", sourceId: card.id },\n                    ownerPlayerId: modifier.ownerPlayerId,\n                    attachedUnitId: unitId,\n                    attachedHex: hexKey,\n                    duration: { type: \"endOfBattle\" },\n                    hooks: {\n                      getChampionAttackDice: ({ unit }, current) => {\n                        if (unit.kind !== \"champion\" || unit.id !== unitId) {\n                          return current;\n                        }\n                        return Math.min(current, 1);\n                      }\n                    }\n                  };\n                  const cleaned = removeModifierById(state, modifier.id);\n                  return { ...cleaned, modifiers: [...cleaned.modifiers, tempModifier] };\n                }\n              }\n            }\n          ]\n        };\n        break;\n      }\n      case \"focusFire\": {\n        const modifierId = `card.${card.id}.${playerId}.${nextState.revision}.focus_fire`;\n        nextState = {\n          ...nextState,\n          modifiers: [\n            ...nextState.modifiers,\n            {\n              id: modifierId,\n              source: { type: \"card\", sourceId: card.id },\n              ownerPlayerId: playerId,\n              duration: { type: \"endOfRound\" },\n              hooks: {\n                beforeCombatRound: ({\n                  state,\n                  modifier,\n                  hexKey,\n                  round,\n                  attackerPlayerId,\n                  defenderPlayerId\n                }) => {\n                  if (round !== 1) {\n                    return state;\n                  }\n                  const ownerId = modifier.ownerPlayerId;\n                  if (!ownerId) {\n                    return state;\n                  }\n                  if (ownerId !== attackerPlayerId && ownerId !== defenderPlayerId) {\n                    return state;\n                  }\n                  const tempModifier: Modifier = {\n                    id: `${modifier.id}.battle`,\n                    source: { type: \"card\", sourceId: card.id },\n                    ownerPlayerId: ownerId,\n                    attachedHex: hexKey,\n                    duration: { type: \"endOfBattle\" },\n                    hooks: {\n                      getHitAssignmentPolicy: (\n                        { targetSide, attackerPlayerId, defenderPlayerId },\n                        current\n                      ) => {\n                        if (ownerId === attackerPlayerId && targetSide === \"defenders\") {\n                          return \"focusFire\";\n                        }\n                        if (ownerId === defenderPlayerId && targetSide === \"attackers\") {\n                          return \"focusFire\";\n                        }\n                        return current;\n                      }\n                    }\n                  };\n                  const cleaned = removeModifierById(state, modifier.id);\n                  return { ...cleaned, modifiers: [...cleaned.modifiers, tempModifier] };\n                }\n              }\n            }\n          ]\n        };\n        break;\n      }\n      case \"battleWinDraw\": {\n        const drawCountRaw = typeof effect.drawCount === \"number\" ? effect.drawCount : 0;\n        const drawCount = Math.max(0, Math.floor(drawCountRaw));\n        if (drawCount <= 0) {\n          break;\n        }\n        const movePath = getMovePathTarget(targets ?? null);\n        if (!movePath) {\n          break;\n        }\n        const moveEffect = card.effects?.find(\n          (entry) => entry.kind === \"moveStack\"\n        ) as TargetRecord | undefined;\n        const forceCount = getMoveStackForceCount(card, moveEffect, targets ?? null);\n        const movingUnitIds = selectMovingUnits(\n          nextState.board,\n          playerId,\n          movePath[0],\n          forceCount\n        );\n        if (movingUnitIds.length === 0) {\n          break;\n        }\n        const modifierId = `card.${card.id}.${playerId}.${nextState.revision}.battle_win_draw`;\n        nextState = {\n          ...nextState,\n          modifiers: [\n            ...nextState.modifiers,\n            {\n              id: modifierId,\n              source: { type: \"card\", sourceId: card.id },\n              ownerPlayerId: playerId,\n              duration: { type: \"endOfRound\" },\n              data: { trackedUnitIds: movingUnitIds, drawCount },\n              hooks: {\n                afterBattle: ({\n                  state,\n                  modifier,\n                  winnerPlayerId,\n                  attackerPlayerId,\n                  defenderPlayerId,\n                  attackers,\n                  defenders\n                }) => {\n                  const ownerId = modifier.ownerPlayerId;\n                  if (!ownerId || winnerPlayerId !== ownerId) {\n                    return state;\n                  }\n                  const trackedRaw = modifier.data?.trackedUnitIds;\n                  if (!Array.isArray(trackedRaw) || trackedRaw.length === 0) {\n                    return state;\n                  }\n                  const tracked = trackedRaw.filter((id) => typeof id === \"string\");\n                  const survivors =\n                    winnerPlayerId === attackerPlayerId\n                      ? attackers\n                      : winnerPlayerId === defenderPlayerId\n                        ? defenders\n                        : [];\n                  if (\n                    tracked.length === 0 ||\n                    survivors.length === 0 ||\n                    !tracked.some((id) => survivors.includes(id))\n                  ) {\n                    return state;\n                  }\n                  const countRaw =\n                    typeof modifier.data?.drawCount === \"number\" ? modifier.data.drawCount : 0;\n                  const count = Math.max(0, Math.floor(countRaw));\n                  if (count <= 0) {\n                    return state;\n                  }\n                  const cleaned = removeModifierById(state, modifier.id);\n                  return {\n                    ...cleaned,\n                    modifiers: [\n                      ...cleaned.modifiers,\n                      {\n                        id: `${modifier.id}.cleanup`,\n                        source: modifier.source,\n                        ownerPlayerId: ownerId,\n                        duration: { type: \"uses\", remaining: 1 },\n                        hooks: {\n                          onRoundEnd: ({ state }) => drawCards(state, ownerId, count)\n                        }\n                      }\n                    ]\n                  };\n                }\n              }\n            }\n          ]\n        };\n        break;\n      }\n      case \"setToSkirmish\": {\n        const target = getHexTarget(\n          nextState,\n          playerId,\n          card.targetSpec as TargetRecord,\n          targets ?? null\n        );\n        if (!target) {\n          break;\n        }\n        const modifierId = `card.${card.id}.${playerId}.${nextState.revision}.${target.hexKey}.skirmish`;\n        nextState = {\n          ...nextState,\n          modifiers: [\n            ...nextState.modifiers,\n            {\n              id: modifierId,\n              source: { type: \"card\", sourceId: card.id },\n              ownerPlayerId: playerId,\n              attachedHex: target.hexKey,\n              duration: { type: \"endOfRound\" },\n              hooks: {\n                beforeCombatRound: ({ state, modifier, hexKey, round }) => {\n                  if (round !== 1) {\n                    return state;\n                  }\n                  const ownerId = modifier.ownerPlayerId;\n                  if (!ownerId) {\n                    return state;\n                  }\n                  const hex = state.board.hexes[hexKey];\n                  if (!hex) {\n                    return state;\n                  }\n                  const ownerUnits = hex.occupants[ownerId] ?? [];\n                  if (ownerUnits.length === 0) {\n                    return state;\n                  }\n\n                  const candidates = neighborHexKeys(hexKey).filter((neighbor) => {\n                    const neighborHex = state.board.hexes[neighbor];\n                    if (!neighborHex) {\n                      return false;\n                    }\n                    return countPlayersOnHex(neighborHex) === 0;\n                  });\n\n                  if (candidates.length === 0) {\n                    let nextState = state;\n                    const forceCount = ownerUnits.filter(\n                      (unitId) => state.board.units[unitId]?.kind === \"force\"\n                    ).length;\n                    if (forceCount > 0) {\n                      nextState = removeForcesFromHex(\n                        nextState,\n                        ownerId,\n                        hexKey,\n                        ownerUnits,\n                        forceCount\n                      );\n                    }\n                    for (const unitId of ownerUnits) {\n                      const unit = nextState.board.units[unitId];\n                      if (!unit || unit.kind !== \"champion\") {\n                        continue;\n                      }\n                      nextState = dealChampionDamage(\n                        nextState,\n                        ownerId,\n                        unitId,\n                        unit.hp\n                      );\n                    }\n                    return nextState;\n                  }\n\n                  const roll = randInt(state.rngState, 0, candidates.length - 1);\n                  const retreatHex = candidates[roll.value] ?? candidates[0];\n                  let nextState: GameState = {\n                    ...state,\n                    rngState: roll.next\n                  };\n                  nextState = moveUnits(nextState, ownerId, ownerUnits, hexKey, retreatHex);\n                  return nextState;\n                }\n              }\n            }\n          ]\n        };\n        break;\n      }\n      case \"buildBridge\": {\n        const isTemporary = effect.temporary === true;\n        if (card.targetSpec.kind === \"multiEdge\") {\n          const plans = getBuildBridgePlans(\n            nextState,\n            playerId,\n            card.targetSpec as TargetRecord,\n            targets ?? null\n          );\n          if (!plans || plans.length === 0) {\n            break;\n          }\n          const bridges = { ...nextState.board.bridges };\n          for (const plan of plans) {\n            bridges[plan.key] = {\n              key: plan.key,\n              from: plan.from,\n              to: plan.to,\n              ownerPlayerId: playerId,\n              temporary: isTemporary ? true : undefined\n            };\n          }\n          nextState = {\n            ...nextState,\n            board: {\n              ...nextState.board,\n              bridges\n            }\n          };\n          break;\n        }\n        const plan = getBuildBridgePlan(\n          nextState,\n          playerId,\n          card.targetSpec as TargetRecord,\n          targets ?? null\n        );\n        if (!plan) {\n          break;\n        }\n        nextState = {\n          ...nextState,\n          board: {\n            ...nextState.board,\n            bridges: {\n              ...nextState.board.bridges,\n              [plan.key]: {\n                key: plan.key,\n                from: plan.from,\n                to: plan.to,\n                ownerPlayerId: playerId,\n                temporary: isTemporary ? true : undefined\n              }\n            }\n          }\n        };\n        break;\n      }\n      case \"lockBridge\": {\n        const plan = getExistingBridgePlan(\n          nextState,\n          playerId,\n          card.targetSpec as TargetRecord,\n          targets ?? null\n        );\n        if (!plan) {\n          break;\n        }\n        const modifierId = `card.${card.id}.${playerId}.${nextState.revision}.${plan.key}.lock`;\n        nextState = {\n          ...nextState,\n          modifiers: [\n            ...nextState.modifiers,\n            {\n              id: modifierId,\n              source: { type: \"card\", sourceId: card.id },\n              ownerPlayerId: playerId,\n              attachedEdge: plan.key,\n              duration: { type: \"endOfRound\" },\n              hooks: {\n                getMoveAdjacency: ({ modifier, from, to }, current) => {\n                  if (!modifier.attachedEdge) {\n                    return current;\n                  }\n                  return getBridgeKey(from, to) === modifier.attachedEdge ? false : current;\n                }\n              }\n            }\n          ]\n        };\n        break;\n      }\n      case \"trapBridge\": {\n        const plan = getExistingBridgePlan(\n          nextState,\n          playerId,\n          card.targetSpec as TargetRecord,\n          targets ?? null\n        );\n        if (!plan) {\n          break;\n        }\n        const lossValue =\n          typeof effect.forceLoss === \"number\"\n            ? effect.forceLoss\n            : typeof effect.loss === \"number\"\n              ? effect.loss\n              : 1;\n        const loss = Number.isFinite(lossValue) ? Math.max(1, Math.floor(lossValue)) : 1;\n        const modifierId = `card.${card.id}.${playerId}.${nextState.revision}.${plan.key}.trap`;\n        nextState = {\n          ...nextState,\n          modifiers: [\n            ...nextState.modifiers,\n            {\n              id: modifierId,\n              source: { type: \"card\", sourceId: card.id },\n              ownerPlayerId: playerId,\n              attachedEdge: plan.key,\n              duration: { type: \"endOfRound\" },\n              hooks: {\n                onMove: ({ state, modifier, playerId: movingPlayerId, from, to, movingUnitIds }) => {\n                  if (!modifier.attachedEdge) {\n                    return state;\n                  }\n                  if (modifier.ownerPlayerId && modifier.ownerPlayerId === movingPlayerId) {\n                    return state;\n                  }\n                  if (getBridgeKey(from, to) !== modifier.attachedEdge) {\n                    return state;\n                  }\n                  const nextState = removeForcesFromHex(\n                    state,\n                    movingPlayerId,\n                    to,\n                    movingUnitIds,\n                    loss\n                  );\n                  if (nextState === state) {\n                    return state;\n                  }\n                  const nextModifiers = nextState.modifiers.filter(\n                    (entry) => entry.id !== modifier.id\n                  );\n                  return nextModifiers.length === nextState.modifiers.length\n                    ? nextState\n                    : { ...nextState, modifiers: nextModifiers };\n                }\n              }\n            }\n          ]\n        };\n        break;\n      }\n      case \"destroyBridge\": {\n        const targetSpec = card.targetSpec as TargetRecord;\n        if (card.targetSpec.kind === \"multiEdge\") {\n          const plans = getExistingBridgePlans(nextState, playerId, targetSpec, targets ?? null);\n          if (!plans || plans.length === 0) {\n            break;\n          }\n          const bridges = { ...nextState.board.bridges };\n          for (const plan of plans) {\n            delete bridges[plan.key];\n          }\n          nextState = {\n            ...nextState,\n            board: {\n              ...nextState.board,\n              bridges\n            }\n          };\n          break;\n        }\n        const plan = getExistingBridgePlan(nextState, playerId, targetSpec, targets ?? null);\n        if (!plan) {\n          break;\n        }\n        const { [plan.key]: _removed, ...bridges } = nextState.board.bridges;\n        nextState = {\n          ...nextState,\n          board: {\n            ...nextState.board,\n            bridges\n          }\n        };\n        break;\n      }\n      case \"bridgePivot\": {\n        const targetSpec = card.targetSpec as TargetRecord;\n        const plans = getBridgePivotPlans(nextState, playerId, targetSpec, targets ?? null);\n        if (!plans) {\n          break;\n        }\n        const bridges = { ...nextState.board.bridges };\n        delete bridges[plans.existing.key];\n        bridges[plans.build.key] = {\n          key: plans.build.key,\n          from: plans.build.from,\n          to: plans.build.to,\n          ownerPlayerId: playerId\n        };\n        nextState = {\n          ...nextState,\n          board: {\n            ...nextState.board,\n            bridges\n          }\n        };\n        break;\n      }\n      case \"destroyConnectedBridges\": {\n        const movePath = targets ? getMovePathTarget(targets) : null;\n        const targetHex = movePath ? movePath[movePath.length - 1] : getHexKeyTarget(targets ?? null);\n        if (!targetHex) {\n          break;\n        }\n        const bridges = Object.fromEntries(\n          Object.entries(nextState.board.bridges).filter(\n            ([, bridge]) => bridge.from !== targetHex && bridge.to !== targetHex\n          )\n        );\n        nextState = {\n          ...nextState,\n          board: {\n            ...nextState.board,\n            bridges\n          }\n        };\n        break;\n      }\n      case \"linkHexes\": {\n        const link = getHexPairTarget(\n          nextState,\n          playerId,\n          card.targetSpec as TargetRecord,\n          targets ?? null\n        );\n        if (!link) {\n          break;\n        }\n        nextState = addHexLinkModifier(nextState, playerId, card.id, link.from, link.to);\n        break;\n      }\n      case \"linkCapitalToCenter\": {\n        const player = nextState.players.find((entry) => entry.id === playerId);\n        if (!player?.capitalHex) {\n          break;\n        }\n        const centerHexKey = getCenterHexKey(nextState.board);\n        if (!centerHexKey) {\n          break;\n        }\n        nextState = addHexLinkModifier(\n          nextState,\n          playerId,\n          card.id,\n          player.capitalHex,\n          centerHexKey\n        );\n        break;\n      }\n      case \"moveStacks\": {\n        const paths = getMultiPathTargets(targets ?? null);\n        if (!paths || paths.length === 0) {\n          break;\n        }\n        const targetSpec = card.targetSpec as TargetRecord;\n        const owner = typeof targetSpec.owner === \"string\" ? targetSpec.owner : \"self\";\n        if (owner !== \"self\") {\n          break;\n        }\n        const minPaths =\n          typeof targetSpec.minPaths === \"number\"\n            ? Math.max(0, Math.floor(targetSpec.minPaths))\n            : 1;\n        const maxPaths =\n          typeof targetSpec.maxPaths === \"number\"\n            ? Math.max(0, Math.floor(targetSpec.maxPaths))\n            : Number.POSITIVE_INFINITY;\n        if (paths.length < minPaths || paths.length > maxPaths) {\n          break;\n        }\n        const maxDistance =\n          typeof effect.maxDistance === \"number\"\n            ? effect.maxDistance\n            : typeof targetSpec.maxDistance === \"number\"\n              ? targetSpec.maxDistance\n              : undefined;\n        const requiresBridge =\n          effect.requiresBridge === false ? false : targetSpec.requiresBridge !== false;\n        const stopOnOccupied =\n          effect.stopOnOccupied === true || targetSpec.stopOnOccupied === true;\n        const seenStarts = new Set<string>();\n        const movePlans: Array<{ path: string[]; unitIds: string[] }> = [];\n        let validationState = nextState;\n        const snapshotBoard = nextState.board;\n        for (const path of paths) {\n          const start = path[0];\n          if (seenStarts.has(start)) {\n            movePlans.length = 0;\n            break;\n          }\n          seenStarts.add(start);\n          const unitIds = selectMovingUnits(snapshotBoard, playerId, start);\n          if (unitIds.length === 0) {\n            movePlans.length = 0;\n            break;\n          }\n          const validPath = validateMovePath(validationState, playerId, path, {\n            maxDistance,\n            requiresBridge,\n            requireStartOccupied: true,\n            movingUnitIds: unitIds,\n            stopOnOccupied\n          });\n          if (!validPath) {\n            movePlans.length = 0;\n            break;\n          }\n          movePlans.push({ path: validPath, unitIds });\n          validationState = markPlayerMovedThisRound(validationState, playerId);\n        }\n        if (movePlans.length === 0) {\n          break;\n        }\n        for (const plan of movePlans) {\n          nextState = moveUnitIdsAlongPath(nextState, playerId, plan.path, plan.unitIds);\n          nextState = markPlayerMovedThisRound(nextState, playerId);\n        }\n        break;\n      }\n      case \"moveStack\": {\n        const movePath = getMovePathTarget(targets ?? null);\n        if (!movePath) {\n          break;\n        }\n        const maxDistance =\n          typeof effect.maxDistance === \"number\"\n            ? effect.maxDistance\n            : typeof card.targetSpec.maxDistance === \"number\"\n              ? card.targetSpec.maxDistance\n              : undefined;\n        const requiresBridge =\n          effect.requiresBridge === false ? false : card.targetSpec.requiresBridge !== false;\n        const stopOnOccupied =\n          effect.stopOnOccupied === true ||\n          (card.targetSpec as TargetRecord | undefined)?.stopOnOccupied === true;\n        const forceCount = getMoveStackForceCount(card, effect, targets ?? null);\n        const includeChampions = getMoveStackIncludeChampions(card, effect, targets ?? null);\n        const validPath = validateMovePath(nextState, playerId, movePath, {\n          maxDistance,\n          requiresBridge,\n          requireStartOccupied: true,\n          forceCount,\n          includeChampions,\n          stopOnOccupied\n        });\n        if (!validPath) {\n          break;\n        }\n        nextState = moveUnitsAlongPath(\n          nextState,\n          playerId,\n          validPath,\n          forceCount,\n          includeChampions\n        );\n        nextState = markPlayerMovedThisRound(nextState, playerId);\n        break;\n      }\n      default:\n        break;\n    }\n  }\n\n  return nextState;\n};\n\nconst isScoutReportChoiceValid = (\n  state: GameState,\n  block: Extract<BlockState, { type: \"action.scoutReport\" }>,\n  playerId: PlayerID,\n  cardInstanceIds: CardInstanceID[]\n): boolean => {\n  if (block.payload.playerId !== playerId) {\n    return false;\n  }\n  const maxKeep = Math.min(block.payload.keepCount, block.payload.offers.length);\n  if (cardInstanceIds.length > maxKeep) {\n    return false;\n  }\n  const unique = new Set(cardInstanceIds);\n  if (unique.size !== cardInstanceIds.length) {\n    return false;\n  }\n  const offerSet = new Set(block.payload.offers);\n  if (!cardInstanceIds.every((id) => offerSet.has(id))) {\n    return false;\n  }\n  const player = state.players.find((entry) => entry.id === playerId);\n  return Boolean(player);\n};\n\nconst resolveScoutReportSelection = (\n  block: Extract<BlockState, { type: \"action.scoutReport\" }>\n): CardInstanceID[] => {\n  const offers = block.payload.offers;\n  const maxKeep = Math.min(block.payload.keepCount, offers.length);\n  if (maxKeep <= 0) {\n    return [];\n  }\n  const rawChosen = block.payload.chosen ?? [];\n  const offerSet = new Set(offers);\n  const filtered = rawChosen.filter((id) => offerSet.has(id));\n  const unique = Array.from(new Set(filtered)).slice(0, maxKeep);\n  if (unique.length > 0) {\n    return unique;\n  }\n  return offers.slice(0, maxKeep);\n};\n\nexport const applyScoutReportChoice = (\n  state: GameState,\n  cardInstanceIds: CardInstanceID[],\n  playerId: PlayerID\n): GameState => {\n  const block = state.blocks;\n  if (!block || block.type !== \"action.scoutReport\") {\n    return state;\n  }\n  if (!block.waitingFor.includes(playerId)) {\n    return state;\n  }\n  if (block.payload.chosen) {\n    return state;\n  }\n  if (!isScoutReportChoiceValid(state, block, playerId, cardInstanceIds)) {\n    return state;\n  }\n\n  return {\n    ...state,\n    blocks: {\n      ...block,\n      waitingFor: block.waitingFor.filter((id) => id !== playerId),\n      payload: {\n        ...block.payload,\n        chosen: cardInstanceIds\n      }\n    }\n  };\n};\n\nexport const resolveScoutReportBlock = (\n  state: GameState,\n  block: Extract<BlockState, { type: \"action.scoutReport\" }>\n): GameState => {\n  const selected = resolveScoutReportSelection(block);\n  const selectedSet = new Set(selected);\n  let nextState = state;\n  for (const cardId of selected) {\n    nextState = addCardToHandWithOverflow(nextState, block.payload.playerId, cardId);\n  }\n  for (const cardId of block.payload.offers) {\n    if (selectedSet.has(cardId)) {\n      continue;\n    }\n    nextState = addCardToDiscardPile(nextState, block.payload.playerId, cardId, {\n      countAsDiscard: true\n    });\n  }\n  return nextState;\n};\n", "import { compareHexKeys, parseEdgeKey, randInt, rollDie } from \"@bridgefront/shared\";\n\nimport type {\n  ChampionUnitState,\n  BlockState,\n  CombatAssignmentContext,\n  CombatContext,\n  CombatEndContext,\n  CombatEndReason,\n  CombatRoundContext,\n  CombatSide,\n  CombatSideSummary,\n  CombatRetreatSelection,\n  EdgeKey,\n  CombatUnitContext,\n  GameState,\n  HexKey,\n  HitAssignmentPolicy,\n  PlayerID,\n  UnitID,\n  UnitState\n} from \"./types\";\nimport { getPlayerIdsOnHex, isContestedHex } from \"./board\";\nimport { emit } from \"./events\";\nimport {\n  applyModifierQuery,\n  expireEndOfBattleModifiers,\n  getCombatModifiers,\n  runModifierEvents\n} from \"./modifiers\";\nimport {\n  consumeChampionAbilityUse,\n  GRAND_STRATEGIST_CHAMPION_ID,\n  TACTICAL_HAND_KEY,\n  applyGoldArmorToDamage,\n  applyChampionDeathEffects,\n  removeChampionModifiers\n} from \"./champions\";\nimport { applyChampionKillRewards } from \"./rewards\";\nimport { moveStack } from \"./units\";\n\nconst FORCE_HIT_FACES = 2;\nconst MAX_STALE_COMBAT_ROUNDS = 20;\nconst TACTICAL_HAND_HITS = 3;\n\ntype HitRollResult = {\n  hits: number;\n  nextState: GameState[\"rngState\"];\n  rolls: DiceRoll[];\n  unitRolls: CombatUnitRoll[];\n};\n\ntype HitAssignmentResult = {\n  hitsByUnit: Record<UnitID, number>;\n  nextState: GameState[\"rngState\"];\n  bodyguardUsed?: boolean;\n};\n\ntype DiceRoll = {\n  value: number;\n  isHit: boolean;\n};\n\ntype CombatUnitRoll = {\n  unitId: UnitID;\n  kind: UnitState[\"kind\"];\n  cardDefId?: string;\n  hp?: number;\n  maxHp?: number;\n  attackDice: number;\n  hitFaces: number;\n  dice: DiceRoll[];\n};\n\ntype HitAssignmentSummary = {\n  forces: number;\n  champions: Array<{\n    unitId: UnitID;\n    cardDefId: string;\n    hits: number;\n    hp: number;\n    maxHp: number;\n  }>;\n};\n\ntype HitResolution = {\n  removedUnitIds: UnitID[];\n  updatedChampions: Record<UnitID, ChampionUnitState>;\n  bounty: number;\n  killedChampions: ChampionUnitState[];\n};\n\ntype CombatantSummary = {\n  forces: number;\n  champions: number;\n  total: number;\n};\n\nconst getForceHitFaces = (\n  state: GameState,\n  modifiers: GameState[\"modifiers\"],\n  context: CombatUnitContext\n): number => {\n  return applyModifierQuery(\n    state,\n    modifiers,\n    (hooks) => hooks.getForceHitFaces,\n    context,\n    FORCE_HIT_FACES\n  );\n};\n\nconst getChampionAttackDice = (\n  state: GameState,\n  modifiers: GameState[\"modifiers\"],\n  context: CombatUnitContext,\n  base: number\n): number => {\n  return applyModifierQuery(\n    state,\n    modifiers,\n    (hooks) => hooks.getChampionAttackDice,\n    context,\n    base\n  );\n};\n\nconst getChampionHitFaces = (\n  state: GameState,\n  modifiers: GameState[\"modifiers\"],\n  context: CombatUnitContext,\n  base: number\n): number => {\n  return applyModifierQuery(\n    state,\n    modifiers,\n    (hooks) => hooks.getChampionHitFaces,\n    context,\n    base\n  );\n};\n\nconst getHitAssignmentPolicy = (\n  state: GameState,\n  modifiers: GameState[\"modifiers\"],\n  context: CombatAssignmentContext\n): HitAssignmentPolicy => {\n  return applyModifierQuery(\n    state,\n    modifiers,\n    (hooks) => hooks.getHitAssignmentPolicy,\n    context,\n    \"random\"\n  );\n};\n\nconst getUnitCombatProfile = (\n  state: GameState,\n  modifiers: GameState[\"modifiers\"],\n  context: CombatContext,\n  side: CombatSide,\n  unitId: UnitID,\n  unit: UnitState\n): { attackDice: number; hitFaces: number } => {\n  const unitContext: CombatUnitContext = {\n    ...context,\n    side,\n    unitId,\n    unit\n  };\n\n  if (unit.kind === \"force\") {\n    return {\n      attackDice: 1,\n      hitFaces: getForceHitFaces(state, modifiers, unitContext)\n    };\n  }\n\n  return {\n    attackDice: getChampionAttackDice(state, modifiers, unitContext, unit.attackDice),\n    hitFaces: getChampionHitFaces(state, modifiers, unitContext, unit.hitFaces)\n  };\n};\n\nconst unitCanHit = (\n  state: GameState,\n  modifiers: GameState[\"modifiers\"],\n  context: CombatContext,\n  side: CombatSide,\n  unitId: UnitID,\n  unit?: UnitState\n): boolean => {\n  if (!unit) {\n    return false;\n  }\n  const { attackDice, hitFaces } = getUnitCombatProfile(\n    state,\n    modifiers,\n    context,\n    side,\n    unitId,\n    unit\n  );\n  return attackDice > 0 && hitFaces > 0;\n};\n\nconst rollHitsForUnits = (\n  unitIds: UnitID[],\n  units: Record<UnitID, UnitState>,\n  state: GameState,\n  modifiers: GameState[\"modifiers\"],\n  context: CombatContext,\n  side: CombatSide,\n  rngState: GameState[\"rngState\"]\n): HitRollResult => {\n  let hits = 0;\n  let nextState = rngState;\n  const rolls: DiceRoll[] = [];\n  const unitRolls: CombatUnitRoll[] = [];\n\n  for (const unitId of unitIds) {\n    const unit = units[unitId];\n    if (!unit) {\n      continue;\n    }\n\n    const { attackDice, hitFaces } = getUnitCombatProfile(\n      state,\n      modifiers,\n      context,\n      side,\n      unitId,\n      unit\n    );\n    const unitRoll: CombatUnitRoll = {\n      unitId,\n      kind: unit.kind,\n      attackDice,\n      hitFaces,\n      dice: []\n    };\n    if (unit.kind === \"champion\") {\n      unitRoll.cardDefId = unit.cardDefId;\n      unitRoll.hp = unit.hp;\n      unitRoll.maxHp = unit.maxHp;\n    }\n    if (attackDice <= 0 || hitFaces <= 0) {\n      unitRolls.push(unitRoll);\n      continue;\n    }\n\n    for (let i = 0; i < attackDice; i += 1) {\n      const roll = rollDie(nextState);\n      nextState = roll.next;\n      const isHit = roll.value <= hitFaces;\n      const entry = { value: roll.value, isHit };\n      rolls.push(entry);\n      unitRoll.dice.push(entry);\n      if (isHit) {\n        hits += 1;\n      }\n    }\n    unitRolls.push(unitRoll);\n  }\n\n  return { hits, nextState, rolls, unitRolls };\n};\n\nconst findTacticalHandSource = (\n  state: GameState,\n  hexKey: HexKey,\n  ownerPlayerId: PlayerID\n): UnitID | null => {\n  const hex = state.board.hexes[hexKey];\n  if (!hex) {\n    return null;\n  }\n  const occupantIds = hex.occupants[ownerPlayerId] ?? [];\n  for (const unitId of occupantIds) {\n    const unit = state.board.units[unitId];\n    if (\n      unit?.kind === \"champion\" &&\n      unit.cardDefId === GRAND_STRATEGIST_CHAMPION_ID &&\n      (unit.abilityUses[TACTICAL_HAND_KEY]?.remaining ?? 0) > 0\n    ) {\n      return unitId;\n    }\n  }\n  return null;\n};\n\nconst hasBodyguardModifier = (\n  modifiers: GameState[\"modifiers\"],\n  targetUnitIds: UnitID[],\n  units: Record<UnitID, UnitState>\n): boolean => {\n  if (targetUnitIds.length === 0) {\n    return false;\n  }\n  const hasForce = targetUnitIds.some((unitId) => units[unitId]?.kind === \"force\");\n  if (!hasForce) {\n    return false;\n  }\n  return modifiers.some((modifier) => {\n    if (modifier.data?.bodyguard !== true) {\n      return false;\n    }\n    const unitId = modifier.data?.unitId;\n    return typeof unitId === \"string\" && targetUnitIds.includes(unitId);\n  });\n};\n\nconst assignHits = (\n  unitIds: UnitID[],\n  hits: number,\n  policy: HitAssignmentPolicy,\n  units: Record<UnitID, UnitState>,\n  rngState: GameState[\"rngState\"],\n  bodyguardUsed = false,\n  bodyguardActive = policy === \"bodyguard\"\n): HitAssignmentResult => {\n  const hitsByUnit: Record<UnitID, number> = {};\n  let nextState = rngState;\n\n  if (hits <= 0 || unitIds.length === 0) {\n    return { hitsByUnit, nextState };\n  }\n\n  const pickRandomTarget = (candidates: UnitID[]): UnitID | null => {\n    if (candidates.length === 0) {\n      return null;\n    }\n    const roll = randInt(nextState, 0, candidates.length - 1);\n    nextState = roll.next;\n    return candidates[roll.value] ?? null;\n  };\n\n  if (policy === \"random\") {\n    for (let i = 0; i < hits; i += 1) {\n      const targetId = pickRandomTarget(unitIds);\n      if (!targetId) {\n        break;\n      }\n      hitsByUnit[targetId] = (hitsByUnit[targetId] ?? 0) + 1;\n    }\n    return { hitsByUnit, nextState };\n  }\n\n  if (policy === \"bodyguard\") {\n    let used = bodyguardUsed;\n    const forceUnitIds = unitIds.filter((unitId) => units[unitId]?.kind === \"force\");\n    for (let i = 0; i < hits; i += 1) {\n      const targetId = pickRandomTarget(unitIds);\n      if (!targetId) {\n        break;\n      }\n      const targetUnit = units[targetId];\n      if (!used && targetUnit?.kind === \"champion\" && forceUnitIds.length > 0) {\n        const redirectId = pickRandomTarget(forceUnitIds);\n        if (redirectId) {\n          hitsByUnit[redirectId] = (hitsByUnit[redirectId] ?? 0) + 1;\n          used = true;\n          continue;\n        }\n      }\n      hitsByUnit[targetId] = (hitsByUnit[targetId] ?? 0) + 1;\n    }\n    return { hitsByUnit, nextState, bodyguardUsed: used };\n  }\n\n  if (policy === \"tacticalHand\" || policy === \"focusFire\") {\n    let used = bodyguardUsed;\n    const forceUnitIds = unitIds.filter((unitId) => units[unitId]?.kind === \"force\");\n    const championRemaining = new Map<UnitID, number>();\n    for (const unitId of unitIds) {\n      const unit = units[unitId];\n      if (unit?.kind === \"champion\") {\n        championRemaining.set(unitId, unit.hp);\n      }\n    }\n    const forceTargets = forceUnitIds.slice().sort();\n\n    const pickManualTarget = (): UnitID | null => {\n      let bestChampion: UnitID | null = null;\n      let bestHp = Number.POSITIVE_INFINITY;\n      for (const [unitId, remaining] of championRemaining.entries()) {\n        if (remaining <= 0) {\n          continue;\n        }\n        if (remaining < bestHp || (remaining === bestHp && unitId < (bestChampion ?? \"\"))) {\n          bestChampion = unitId;\n          bestHp = remaining;\n        }\n      }\n      if (bestChampion) {\n        return bestChampion;\n      }\n      return forceTargets[0] ?? null;\n    };\n\n    let assignedManual = 0;\n    const manualLimit = policy === \"tacticalHand\" ? TACTICAL_HAND_HITS : hits;\n    const manualHits = Math.min(manualLimit, hits);\n    for (let i = 0; i < manualHits; i += 1) {\n      const targetId = pickManualTarget();\n      if (!targetId) {\n        break;\n      }\n      const targetUnit = units[targetId];\n      if (\n        bodyguardActive &&\n        !used &&\n        targetUnit?.kind === \"champion\" &&\n        forceUnitIds.length > 0\n      ) {\n        const redirectId = pickRandomTarget(forceUnitIds);\n        if (redirectId) {\n          hitsByUnit[redirectId] = (hitsByUnit[redirectId] ?? 0) + 1;\n          used = true;\n          assignedManual += 1;\n          continue;\n        }\n      }\n\n      hitsByUnit[targetId] = (hitsByUnit[targetId] ?? 0) + 1;\n      assignedManual += 1;\n      if (targetUnit?.kind === \"champion\") {\n        const remaining = (championRemaining.get(targetId) ?? 0) - 1;\n        championRemaining.set(targetId, remaining);\n      } else if (targetUnit?.kind === \"force\") {\n        const index = forceTargets.indexOf(targetId);\n        if (index >= 0) {\n          forceTargets.splice(index, 1);\n        }\n      }\n    }\n\n    const remainingHits = hits - assignedManual;\n    for (let i = 0; i < remainingHits; i += 1) {\n      const targetId = pickRandomTarget(unitIds);\n      if (!targetId) {\n        break;\n      }\n      const targetUnit = units[targetId];\n      if (\n        bodyguardActive &&\n        !used &&\n        targetUnit?.kind === \"champion\" &&\n        forceUnitIds.length > 0\n      ) {\n        const redirectId = pickRandomTarget(forceUnitIds);\n        if (redirectId) {\n          hitsByUnit[redirectId] = (hitsByUnit[redirectId] ?? 0) + 1;\n          used = true;\n          continue;\n        }\n      }\n      hitsByUnit[targetId] = (hitsByUnit[targetId] ?? 0) + 1;\n    }\n\n    return { hitsByUnit, nextState, bodyguardUsed: used };\n  }\n\n  const isForce = (unitId: UnitID): boolean => units[unitId]?.kind === \"force\";\n  const preferred =\n    policy === \"forcesFirst\"\n      ? unitIds.filter((unitId) => isForce(unitId))\n      : unitIds.filter((unitId) => !isForce(unitId));\n  const fallback =\n    policy === \"forcesFirst\"\n      ? unitIds.filter((unitId) => !isForce(unitId))\n      : unitIds.filter((unitId) => isForce(unitId));\n\n  for (let i = 0; i < hits; i += 1) {\n    const targetId = pickRandomTarget(preferred.length > 0 ? preferred : fallback);\n    if (!targetId) {\n      break;\n    }\n    hitsByUnit[targetId] = (hitsByUnit[targetId] ?? 0) + 1;\n  }\n\n  return { hitsByUnit, nextState };\n};\n\nconst resolveHits = (\n  unitIds: UnitID[],\n  hitsByUnit: Record<UnitID, number>,\n  units: Record<UnitID, UnitState>\n): HitResolution => {\n  const removedUnitIds: UnitID[] = [];\n  const updatedChampions: Record<UnitID, ChampionUnitState> = {};\n  let bounty = 0;\n  const killedChampions: ChampionUnitState[] = [];\n\n  for (const unitId of unitIds) {\n    const hits = hitsByUnit[unitId] ?? 0;\n    if (hits <= 0) {\n      continue;\n    }\n    const unit = units[unitId];\n    if (!unit) {\n      continue;\n    }\n\n    if (unit.kind === \"force\") {\n      removedUnitIds.push(unitId);\n      continue;\n    }\n\n    const nextHp = unit.hp - hits;\n    if (nextHp <= 0) {\n      removedUnitIds.push(unitId);\n      bounty += unit.bounty;\n      killedChampions.push(unit);\n      continue;\n    }\n\n    updatedChampions[unitId] = {\n      ...unit,\n      hp: nextHp\n    };\n  }\n\n  return { removedUnitIds, updatedChampions, bounty, killedChampions };\n};\n\nconst applyGoldArmorToHits = (\n  state: GameState,\n  hitsByUnit: Record<UnitID, number>\n): { state: GameState; hitsByUnit: Record<UnitID, number> } => {\n  let nextState = state;\n  const nextHits: Record<UnitID, number> = { ...hitsByUnit };\n\n  for (const [unitId, hits] of Object.entries(hitsByUnit)) {\n    if (hits <= 0) {\n      continue;\n    }\n    const unit = nextState.board.units[unitId];\n    if (!unit || unit.kind !== \"champion\") {\n      continue;\n    }\n    const result = applyGoldArmorToDamage(nextState, unitId, hits);\n    nextState = result.state;\n    if (result.remainingDamage !== hits) {\n      nextHits[unitId] = result.remainingDamage;\n    }\n  }\n\n  return { state: nextState, hitsByUnit: nextHits };\n};\n\nconst summarizeUnits = (\n  unitIds: UnitID[],\n  units: Record<UnitID, UnitState>\n): CombatantSummary => {\n  let forces = 0;\n  let champions = 0;\n\n  for (const unitId of unitIds) {\n    const unit = units[unitId];\n    if (!unit) {\n      continue;\n    }\n    if (unit.kind === \"force\") {\n      forces += 1;\n    } else {\n      champions += 1;\n    }\n  }\n\n  return { forces, champions, total: forces + champions };\n};\n\nconst buildSideSummary = (\n  playerId: PlayerID,\n  unitIds: UnitID[],\n  units: Record<UnitID, UnitState>\n): CombatSideSummary => {\n  return {\n    playerId,\n    ...summarizeUnits(unitIds, units)\n  };\n};\n\nconst getRetreatDestination = (hexKey: HexKey, edgeKey: EdgeKey): HexKey | null => {\n  try {\n    const [from, to] = parseEdgeKey(edgeKey);\n    if (from === hexKey) {\n      return to;\n    }\n    if (to === hexKey) {\n      return from;\n    }\n  } catch {\n    return null;\n  }\n  return null;\n};\n\nconst canRetreatToHex = (state: GameState, playerId: PlayerID, hexKey: HexKey): boolean => {\n  const hex = state.board.hexes[hexKey];\n  if (!hex) {\n    return false;\n  }\n  const occupants = getPlayerIdsOnHex(hex);\n  if (occupants.length < 2) {\n    return true;\n  }\n  return occupants.includes(playerId);\n};\n\nconst getRetreatEdgesForPlayer = (\n  state: GameState,\n  hexKey: HexKey,\n  playerId: PlayerID\n): EdgeKey[] => {\n  const player = state.players.find((entry) => entry.id === playerId);\n  if (!player || player.resources.mana < 1) {\n    return [];\n  }\n\n  const edges: EdgeKey[] = [];\n  for (const bridge of Object.values(state.board.bridges)) {\n    if (bridge.locked) {\n      continue;\n    }\n    if (bridge.from !== hexKey && bridge.to !== hexKey) {\n      continue;\n    }\n    const destination = bridge.from === hexKey ? bridge.to : bridge.from;\n    if (!canRetreatToHex(state, playerId, destination)) {\n      continue;\n    }\n    edges.push(bridge.key);\n  }\n\n  return edges;\n};\n\nconst applyRetreatMoves = (\n  state: GameState,\n  hexKey: HexKey,\n  plans: Array<{ playerId: PlayerID; destination: HexKey }>\n): GameState => {\n  let nextState = state;\n\n  for (const plan of plans) {\n    const hex = nextState.board.hexes[hexKey];\n    if (!hex) {\n      continue;\n    }\n    const occupants = hex.occupants[plan.playerId] ?? [];\n    if (occupants.length === 0) {\n      continue;\n    }\n    nextState = {\n      ...nextState,\n      board: moveStack(nextState.board, plan.playerId, hexKey, plan.destination)\n    };\n  }\n\n  return nextState;\n};\n\nconst createEmptyHitSummary = (): HitAssignmentSummary => ({\n  forces: 0,\n  champions: []\n});\n\nconst summarizeHitAssignments = (\n  hitsByUnit: Record<UnitID, number>,\n  units: Record<UnitID, UnitState>\n): HitAssignmentSummary => {\n  let forces = 0;\n  const champions: HitAssignmentSummary[\"champions\"] = [];\n\n  for (const [unitId, hits] of Object.entries(hitsByUnit)) {\n    if (hits <= 0) {\n      continue;\n    }\n    const unit = units[unitId];\n    if (!unit) {\n      continue;\n    }\n    if (unit.kind === \"force\") {\n      forces += hits;\n      continue;\n    }\n    champions.push({\n      unitId,\n      cardDefId: unit.cardDefId,\n      hits,\n      hp: unit.hp,\n      maxHp: unit.maxHp\n    });\n  }\n\n  return { forces, champions };\n};\n\nexport const createCombatRetreatBlock = (\n  state: GameState,\n  hexKey: HexKey\n): BlockState | null => {\n  const hex = state.board.hexes[hexKey];\n  if (!hex) {\n    return null;\n  }\n\n  const participants = getPlayerIdsOnHex(hex);\n  if (participants.length !== 2) {\n    return null;\n  }\n\n  const attackersId = participants[0];\n  const defendersId = participants[1];\n  const availableEdges: Record<PlayerID, EdgeKey[]> = {\n    [attackersId]: getRetreatEdgesForPlayer(state, hexKey, attackersId),\n    [defendersId]: getRetreatEdgesForPlayer(state, hexKey, defendersId)\n  };\n  const eligiblePlayerIds = participants.filter(\n    (playerId) => (availableEdges[playerId] ?? []).length > 0\n  );\n  if (eligiblePlayerIds.length === 0) {\n    return null;\n  }\n\n  const choices = Object.fromEntries(\n    participants.map((playerId) => [playerId, null])\n  ) as Record<PlayerID, CombatRetreatSelection>;\n\n  return {\n    type: \"combat.retreat\",\n    waitingFor: eligiblePlayerIds,\n    payload: {\n      hexKey,\n      attackers: buildSideSummary(\n        attackersId,\n        hex.occupants[attackersId] ?? [],\n        state.board.units\n      ),\n      defenders: buildSideSummary(\n        defendersId,\n        hex.occupants[defendersId] ?? [],\n        state.board.units\n      ),\n      eligiblePlayerIds,\n      availableEdges,\n      choices\n    }\n  };\n};\n\nexport const resolveBattleAtHex = (\n  state: GameState,\n  hexKey: HexKey,\n  retreatChoices?: Record<PlayerID, EdgeKey>\n): GameState => {\n  const hex = state.board.hexes[hexKey];\n  if (!hex) {\n    return state;\n  }\n\n  const participants = getPlayerIdsOnHex(hex);\n  if (participants.length !== 2) {\n    return state;\n  }\n\n  const retreatPlans: Array<{ playerId: PlayerID; destination: HexKey }> = [];\n  if (retreatChoices) {\n    for (const playerId of participants) {\n      const edgeKey = retreatChoices[playerId];\n      if (!edgeKey) {\n        continue;\n      }\n      const bridge = state.board.bridges[edgeKey];\n      if (!bridge || bridge.locked) {\n        continue;\n      }\n      const destination = getRetreatDestination(hexKey, edgeKey);\n      if (!destination || !canRetreatToHex(state, playerId, destination)) {\n        continue;\n      }\n      const player = state.players.find((entry) => entry.id === playerId);\n      if (!player || player.resources.mana < 1) {\n        continue;\n      }\n      retreatPlans.push({ playerId, destination });\n    }\n  }\n\n  let nextState: GameState = state;\n  if (retreatPlans.length > 0) {\n    const retreating = new Set(retreatPlans.map((plan) => plan.playerId));\n    nextState = {\n      ...nextState,\n      players: nextState.players.map((player) =>\n        retreating.has(player.id)\n          ? {\n              ...player,\n              resources: {\n                ...player.resources,\n                mana: Math.max(0, player.resources.mana - 1)\n              }\n            }\n          : player\n      )\n    };\n  }\n\n  const initialAttackers = hex.occupants[participants[0]] ?? [];\n  const initialDefenders = hex.occupants[participants[1]] ?? [];\n  nextState = emit(nextState, {\n    type: \"combat.start\",\n    payload: {\n      hexKey,\n      attackers: {\n        playerId: participants[0],\n        ...summarizeUnits(initialAttackers, nextState.board.units)\n      },\n      defenders: {\n        playerId: participants[1],\n        ...summarizeUnits(initialDefenders, nextState.board.units)\n      }\n    }\n  });\n  let nextBoard = nextState.board;\n  let nextUnits = nextState.board.units;\n  let rngState = nextState.rngState;\n  let staleRounds = 0;\n  let endReason: CombatEndReason = \"eliminated\";\n  let battleRound = 0;\n  const retreatAfterRound = retreatPlans.length > 0;\n  let bodyguardUsed: Record<CombatSide, boolean> = {\n    attackers: false,\n    defenders: false\n  };\n\n  while (true) {\n    const currentHex = nextBoard.hexes[hexKey];\n    if (!currentHex) {\n      return nextState;\n    }\n\n    let attackers = currentHex.occupants[participants[0]] ?? [];\n    let defenders = currentHex.occupants[participants[1]] ?? [];\n    if (attackers.length === 0 || defenders.length === 0) {\n      endReason = \"eliminated\";\n      break;\n    }\n\n    battleRound += 1;\n    const contextBase: CombatContext = {\n      hexKey,\n      attackerPlayerId: participants[0],\n      defenderPlayerId: participants[1],\n      round: battleRound\n    };\n    let modifiers = getCombatModifiers(nextState, hexKey);\n\n    const roundContext: CombatRoundContext = {\n      ...contextBase,\n      attackers,\n      defenders\n    };\n    nextState = runModifierEvents(\n      nextState,\n      modifiers,\n      (hooks) => hooks.beforeCombatRound,\n      roundContext\n    );\n    nextBoard = nextState.board;\n    nextUnits = nextState.board.units;\n    rngState = nextState.rngState;\n\n    const afterRoundHex = nextBoard.hexes[hexKey];\n    if (!afterRoundHex) {\n      return nextState;\n    }\n    attackers = afterRoundHex.occupants[participants[0]] ?? [];\n    defenders = afterRoundHex.occupants[participants[1]] ?? [];\n    if (attackers.length === 0 || defenders.length === 0) {\n      endReason = \"eliminated\";\n      break;\n    }\n\n    modifiers = getCombatModifiers(nextState, hexKey);\n\n    const attackersCanHit = attackers.some((unitId) =>\n      unitCanHit(nextState, modifiers, contextBase, \"attackers\", unitId, nextUnits[unitId])\n    );\n    const defendersCanHit = defenders.some((unitId) =>\n      unitCanHit(nextState, modifiers, contextBase, \"defenders\", unitId, nextUnits[unitId])\n    );\n    if (!attackersCanHit && !defendersCanHit) {\n      if (!retreatAfterRound) {\n        endReason = \"noHits\";\n        break;\n      }\n    }\n\n    const attackerRoll = rollHitsForUnits(\n      attackers,\n      nextUnits,\n      nextState,\n      modifiers,\n      contextBase,\n      \"attackers\",\n      rngState\n    );\n    rngState = attackerRoll.nextState;\n    const defenderRoll = rollHitsForUnits(\n      defenders,\n      nextUnits,\n      nextState,\n      modifiers,\n      contextBase,\n      \"defenders\",\n      rngState\n    );\n    rngState = defenderRoll.nextState;\n\n    const roundPayloadBase = {\n      hexKey,\n      round: battleRound,\n      attackers: {\n        playerId: participants[0],\n        dice: attackerRoll.rolls,\n        hits: attackerRoll.hits,\n        units: attackerRoll.unitRolls\n      },\n      defenders: {\n        playerId: participants[1],\n        dice: defenderRoll.rolls,\n        hits: defenderRoll.hits,\n        units: defenderRoll.unitRolls\n      }\n    };\n\n    if (attackerRoll.hits + defenderRoll.hits === 0) {\n      staleRounds += 1;\n      nextState = emit(nextState, {\n        type: \"combat.round\",\n        payload: {\n          ...roundPayloadBase,\n          hitsToAttackers: createEmptyHitSummary(),\n          hitsToDefenders: createEmptyHitSummary()\n        }\n      });\n      if (retreatAfterRound) {\n        nextState = applyRetreatMoves(nextState, hexKey, retreatPlans);\n        nextBoard = nextState.board;\n        nextUnits = nextState.board.units;\n        endReason = \"retreated\";\n        break;\n      }\n      if (staleRounds >= MAX_STALE_COMBAT_ROUNDS) {\n        endReason = \"stale\";\n        break;\n      }\n      continue;\n    }\n    staleRounds = 0;\n\n    const defenderTacticalSource =\n      attackerRoll.hits > 0\n        ? findTacticalHandSource(nextState, hexKey, participants[0])\n        : null;\n    const attackerTacticalSource =\n      defenderRoll.hits > 0\n        ? findTacticalHandSource(nextState, hexKey, participants[1])\n        : null;\n\n    const defenderAssignmentContext: CombatAssignmentContext = {\n      ...contextBase,\n      targetSide: \"defenders\",\n      targetUnitIds: defenders,\n      hits: attackerRoll.hits\n    };\n    const defenderBasePolicy = getHitAssignmentPolicy(\n      nextState,\n      modifiers,\n      defenderAssignmentContext\n    );\n    const defenderPolicy = defenderTacticalSource ? \"tacticalHand\" : defenderBasePolicy;\n    const defenderBodyguardActive =\n      defenderBasePolicy === \"bodyguard\" ||\n      hasBodyguardModifier(modifiers, defenders, nextUnits);\n    const assignedToDefenders = assignHits(\n      defenders,\n      attackerRoll.hits,\n      defenderPolicy,\n      nextUnits,\n      rngState,\n      bodyguardUsed.defenders,\n      defenderBodyguardActive\n    );\n    rngState = assignedToDefenders.nextState;\n    bodyguardUsed.defenders =\n      assignedToDefenders.bodyguardUsed ?? bodyguardUsed.defenders;\n    const attackerAssignmentContext: CombatAssignmentContext = {\n      ...contextBase,\n      targetSide: \"attackers\",\n      targetUnitIds: attackers,\n      hits: defenderRoll.hits\n    };\n    const attackerBasePolicy = getHitAssignmentPolicy(\n      nextState,\n      modifiers,\n      attackerAssignmentContext\n    );\n    const attackerPolicy = attackerTacticalSource ? \"tacticalHand\" : attackerBasePolicy;\n    const attackerBodyguardActive =\n      attackerBasePolicy === \"bodyguard\" ||\n      hasBodyguardModifier(modifiers, attackers, nextUnits);\n    const assignedToAttackers = assignHits(\n      attackers,\n      defenderRoll.hits,\n      attackerPolicy,\n      nextUnits,\n      rngState,\n      bodyguardUsed.attackers,\n      attackerBodyguardActive\n    );\n    rngState = assignedToAttackers.nextState;\n    bodyguardUsed.attackers =\n      assignedToAttackers.bodyguardUsed ?? bodyguardUsed.attackers;\n\n    if (defenderTacticalSource) {\n      nextState = consumeChampionAbilityUse(\n        nextState,\n        defenderTacticalSource,\n        TACTICAL_HAND_KEY\n      );\n      nextUnits = nextState.board.units;\n    }\n    if (attackerTacticalSource) {\n      nextState = consumeChampionAbilityUse(\n        nextState,\n        attackerTacticalSource,\n        TACTICAL_HAND_KEY\n      );\n      nextUnits = nextState.board.units;\n    }\n\n    const defenderArmor = applyGoldArmorToHits(nextState, assignedToDefenders.hitsByUnit);\n    nextState = defenderArmor.state;\n    const defenderHitsByUnit = defenderArmor.hitsByUnit;\n    const attackerArmor = applyGoldArmorToHits(nextState, assignedToAttackers.hitsByUnit);\n    nextState = attackerArmor.state;\n    const attackerHitsByUnit = attackerArmor.hitsByUnit;\n\n    nextState = emit(nextState, {\n      type: \"combat.round\",\n      payload: {\n        ...roundPayloadBase,\n        hitsToDefenders: summarizeHitAssignments(\n          defenderHitsByUnit,\n          nextUnits\n        ),\n        hitsToAttackers: summarizeHitAssignments(\n          attackerHitsByUnit,\n          nextUnits\n        )\n      }\n    });\n\n    const attackerHits = resolveHits(attackers, attackerHitsByUnit, nextUnits);\n    const defenderHits = resolveHits(defenders, defenderHitsByUnit, nextUnits);\n\n    const removedSet = new Set<UnitID>([\n      ...attackerHits.removedUnitIds,\n      ...defenderHits.removedUnitIds\n    ]);\n    const removedChampionIds = [\n      ...attackerHits.killedChampions.map((unit) => unit.id),\n      ...defenderHits.killedChampions.map((unit) => unit.id)\n    ];\n    const uniqueChampionIds = [...new Set(removedChampionIds)];\n\n    const updatedUnits: Record<UnitID, UnitState> = { ...nextUnits };\n    for (const unitId of removedSet) {\n      delete updatedUnits[unitId];\n    }\n    for (const [unitId, champion] of Object.entries(attackerHits.updatedChampions)) {\n      updatedUnits[unitId] = champion;\n    }\n    for (const [unitId, champion] of Object.entries(defenderHits.updatedChampions)) {\n      updatedUnits[unitId] = champion;\n    }\n\n    const updatedHex = {\n      ...currentHex,\n      occupants: {\n        ...currentHex.occupants,\n        [participants[0]]: attackers.filter((unitId) => !removedSet.has(unitId)),\n        [participants[1]]: defenders.filter((unitId) => !removedSet.has(unitId))\n      }\n    };\n\n    nextBoard = {\n      ...nextBoard,\n      units: updatedUnits,\n      hexes: {\n        ...nextBoard.hexes,\n        [hexKey]: updatedHex\n      }\n    };\n    nextUnits = updatedUnits;\n    nextState = {\n      ...nextState,\n      board: nextBoard,\n      rngState\n    };\n    if (uniqueChampionIds.length > 0) {\n      nextState = removeChampionModifiers(nextState, uniqueChampionIds);\n    }\n\n    const killedChampions = [\n      ...defenderHits.killedChampions,\n      ...attackerHits.killedChampions\n    ];\n    if (killedChampions.length > 0) {\n      nextState = applyChampionDeathEffects(nextState, killedChampions);\n    }\n\n    if (defenderHits.killedChampions.length > 0) {\n      nextState = applyChampionKillRewards(nextState, {\n        killerPlayerId: participants[0],\n        victimPlayerId: participants[1],\n        killedChampions: defenderHits.killedChampions,\n        bounty: defenderHits.bounty,\n        hexKey,\n        source: \"battle\"\n      });\n    }\n    if (attackerHits.killedChampions.length > 0) {\n      nextState = applyChampionKillRewards(nextState, {\n        killerPlayerId: participants[1],\n        victimPlayerId: participants[0],\n        killedChampions: attackerHits.killedChampions,\n        bounty: attackerHits.bounty,\n        hexKey,\n        source: \"battle\"\n      });\n    }\n\n    nextBoard = nextState.board;\n    nextUnits = nextState.board.units;\n\n    const postRoundHex = nextBoard.hexes[hexKey];\n    const remainingAttackers = postRoundHex?.occupants[participants[0]] ?? [];\n    const remainingDefenders = postRoundHex?.occupants[participants[1]] ?? [];\n    if (remainingAttackers.length === 0 || remainingDefenders.length === 0) {\n      endReason = \"eliminated\";\n      break;\n    }\n\n    if (retreatAfterRound) {\n      nextState = applyRetreatMoves(nextState, hexKey, retreatPlans);\n      nextBoard = nextState.board;\n      nextUnits = nextState.board.units;\n      endReason = \"retreated\";\n      break;\n    }\n  }\n\n  const finalHex = nextBoard.hexes[hexKey];\n  const finalAttackers = finalHex?.occupants[participants[0]] ?? [];\n  const finalDefenders = finalHex?.occupants[participants[1]] ?? [];\n  const winnerPlayerId =\n    finalAttackers.length > 0 && finalDefenders.length === 0\n      ? participants[0]\n      : finalDefenders.length > 0 && finalAttackers.length === 0\n        ? participants[1]\n        : null;\n\n  const endContext: CombatEndContext = {\n    hexKey,\n    attackerPlayerId: participants[0],\n    defenderPlayerId: participants[1],\n    round: battleRound,\n    reason: endReason,\n    winnerPlayerId,\n    attackers: finalAttackers,\n    defenders: finalDefenders\n  };\n\n  nextState = emit(nextState, {\n    type: \"combat.end\",\n    payload: {\n      hexKey,\n      reason: endReason,\n      winnerPlayerId,\n      attackers: {\n        playerId: participants[0],\n        ...summarizeUnits(finalAttackers, nextUnits)\n      },\n      defenders: {\n        playerId: participants[1],\n        ...summarizeUnits(finalDefenders, nextUnits)\n      }\n    }\n  });\n\n  nextState = runModifierEvents(\n    nextState,\n    getCombatModifiers(nextState, hexKey),\n    (hooks) => hooks.afterBattle,\n    endContext\n  );\n\n  return expireEndOfBattleModifiers(nextState, hexKey);\n};\n\nexport const applyCombatRetreatChoice = (\n  state: GameState,\n  playerId: PlayerID,\n  payload: { hexKey: HexKey; edgeKey: EdgeKey | null }\n): GameState => {\n  const block = state.blocks;\n  if (!block || block.type !== \"combat.retreat\") {\n    return state;\n  }\n  if (block.payload.hexKey !== payload.hexKey) {\n    return state;\n  }\n  if (!block.waitingFor.includes(playerId)) {\n    return state;\n  }\n  if (!block.payload.eligiblePlayerIds.includes(playerId)) {\n    return state;\n  }\n\n  let choice: CombatRetreatSelection = \"stay\";\n  if (payload.edgeKey) {\n    const options = block.payload.availableEdges[playerId] ?? [];\n    if (!options.includes(payload.edgeKey)) {\n      return state;\n    }\n    choice = payload.edgeKey;\n  }\n\n  return {\n    ...state,\n    blocks: {\n      ...block,\n      waitingFor: block.waitingFor.filter((id) => id !== playerId),\n      payload: {\n        ...block.payload,\n        choices: {\n          ...block.payload.choices,\n          [playerId]: choice\n        }\n      }\n    }\n  };\n};\n\nexport const resolveCombatRetreatBlock = (\n  state: GameState,\n  block: Extract<BlockState, { type: \"combat.retreat\" }>\n): GameState => {\n  const retreatChoices: Record<PlayerID, EdgeKey> = {};\n  for (const [playerId, choice] of Object.entries(block.payload.choices)) {\n    if (!choice || choice === \"stay\") {\n      continue;\n    }\n    retreatChoices[playerId] = choice;\n  }\n\n  return resolveBattleAtHex(state, block.payload.hexKey, retreatChoices);\n};\n\nexport const resolveImmediateBattles = (state: GameState): GameState => {\n  if (state.blocks?.type === \"combat.retreat\") {\n    return state;\n  }\n\n  const contested = Object.values(state.board.hexes)\n    .filter((hex) => hex.tile !== \"capital\" && isContestedHex(hex))\n    .map((hex) => hex.key)\n    .sort(compareHexKeys);\n\n  let nextState = state;\n  for (const hexKey of contested) {\n    const block = createCombatRetreatBlock(nextState, hexKey);\n    if (block) {\n      return {\n        ...nextState,\n        blocks: block\n      };\n    }\n    nextState = resolveBattleAtHex(nextState, hexKey);\n  }\n\n  return nextState;\n};\n\nexport const resolveSieges = (state: GameState): GameState => {\n  if (state.blocks?.type === \"combat.retreat\") {\n    return state;\n  }\n\n  const seatIndexByPlayer = new Map<PlayerID, number>();\n  for (const player of state.players) {\n    seatIndexByPlayer.set(player.id, player.seatIndex);\n  }\n\n  const contestedCapitals = Object.values(state.board.hexes)\n    .filter((hex) => hex.tile === \"capital\" && isContestedHex(hex) && hex.ownerPlayerId)\n    .map((hex) => ({\n      key: hex.key,\n      defenderId: hex.ownerPlayerId as PlayerID\n    }))\n    .filter((entry) => seatIndexByPlayer.has(entry.defenderId))\n    .sort((a, b) => {\n      const seatA = seatIndexByPlayer.get(a.defenderId) ?? 0;\n      const seatB = seatIndexByPlayer.get(b.defenderId) ?? 0;\n      if (seatA !== seatB) {\n        return seatA - seatB;\n      }\n      return compareHexKeys(a.key, b.key);\n    });\n\n  let nextState = state;\n  for (const entry of contestedCapitals) {\n    const block = createCombatRetreatBlock(nextState, entry.key);\n    if (block) {\n      return {\n        ...nextState,\n        blocks: block\n      };\n    }\n    nextState = resolveBattleAtHex(nextState, entry.key);\n  }\n\n  return nextState;\n};\n", "import { areAdjacent, neighborHexKeys, parseEdgeKey, parseHexKey } from \"@bridgefront/shared\";\n\nimport type {\n  ActionDeclaration,\n  ActionResolutionEntry,\n  ActionResolutionState,\n  BasicAction,\n  BlockState,\n  CardPlayDeclaration,\n  GameState,\n  PlayerID,\n  PlayerState\n} from \"./types\";\nimport { getBridgeKey, isOccupiedByPlayer } from \"./board\";\nimport { addCardToBurned, addCardToDiscardPile, removeCardFromHand } from \"./cards\";\nimport { resolveCardEffects, isCardPlayable, validateMovePath } from \"./card-effects\";\nimport { resolveImmediateBattles } from \"./combat\";\nimport type { CardDef } from \"./content/cards\";\nimport { getCardDef } from \"./content/cards\";\nimport { resolveCapitalDeployHex } from \"./deploy-utils\";\nimport { emit } from \"./events\";\nimport { getDeployForcesCount, runMoveEvents } from \"./modifiers\";\nimport { incrementCardsPlayedThisRound, markPlayerMovedThisRound } from \"./player-flags\";\nimport { addForcesToHex, countPlayerChampions, moveStack, selectMovingUnits } from \"./units\";\n\nconst BASIC_ACTION_MANA_COST = 1;\nconst REINFORCE_GOLD_COST = 1;\n\ntype ActionCost = {\n  mana: number;\n  gold: number;\n};\n\ntype BuildBridgePlan = {\n  from: string;\n  to: string;\n  key: string;\n};\n\nconst getCardDefinition = (state: GameState, cardInstanceId: string) => {\n  const instance = state.cardsByInstanceId[cardInstanceId];\n  if (!instance) {\n    return null;\n  }\n  return getCardDef(instance.defId) ?? null;\n};\n\nconst getChampionGoldCost = (card: CardDef, championCount: number): number => {\n  if (card.type !== \"Champion\" || !card.champion) {\n    return 0;\n  }\n  const costs = card.champion.goldCostByChampionCount;\n  if (!Array.isArray(costs) || costs.length === 0) {\n    return 0;\n  }\n  const index = Math.min(Math.max(0, championCount), costs.length - 1);\n  const cost = Number(costs[index]);\n  return Number.isFinite(cost) && cost > 0 ? cost : 0;\n};\n\nconst getDeclarationCost = (\n  state: GameState,\n  playerId: PlayerID,\n  declaration: ActionDeclaration\n): ActionCost => {\n  if (declaration.kind === \"card\") {\n    const card = getCardDefinition(state, declaration.cardInstanceId);\n    if (!card) {\n      return { mana: 0, gold: 0 };\n    }\n    const championGold =\n      card.type === \"Champion\"\n        ? getChampionGoldCost(card, countPlayerChampions(state.board, playerId))\n        : 0;\n    return { mana: card.cost.mana, gold: (card.cost.gold ?? 0) + championGold };\n  }\n\n  if (declaration.kind === \"basic\") {\n    if (declaration.action.kind === \"capitalReinforce\") {\n      return { mana: BASIC_ACTION_MANA_COST, gold: REINFORCE_GOLD_COST };\n    }\n\n    return { mana: BASIC_ACTION_MANA_COST, gold: 0 };\n  }\n\n  return { mana: 0, gold: 0 };\n};\n\nconst getBuildBridgePlan = (\n  state: GameState,\n  playerId: PlayerID,\n  edgeKey: string\n): BuildBridgePlan | null => {\n  let rawA: string;\n  let rawB: string;\n  try {\n    [rawA, rawB] = parseEdgeKey(edgeKey);\n  } catch {\n    return null;\n  }\n\n  const fromHex = state.board.hexes[rawA];\n  const toHex = state.board.hexes[rawB];\n  if (!fromHex || !toHex) {\n    return null;\n  }\n\n  try {\n    if (!areAdjacent(parseHexKey(rawA), parseHexKey(rawB))) {\n      return null;\n    }\n  } catch {\n    return null;\n  }\n\n  if (!isOccupiedByPlayer(fromHex, playerId) && !isOccupiedByPlayer(toHex, playerId)) {\n    return null;\n  }\n\n  const canonicalKey = getBridgeKey(rawA, rawB);\n  if (state.board.bridges[canonicalKey]) {\n    return null;\n  }\n\n  return { from: rawA, to: rawB, key: canonicalKey };\n};\n\nconst canMarch = (\n  state: GameState,\n  playerId: PlayerID,\n  from: string,\n  to: string,\n  forceCount?: number,\n  includeChampions?: boolean\n): boolean => {\n  const fromHex = state.board.hexes[from];\n  const toHex = state.board.hexes[to];\n  if (!fromHex || !toHex) {\n    return false;\n  }\n\n  if (!isOccupiedByPlayer(fromHex, playerId)) {\n    return false;\n  }\n\n  const options = { maxDistance: 1, requiresBridge: true, requireStartOccupied: true };\n\n  if (\n    validateMovePath(state, playerId, [from, to], {\n      ...options,\n      forceCount,\n      includeChampions\n    })\n  ) {\n    return true;\n  }\n\n  let neighbors: string[];\n  try {\n    neighbors = neighborHexKeys(from);\n  } catch {\n    return false;\n  }\n\n  for (const mid of neighbors) {\n    if (!state.board.hexes[mid]) {\n      continue;\n    }\n    try {\n      if (!areAdjacent(parseHexKey(mid), parseHexKey(to))) {\n        continue;\n      }\n    } catch {\n      continue;\n    }\n    if (\n      validateMovePath(state, playerId, [from, mid, to], {\n        ...options,\n        forceCount,\n        includeChampions\n      })\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst getCapitalReinforceHex = (\n  state: GameState,\n  playerId: PlayerID,\n  preferredHex?: string\n): string | null => resolveCapitalDeployHex(state, playerId, preferredHex ?? null);\n\nconst isBasicActionValid = (state: GameState, playerId: PlayerID, action: BasicAction): boolean => {\n  switch (action.kind) {\n    case \"buildBridge\":\n      return Boolean(getBuildBridgePlan(state, playerId, action.edgeKey));\n    case \"march\":\n      return canMarch(\n        state,\n        playerId,\n        action.from,\n        action.to,\n        action.forceCount,\n        action.includeChampions\n      );\n    case \"capitalReinforce\":\n      return Boolean(getCapitalReinforceHex(state, playerId, action.hexKey));\n    default: {\n      const _exhaustive: never = action;\n      return _exhaustive;\n    }\n  }\n};\n\nconst isCardDeclarationValid = (\n  state: GameState,\n  player: PlayerState,\n  declaration: CardPlayDeclaration\n): boolean => {\n  const card = getCardDefinition(state, declaration.cardInstanceId);\n  if (!card) {\n    return false;\n  }\n\n  if (!player.deck.hand.includes(declaration.cardInstanceId)) {\n    return false;\n  }\n\n  return isCardPlayable(state, player.id, card, declaration.targets);\n};\n\nconst isDeclarationValid = (\n  state: GameState,\n  player: PlayerState,\n  declaration: ActionDeclaration\n): boolean => {\n  if (declaration.kind === \"done\") {\n    return true;\n  }\n\n  if (declaration.kind === \"basic\") {\n    return isBasicActionValid(state, player.id, declaration.action);\n  }\n\n  if (declaration.kind === \"card\") {\n    return isCardDeclarationValid(state, player, declaration);\n  }\n\n  return false;\n};\n\nconst getLeadOrderedPlayers = (players: PlayerState[], leadSeatIndex: number): PlayerState[] => {\n  const ordered = [...players].sort((a, b) => a.seatIndex - b.seatIndex);\n  const leadIndex = ordered.findIndex((player) => player.seatIndex === leadSeatIndex);\n  if (leadIndex <= 0) {\n    return ordered;\n  }\n  return [...ordered.slice(leadIndex), ...ordered.slice(0, leadIndex)];\n};\n\nconst getBasicActionOrderedPlayers = (\n  state: GameState,\n  leadOrderedPlayers: PlayerState[]\n): PlayerState[] => {\n  const factionOrder = state.config.basicActionFactionOrder;\n  if (!Array.isArray(factionOrder) || factionOrder.length === 0) {\n    return leadOrderedPlayers;\n  }\n\n  const factionPriority = new Map(\n    factionOrder.map((factionId, index) => [factionId, index])\n  );\n  const leadIndex = new Map(leadOrderedPlayers.map((player, index) => [player.id, index]));\n\n  return [...leadOrderedPlayers].sort((a, b) => {\n    const aPriority = factionPriority.get(a.factionId) ?? Number.MAX_SAFE_INTEGER;\n    const bPriority = factionPriority.get(b.factionId) ?? Number.MAX_SAFE_INTEGER;\n    if (aPriority !== bPriority) {\n      return aPriority - bPriority;\n    }\n    return (leadIndex.get(a.id) ?? 0) - (leadIndex.get(b.id) ?? 0);\n  });\n};\n\nconst finalizeCardPlay = (\n  state: GameState,\n  playerId: PlayerID,\n  cardInstanceId: string,\n  card: CardDef | null\n): GameState => {\n  if (card && (card.burn || card.type === \"Champion\")) {\n    return addCardToBurned(state, playerId, cardInstanceId);\n  }\n  return addCardToDiscardPile(state, playerId, cardInstanceId);\n};\n\nexport const createActionStepBlock = (state: GameState): BlockState | null => {\n  const eligible = state.players\n    .filter((player) => player.resources.mana >= 1 && !player.doneThisRound)\n    .map((player) => player.id);\n\n  if (eligible.length === 0) {\n    return null;\n  }\n\n  return {\n    type: \"actionStep.declarations\",\n    waitingFor: eligible,\n    payload: {\n      declarations: Object.fromEntries(eligible.map((playerId) => [playerId, null]))\n    }\n  };\n};\n\nconst buildActionResolutionEntries = (\n  state: GameState,\n  declarations: Record<PlayerID, ActionDeclaration | null>\n): ActionResolutionEntry[] => {\n  const orderedPlayers = getLeadOrderedPlayers(state.players, state.leadSeatIndex);\n  const basicActionOrder = getBasicActionOrderedPlayers(state, orderedPlayers);\n  const leadOrderIndex = new Map(\n    orderedPlayers.map((player, index) => [player.id, index])\n  );\n\n  const cardPlays: Array<{\n    player: PlayerState;\n    declaration: CardPlayDeclaration;\n    card: CardDef | null;\n  }> = [];\n\n  for (const player of orderedPlayers) {\n    const declaration = declarations[player.id];\n    if (declaration?.kind === \"card\") {\n      cardPlays.push({\n        player,\n        declaration,\n        card: getCardDefinition(state, declaration.cardInstanceId)\n      });\n    }\n  }\n\n  const orderedCardPlays = [...cardPlays].sort((a, b) => {\n    const aInitiative = a.card?.initiative ?? Number.MAX_SAFE_INTEGER;\n    const bInitiative = b.card?.initiative ?? Number.MAX_SAFE_INTEGER;\n    if (aInitiative !== bInitiative) {\n      return aInitiative - bInitiative;\n    }\n    return (leadOrderIndex.get(a.player.id) ?? 0) - (leadOrderIndex.get(b.player.id) ?? 0);\n  });\n\n  const entries: ActionResolutionEntry[] = [];\n  for (const entry of orderedCardPlays) {\n    entries.push({\n      kind: \"card\",\n      playerId: entry.player.id,\n      cardInstanceId: entry.declaration.cardInstanceId,\n      targets: entry.declaration.targets ?? null\n    });\n  }\n\n  for (const player of basicActionOrder) {\n    const declaration = declarations[player.id];\n    if (declaration?.kind === \"basic\") {\n      entries.push({ kind: \"basic\", playerId: player.id, action: declaration.action });\n    }\n  }\n\n  for (const player of orderedPlayers) {\n    const declaration = declarations[player.id];\n    if (declaration?.kind === \"done\") {\n      entries.push({ kind: \"done\", playerId: player.id });\n    }\n  }\n\n  return entries;\n};\n\nexport const createActionResolutionState = (\n  state: GameState,\n  declarations: Record<PlayerID, ActionDeclaration | null>\n): ActionResolutionState => {\n  return {\n    entries: buildActionResolutionEntries(state, declarations),\n    index: 0\n  };\n};\n\nexport const applyActionDeclaration = (\n  state: GameState,\n  declaration: ActionDeclaration,\n  playerId: PlayerID\n): GameState => {\n  if (state.phase !== \"round.action\") {\n    return state;\n  }\n\n  const block = state.blocks;\n  if (!block || block.type !== \"actionStep.declarations\") {\n    return state;\n  }\n\n  if (!block.waitingFor.includes(playerId)) {\n    return state;\n  }\n\n  if (block.payload.declarations[playerId]) {\n    return state;\n  }\n\n  const player = state.players.find((entry) => entry.id === playerId);\n  if (!player) {\n    return state;\n  }\n\n  if (!isDeclarationValid(state, player, declaration)) {\n    return state;\n  }\n\n  const cost = getDeclarationCost(state, playerId, declaration);\n  if (player.resources.mana < cost.mana || player.resources.gold < cost.gold) {\n    return state;\n  }\n\n  const nextPlayers = state.players.map((entry) =>\n    entry.id === playerId\n      ? {\n          ...entry,\n          resources: {\n            gold: entry.resources.gold - cost.gold,\n            mana: entry.resources.mana - cost.mana\n          }\n        }\n      : entry\n  );\n\n  let nextState: GameState = {\n    ...state,\n    players: nextPlayers,\n    blocks: {\n      ...block,\n      waitingFor: block.waitingFor.filter((id) => id !== playerId),\n      payload: {\n        ...block.payload,\n        declarations: {\n          ...block.payload.declarations,\n          [playerId]: declaration\n        }\n      }\n    }\n  };\n\n  if (declaration.kind === \"card\") {\n    nextState = removeCardFromHand(nextState, playerId, declaration.cardInstanceId);\n    nextState = incrementCardsPlayedThisRound(nextState, playerId);\n  }\n\n  return nextState;\n};\n\nexport const resolveActionStep = (\n  state: GameState,\n  declarations: Record<PlayerID, ActionDeclaration | null>\n): GameState => {\n  const entries = buildActionResolutionEntries(state, declarations);\n  let nextState = state;\n  for (const entry of entries) {\n    nextState = resolveActionEntry(nextState, entry);\n    if (nextState.blocks?.type === \"combat.retreat\") {\n      return nextState;\n    }\n  }\n\n  return nextState;\n};\n\nconst resolveBasicAction = (state: GameState, playerId: PlayerID, action: BasicAction): GameState => {\n  switch (action.kind) {\n    case \"buildBridge\":\n      return resolveBuildBridge(state, playerId, action.edgeKey);\n    case \"march\":\n      return resolveMarch(\n        state,\n        playerId,\n        action.from,\n        action.to,\n        action.forceCount,\n        action.includeChampions\n      );\n    case \"capitalReinforce\":\n      return resolveCapitalReinforce(state, playerId, action.hexKey);\n    default: {\n      const _exhaustive: never = action;\n      return state;\n    }\n  }\n};\n\nfunction resolveActionEntry(state: GameState, entry: ActionResolutionEntry): GameState {\n  if (entry.kind === \"card\") {\n    const card = getCardDefinition(state, entry.cardInstanceId);\n    const cardId = card?.id ?? \"unknown\";\n    let nextState = emit(state, {\n      type: `action.card.${cardId}`,\n      payload: {\n        playerId: entry.playerId,\n        cardId,\n        targets: entry.targets ?? null\n      }\n    });\n    if (card) {\n      nextState = resolveCardEffects(nextState, entry.playerId, card, entry.targets ?? null);\n    }\n    nextState = finalizeCardPlay(nextState, entry.playerId, entry.cardInstanceId, card);\n    return resolveImmediateBattles(nextState);\n  }\n\n  if (entry.kind === \"basic\") {\n    let nextState = emit(state, {\n      type: `action.basic.${entry.action.kind}`,\n      payload: { playerId: entry.playerId, action: entry.action }\n    });\n    nextState = resolveBasicAction(nextState, entry.playerId, entry.action);\n    return resolveImmediateBattles(nextState);\n  }\n\n  let nextState = emit(state, {\n    type: \"action.done\",\n    payload: { playerId: entry.playerId }\n  });\n  nextState = {\n    ...nextState,\n    players: nextState.players.map((player) =>\n      player.id === entry.playerId ? { ...player, doneThisRound: true } : player\n    )\n  };\n  return nextState;\n}\n\nexport const resolveNextActionEntry = (state: GameState): GameState => {\n  const pending = state.actionResolution;\n  if (!pending) {\n    return state;\n  }\n  const entry = pending.entries[pending.index];\n  if (!entry) {\n    return {\n      ...state,\n      actionResolution: undefined\n    };\n  }\n\n  const nextState = resolveActionEntry(state, entry);\n  const nextIndex = pending.index + 1;\n  if (nextIndex >= pending.entries.length) {\n    return {\n      ...nextState,\n      actionResolution: undefined\n    };\n  }\n\n  return {\n    ...nextState,\n    actionResolution: {\n      entries: pending.entries,\n      index: nextIndex\n    }\n  };\n};\n\nconst resolveBuildBridge = (state: GameState, playerId: PlayerID, edgeKey: string): GameState => {\n  const plan = getBuildBridgePlan(state, playerId, edgeKey);\n  if (!plan) {\n    return state;\n  }\n\n  return {\n    ...state,\n    board: {\n      ...state.board,\n      bridges: {\n        ...state.board.bridges,\n        [plan.key]: {\n          key: plan.key,\n          from: plan.from,\n          to: plan.to,\n          ownerPlayerId: playerId\n        }\n      }\n    }\n  };\n};\n\nconst resolveMarch = (\n  state: GameState,\n  playerId: PlayerID,\n  from: string,\n  to: string,\n  forceCount?: number,\n  includeChampions?: boolean\n): GameState => {\n  if (!canMarch(state, playerId, from, to, forceCount, includeChampions)) {\n    return state;\n  }\n\n  const movingUnitIds = selectMovingUnits(\n    state.board,\n    playerId,\n    from,\n    forceCount,\n    includeChampions\n  );\n  if (movingUnitIds.length === 0) {\n    return state;\n  }\n\n  let nextState: GameState = {\n    ...state,\n    board: moveStack(state.board, playerId, from, to, forceCount, includeChampions)\n  };\n  nextState = runMoveEvents(nextState, { playerId, from, to, path: [from, to], movingUnitIds });\n  return markPlayerMovedThisRound(nextState, playerId);\n};\n\nconst resolveCapitalReinforce = (\n  state: GameState,\n  playerId: PlayerID,\n  preferredHex?: string\n): GameState => {\n  const capitalHex = getCapitalReinforceHex(state, playerId, preferredHex);\n  if (!capitalHex) {\n    return state;\n  }\n\n  const baseCount = 1;\n  const count = getDeployForcesCount(state, { playerId, hexKey: capitalHex, baseCount }, baseCount);\n\n  return {\n    ...state,\n    board: addForcesToHex(state.board, playerId, capitalHex, count)\n  };\n};\n", "import { rollDie, shuffle } from \"@bridgefront/shared\";\n\nimport { MARKET_DECKS_BY_AGE } from \"./content/market-decks\";\nimport { POWER_DECKS_BY_AGE } from \"./content/power-decks\";\nimport type {\n  Age,\n  Bid,\n  BlockState,\n  CardDefId,\n  GameState,\n  MarketRollOffRound,\n  MarketRollOffState,\n  MarketRowCard,\n  PlayerID\n} from \"./types\";\nimport { createCardInstance, insertCardIntoDrawPileRandom } from \"./cards\";\nimport { emit } from \"./events\";\n\nconst AGE_ORDER: Age[] = [\"I\", \"II\", \"III\"];\n\nconst clamp = (value: number, min: number, max: number) =>\n  Math.min(max, Math.max(min, value));\n\nconst getNextAge = (age: Age): Age | null => {\n  const index = AGE_ORDER.indexOf(age);\n  if (index < 0 || index >= AGE_ORDER.length - 1) {\n    return null;\n  }\n  return AGE_ORDER[index + 1];\n};\n\ntype DeckDraw = {\n  drawn: CardDefId[];\n  remaining: CardDefId[];\n};\n\nconst takeFromDeck = (deck: CardDefId[], count: number): DeckDraw => {\n  if (count <= 0 || deck.length === 0) {\n    return { drawn: [], remaining: deck };\n  }\n  const drawn = deck.slice(0, count);\n  const remaining = deck.slice(count);\n  return { drawn, remaining };\n};\n\nconst toRowCards = (age: Age, cardIds: CardDefId[]): MarketRowCard[] =>\n  cardIds.map((cardId) => ({ cardId, age, revealed: true }));\n\nconst createBids = (state: GameState) =>\n  Object.fromEntries(state.players.map((player) => [player.id, null]));\n\nconst createPlayersOut = (state: GameState) =>\n  Object.fromEntries(state.players.map((player) => [player.id, false]));\n\nconst getEligibleMarketPlayers = (state: GameState): PlayerID[] =>\n  state.players\n    .filter((player) => !state.market.playersOut[player.id])\n    .map((player) => player.id);\n\nconst isInteger = (value: number) => Number.isFinite(value) && Number.isInteger(value);\n\nconst isBidValid = (bid: Bid, availableGold: number): boolean => {\n  if (!isInteger(bid.amount)) {\n    return false;\n  }\n  if (bid.kind === \"buy\") {\n    return bid.amount >= 1 && bid.amount <= availableGold;\n  }\n  return bid.amount >= 0 && bid.amount <= availableGold;\n};\n\ntype BidEntry = {\n  playerId: PlayerID;\n  bid: Bid;\n};\n\nconst createPendingRolls = (playerIds: PlayerID[]) =>\n  Object.fromEntries(playerIds.map((playerId) => [playerId, null])) as Record<\n    PlayerID,\n    number | null\n  >;\n\nconst createRollOffKey = (state: GameState, cardIndex: number) =>\n  state.round * 100 + cardIndex;\n\nconst createMarketRollOffState = ({\n  state,\n  cardIndex,\n  kind,\n  bidAmount,\n  passBids,\n  eligiblePlayerIds\n}: {\n  state: GameState;\n  cardIndex: number;\n  kind: \"buy\" | \"pass\";\n  bidAmount: number | null;\n  passBids?: Record<PlayerID, number>;\n  eligiblePlayerIds: PlayerID[];\n}): MarketRollOffState => ({\n  key: createRollOffKey(state, cardIndex),\n  cardIndex,\n  kind,\n  bidAmount,\n  passBids,\n  eligiblePlayerIds,\n  rounds: [],\n  currentRolls: createPendingRolls(eligiblePlayerIds)\n});\n\nconst createMarketRollOffBlock = (rollOff: MarketRollOffState): BlockState => ({\n  type: \"market.rollOff\",\n  waitingFor: [...rollOff.eligiblePlayerIds],\n  payload: {\n    cardIndex: rollOff.cardIndex\n  }\n});\n\nexport const initializeMarketDecks = (state: GameState): GameState => {\n  let nextState = state;\n  const marketDecks = { I: [], II: [], III: [] } as Record<Age, CardDefId[]>;\n\n  for (const age of AGE_ORDER) {\n    const baseDeck = MARKET_DECKS_BY_AGE[age] ?? [];\n    const { value, next } = shuffle(nextState.rngState, baseDeck);\n    marketDecks[age] = value;\n    nextState = { ...nextState, rngState: next };\n  }\n\n  return { ...nextState, marketDecks };\n};\n\nexport const initializePowerDecks = (state: GameState): GameState => {\n  let rngState = state.rngState;\n  const powerDecks = { I: [], II: [], III: [] } as Record<Age, CardDefId[]>;\n\n  for (const age of AGE_ORDER) {\n    const baseDeck = POWER_DECKS_BY_AGE[age] ?? [];\n    const { value, next } = shuffle(rngState, baseDeck);\n    powerDecks[age] = value;\n    rngState = next;\n  }\n\n  return { ...state, powerDecks };\n};\n\nexport const prepareMarketRow = (state: GameState): GameState => {\n  if (state.market.currentRow.length > 0) {\n    return state;\n  }\n\n  const playerCount = state.players.length;\n  if (playerCount <= 0) {\n    return state;\n  }\n\n  const currentAge = state.market.age;\n  const nextAge = getNextAge(currentAge);\n  const previewTarget = clamp(\n    state.config.marketPreviewByRound[state.round] ?? 0,\n    0,\n    playerCount\n  );\n\n  let currentDeck = state.marketDecks[currentAge] ?? [];\n  let nextDeck = nextAge ? state.marketDecks[nextAge] ?? [] : [];\n  let previewCount = previewTarget;\n  if (!nextAge || nextDeck.length === 0) {\n    previewCount = 0;\n  }\n\n  const currentTarget = Math.max(0, playerCount - previewCount);\n\n  let { drawn: nextDrawn, remaining: nextRemaining } = takeFromDeck(\n    nextDeck,\n    previewCount\n  );\n  let { drawn: currentDrawn, remaining: currentRemaining } = takeFromDeck(\n    currentDeck,\n    currentTarget\n  );\n\n  let remainingSlots = playerCount - (nextDrawn.length + currentDrawn.length);\n  if (remainingSlots > 0) {\n    const fillCurrent = takeFromDeck(currentRemaining, remainingSlots);\n    currentDrawn = [...currentDrawn, ...fillCurrent.drawn];\n    currentRemaining = fillCurrent.remaining;\n    remainingSlots = playerCount - (nextDrawn.length + currentDrawn.length);\n  }\n  if (remainingSlots > 0 && nextAge) {\n    const fillNext = takeFromDeck(nextRemaining, remainingSlots);\n    nextDrawn = [...nextDrawn, ...fillNext.drawn];\n    nextRemaining = fillNext.remaining;\n  }\n\n  const rowCards: MarketRowCard[] = [\n    ...toRowCards(currentAge, currentDrawn),\n    ...toRowCards(nextAge ?? currentAge, nextDrawn)\n  ];\n  const { value: shuffledRow, next } = shuffle(state.rngState, rowCards);\n\n  const nextState: GameState = {\n    ...state,\n    rngState: next,\n    market: {\n      ...state.market,\n      currentRow: shuffledRow,\n      rowIndexResolving: 0,\n      passPot: 0,\n      bids: createBids(state),\n      playersOut: createPlayersOut(state),\n      rollOff: null\n    },\n    marketDecks: {\n      ...state.marketDecks,\n      [currentAge]: currentRemaining,\n      ...(nextAge ? { [nextAge]: nextRemaining } : {})\n    }\n  };\n\n  return emit(nextState, {\n    type: \"market.reveal\",\n    payload: {\n      row: shuffledRow.map((card) => ({ cardId: card.cardId, age: card.age }))\n    }\n  });\n};\n\nexport const createMarketBidBlock = (state: GameState): BlockState | null => {\n  const cardIndex = state.market.rowIndexResolving;\n  const currentCard = state.market.currentRow[cardIndex];\n  if (!currentCard) {\n    return null;\n  }\n  if (state.market.rollOff) {\n    return null;\n  }\n\n  const eligible = getEligibleMarketPlayers(state);\n  if (eligible.length === 0) {\n    return null;\n  }\n\n  return {\n    type: \"market.bidsForCard\",\n    waitingFor: eligible,\n    payload: {\n      cardIndex\n    }\n  };\n};\n\nexport const applyMarketBid = (\n  state: GameState,\n  bid: Bid,\n  playerId: PlayerID\n): GameState => {\n  if (state.phase !== \"round.market\") {\n    return state;\n  }\n\n  const block = state.blocks;\n  if (!block || block.type !== \"market.bidsForCard\") {\n    return state;\n  }\n\n  if (block.payload.cardIndex !== state.market.rowIndexResolving) {\n    return state;\n  }\n\n  if (!block.waitingFor.includes(playerId)) {\n    return state;\n  }\n\n  if (state.market.playersOut[playerId]) {\n    return state;\n  }\n\n  const player = state.players.find((entry) => entry.id === playerId);\n  if (!player) {\n    return state;\n  }\n\n  if (!isBidValid(bid, player.resources.gold)) {\n    return state;\n  }\n\n  if (state.market.bids[playerId]) {\n    return state;\n  }\n\n  return {\n    ...state,\n    market: {\n      ...state.market,\n      bids: {\n        ...state.market.bids,\n        [playerId]: bid\n      }\n    },\n    blocks: {\n      ...block,\n      waitingFor: block.waitingFor.filter((id) => id !== playerId)\n    }\n  };\n};\n\nexport const applyMarketRollOff = (state: GameState, playerId: PlayerID): GameState => {\n  if (state.phase !== \"round.market\") {\n    return state;\n  }\n\n  const block = state.blocks;\n  if (!block || block.type !== \"market.rollOff\") {\n    return state;\n  }\n\n  const rollOff = state.market.rollOff;\n  if (!rollOff) {\n    return state;\n  }\n\n  if (!block.waitingFor.includes(playerId)) {\n    return state;\n  }\n\n  if (!rollOff.eligiblePlayerIds.includes(playerId)) {\n    return state;\n  }\n\n  if (typeof rollOff.currentRolls[playerId] === \"number\") {\n    return state;\n  }\n\n  const roll = rollDie(state.rngState);\n  return {\n    ...state,\n    rngState: roll.next,\n    market: {\n      ...state.market,\n      rollOff: {\n        ...rollOff,\n        currentRolls: {\n          ...rollOff.currentRolls,\n          [playerId]: roll.value\n        }\n      }\n    },\n    blocks: {\n      ...block,\n      waitingFor: block.waitingFor.filter((id) => id !== playerId)\n    }\n  };\n};\n\nconst applyMarketBuyWinner = ({\n  state,\n  winnerId,\n  amount,\n  cardIndex,\n  rollOffRounds\n}: {\n  state: GameState;\n  winnerId: PlayerID;\n  amount: number;\n  cardIndex: number;\n  rollOffRounds: MarketRollOffRound[];\n}): GameState => {\n  const currentCard = state.market.currentRow[cardIndex];\n  if (!currentCard) {\n    return state;\n  }\n\n  const players = state.players.map((player) =>\n    player.id === winnerId\n      ? {\n          ...player,\n          resources: {\n            ...player.resources,\n            gold: player.resources.gold - amount\n          }\n        }\n      : player\n  );\n\n  let nextState: GameState = {\n    ...state,\n    players,\n    market: {\n      ...state.market,\n      rowIndexResolving: cardIndex + 1,\n      bids: createBids(state),\n      passPot: 0,\n      playersOut: {\n        ...state.market.playersOut,\n        [winnerId]: true\n      },\n      rollOff: null\n    }\n  };\n\n  const created = createCardInstance(nextState, currentCard.cardId);\n  nextState = insertCardIntoDrawPileRandom(created.state, winnerId, created.instanceId);\n  return emit(nextState, {\n    type: \"market.buy\",\n    payload: {\n      playerId: winnerId,\n      cardId: currentCard.cardId,\n      amount,\n      cardIndex,\n      rollOff: rollOffRounds.length > 0 ? rollOffRounds : undefined\n    }\n  });\n};\n\nconst applyMarketPassWinner = ({\n  state,\n  winnerId,\n  passBids,\n  cardIndex,\n  rollOffRounds\n}: {\n  state: GameState;\n  winnerId: PlayerID;\n  passBids: Record<PlayerID, number>;\n  cardIndex: number;\n  rollOffRounds: MarketRollOffRound[];\n}): GameState => {\n  const currentCard = state.market.currentRow[cardIndex];\n  if (!currentCard) {\n    return state;\n  }\n\n  const passPot = Object.values(passBids).reduce((total, amount) => total + amount, 0);\n  const players = state.players.map((player) => {\n    const bidAmount = passBids[player.id] ?? 0;\n    let gold = player.resources.gold;\n    if (bidAmount > 0) {\n      gold -= bidAmount;\n    }\n    if (player.id === winnerId && passPot > 0) {\n      gold += passPot;\n    }\n    return {\n      ...player,\n      resources: {\n        ...player.resources,\n        gold\n      }\n    };\n  });\n\n  let nextState: GameState = {\n    ...state,\n    players,\n    market: {\n      ...state.market,\n      rowIndexResolving: cardIndex + 1,\n      bids: createBids(state),\n      passPot: 0,\n      playersOut: {\n        ...state.market.playersOut,\n        [winnerId]: true\n      },\n      rollOff: null\n    }\n  };\n\n  const created = createCardInstance(nextState, currentCard.cardId);\n  nextState = insertCardIntoDrawPileRandom(created.state, winnerId, created.instanceId);\n  return emit(nextState, {\n    type: \"market.pass\",\n    payload: {\n      playerId: winnerId,\n      cardId: currentCard.cardId,\n      passPot,\n      cardIndex,\n      rollOff: rollOffRounds.length > 0 ? rollOffRounds : undefined\n    }\n  });\n};\n\nexport const resolveMarketRollOff = (state: GameState): GameState => {\n  const rollOff = state.market.rollOff;\n  if (!rollOff) {\n    return state;\n  }\n\n  const roundValues: MarketRollOffRound = {};\n  for (const playerId of rollOff.eligiblePlayerIds) {\n    const value = rollOff.currentRolls[playerId];\n    if (typeof value !== \"number\") {\n      return state;\n    }\n    roundValues[playerId] = value;\n  }\n\n  const rounds = [...rollOff.rounds, roundValues];\n  const lowest = Math.min(...Object.values(roundValues));\n  const tied = rollOff.eligiblePlayerIds.filter((playerId) => roundValues[playerId] === lowest);\n\n  if (tied.length > 1) {\n    const nextRollOff: MarketRollOffState = {\n      ...rollOff,\n      rounds,\n      eligiblePlayerIds: tied,\n      currentRolls: createPendingRolls(tied)\n    };\n    return {\n      ...state,\n      market: {\n        ...state.market,\n        rollOff: nextRollOff\n      },\n      blocks: createMarketRollOffBlock(nextRollOff)\n    };\n  }\n\n  const winnerId = tied[0];\n  if (rollOff.kind === \"buy\") {\n    if (typeof rollOff.bidAmount !== \"number\") {\n      return state;\n    }\n    return {\n      ...applyMarketBuyWinner({\n        state,\n        winnerId,\n        amount: rollOff.bidAmount,\n        cardIndex: rollOff.cardIndex,\n        rollOffRounds: rounds\n      }),\n      blocks: undefined\n    };\n  }\n\n  return {\n    ...applyMarketPassWinner({\n      state,\n      winnerId,\n      passBids: rollOff.passBids ?? {},\n      cardIndex: rollOff.cardIndex,\n      rollOffRounds: rounds\n    }),\n    blocks: undefined\n  };\n};\n\nexport const resolveMarketBids = (state: GameState): GameState => {\n  const cardIndex = state.market.rowIndexResolving;\n  const currentCard = state.market.currentRow[cardIndex];\n  if (!currentCard) {\n    return state;\n  }\n\n  const eligiblePlayerIds = getEligibleMarketPlayers(state);\n  if (eligiblePlayerIds.length === 0) {\n    return {\n      ...state,\n      market: {\n        ...state.market,\n        rowIndexResolving: state.market.currentRow.length,\n        bids: createBids(state),\n        passPot: 0,\n        rollOff: null\n      }\n    };\n  }\n\n  const bidEntries: BidEntry[] = eligiblePlayerIds.map((playerId) => {\n    const bid = state.market.bids[playerId];\n    return {\n      playerId,\n      bid: bid ?? { kind: \"pass\", amount: 0 }\n    };\n  });\n\n  const buyBids = bidEntries.filter((entry) => entry.bid.kind === \"buy\" && entry.bid.amount > 0);\n\n  if (buyBids.length > 0) {\n    const highest = Math.max(...buyBids.map((entry) => entry.bid.amount));\n    const topBids = buyBids.filter((entry) => entry.bid.amount === highest);\n    if (topBids.length > 1) {\n      const rollOff = createMarketRollOffState({\n        state,\n        cardIndex,\n        kind: \"buy\",\n        bidAmount: highest,\n        eligiblePlayerIds: topBids.map((entry) => entry.playerId)\n      });\n      return {\n        ...state,\n        market: {\n          ...state.market,\n          rollOff\n        },\n        blocks: createMarketRollOffBlock(rollOff)\n      };\n    }\n\n    return applyMarketBuyWinner({\n      state,\n      winnerId: topBids[0].playerId,\n      amount: highest,\n      cardIndex,\n      rollOffRounds: []\n    });\n  }\n\n  const passBids = bidEntries.map((entry) => ({\n    playerId: entry.playerId,\n    amount: entry.bid.amount\n  }));\n  const passBidByPlayer = Object.fromEntries(\n    passBids.map((entry) => [entry.playerId, entry.amount])\n  ) as Record<PlayerID, number>;\n  const lowest = Math.min(...passBids.map((entry) => entry.amount));\n  const eligibleWinners = passBids\n    .filter((entry) => entry.amount === lowest)\n    .map((entry) => entry.playerId);\n\n  if (eligibleWinners.length > 1) {\n    const rollOff = createMarketRollOffState({\n      state,\n      cardIndex,\n      kind: \"pass\",\n      bidAmount: null,\n      passBids: passBidByPlayer,\n      eligiblePlayerIds: eligibleWinners\n    });\n    return {\n      ...state,\n      market: {\n        ...state.market,\n        rollOff\n      },\n      blocks: createMarketRollOffBlock(rollOff)\n    };\n  }\n\n  return applyMarketPassWinner({\n    state,\n    winnerId: eligibleWinners[0],\n    passBids: passBidByPlayer,\n    cardIndex,\n    rollOffRounds: []\n  });\n};\n", "import { createRngState } from \"@bridgefront/shared\";\n\nimport type {\n  Command,\n  GameState,\n  LobbyPlayer,\n  PlayerID,\n  PlayerState\n} from \"./types\";\nimport { DEFAULT_CONFIG } from \"./config\";\nimport { createBaseBoard, getCapitalSlots } from \"./board-generation\";\nimport {\n  applySetupChoice,\n  createCapitalDraftBlock,\n  createDeckPreviewBlock,\n  createFreeStartingCardBlock,\n  createStartingBridgesBlock,\n  finalizeCapitalDraft,\n  finalizeFreeStartingCardPick,\n  finalizeStartingBridges\n} from \"./setup-flow\";\nimport {\n  applyAgeUpdate,\n  applyCleanup,\n  applyQuietStudyChoice,\n  applyRoundReset,\n  applyScoring,\n  applyCollectionChoice,\n  createQuietStudyBlock,\n  createCollectionBlock,\n  resolveQuietStudyChoices,\n  resolveCollectionChoices\n} from \"./round-flow\";\nimport {\n  applyActionDeclaration,\n  createActionResolutionState,\n  createActionStepBlock,\n  resolveNextActionEntry\n} from \"./action-flow\";\nimport { applyScoutReportChoice, resolveScoutReportBlock } from \"./card-effects\";\nimport { applyCombatRetreatChoice, resolveCombatRetreatBlock, resolveSieges } from \"./combat\";\nimport { emit } from \"./events\";\nimport {\n  applyMarketBid,\n  applyMarketRollOff,\n  createMarketBidBlock,\n  initializeMarketDecks,\n  initializePowerDecks,\n  prepareMarketRow,\n  resolveMarketBids,\n  resolveMarketRollOff\n} from \"./market\";\n\nconst createPlayerState = (player: LobbyPlayer, seatIndex: number, startingGold: number): PlayerState => {\n  return {\n    id: player.id,\n    name: player.name,\n    seatIndex,\n    factionId: player.factionId ?? \"unassigned\",\n    capitalHex: undefined,\n    resources: { gold: startingGold, mana: 0 },\n    vp: { permanent: 0, control: 0, total: 0 },\n    doneThisRound: false,\n    deck: {\n      drawPile: [],\n      discardPile: [],\n      hand: [],\n      scrapped: []\n    },\n    burned: [],\n    flags: {},\n    visibility: { connected: true }\n  };\n};\n\nconst getHostPlayerId = (state: GameState): PlayerID | null => {\n  return state.players.find((player) => player.seatIndex === 0)?.id ?? null;\n};\n\nconst requestSetupAdvance = (state: GameState, playerId: PlayerID): GameState => {\n  if (state.phase !== \"setup\") {\n    throw new Error(\"setup advance is only available during setup\");\n  }\n  const hostPlayerId = getHostPlayerId(state);\n  if (!hostPlayerId || hostPlayerId !== playerId) {\n    throw new Error(\"only the host can advance setup\");\n  }\n  if (!state.blocks) {\n    throw new Error(\"no setup block to advance\");\n  }\n  if (state.blocks.waitingFor.length > 0) {\n    throw new Error(\"setup cannot advance until all players are ready\");\n  }\n  return {\n    ...state,\n    setup: {\n      ...state.setup,\n      advanceRequested: true\n    }\n  };\n};\n\nconst normalizeSeed = (seed: GameState[\"seed\"]): number => {\n  if (typeof seed === \"number\") {\n    if (!Number.isFinite(seed)) {\n      throw new Error(\"seed must be a finite number\");\n    }\n    return seed >>> 0;\n  }\n\n  let hash = 2166136261;\n  for (let i = 0; i < seed.length; i += 1) {\n    hash ^= seed.charCodeAt(i);\n    hash = Math.imul(hash, 16777619);\n  }\n\n  return hash >>> 0;\n};\n\nconst enterPhase = (state: GameState, phase: GameState[\"phase\"]): GameState => {\n  return emit(\n    { ...state, phase, blocks: undefined },\n    { type: `phase.${phase}`, payload: { round: state.round } }\n  );\n};\n\nexport const createNewGame = (\n  config: GameState[\"config\"] = DEFAULT_CONFIG,\n  seed: GameState[\"seed\"],\n  lobbyPlayers: LobbyPlayer[]\n): GameState => {\n  const playerCount = lobbyPlayers.length;\n  const players = lobbyPlayers.map((player, seatIndex) =>\n    createPlayerState(player, seatIndex, config.START_GOLD)\n  );\n  const radius = config.boardRadiusByPlayerCount[playerCount] ?? 0;\n  const board = createBaseBoard(radius);\n  const capitalSlots = getCapitalSlots(playerCount, radius, config.capitalSlotsByPlayerCount);\n\n  let state: GameState = {\n    config,\n    seed,\n    rngState: createRngState(normalizeSeed(seed)),\n    revision: 0,\n    createdAt: Date.now(),\n    players,\n    round: 0,\n    leadSeatIndex: 0,\n    phase: \"setup\",\n    setup: { advanceRequested: false },\n    board,\n    market: {\n      age: \"I\",\n      currentRow: [],\n      rowIndexResolving: 0,\n      passPot: 0,\n      bids: Object.fromEntries(players.map((player) => [player.id, null])),\n      playersOut: Object.fromEntries(players.map((player) => [player.id, false])),\n      rollOff: null\n    },\n    marketDecks: { I: [], II: [], III: [] },\n    powerDecks: { I: [], II: [], III: [] },\n    logs: [],\n    modifiers: [],\n    blocks: createDeckPreviewBlock(),\n    cardsByInstanceId: {},\n    winnerPlayerId: null\n  };\n\n  state = initializeMarketDecks(state);\n  state = initializePowerDecks(state);\n  return state;\n};\n\nexport const applyCommand = (\n  state: GameState,\n  _command: Command,\n  _playerId: PlayerID\n): GameState => {\n  if (_command.type === \"SubmitSetupChoice\") {\n    return applySetupChoice(state, _command.payload, _playerId);\n  }\n\n  if (_command.type === \"AdvanceSetup\") {\n    return requestSetupAdvance(state, _playerId);\n  }\n\n  if (_command.type === \"SubmitQuietStudy\") {\n    return applyQuietStudyChoice(state, _command.payload.cardInstanceIds, _playerId);\n  }\n\n  if (_command.type === \"SubmitScoutReportChoice\") {\n    return applyScoutReportChoice(state, _command.payload.cardInstanceIds, _playerId);\n  }\n\n  if (_command.type === \"SubmitAction\") {\n    return applyActionDeclaration(state, _command.payload, _playerId);\n  }\n\n  if (_command.type === \"SubmitMarketBid\") {\n    return applyMarketBid(state, _command.payload, _playerId);\n  }\n\n  if (_command.type === \"SubmitMarketRollOff\") {\n    return applyMarketRollOff(state, _playerId);\n  }\n\n  if (_command.type === \"SubmitCollectionChoices\") {\n    return applyCollectionChoice(state, _command.payload, _playerId);\n  }\n\n  if (_command.type === \"SubmitCombatRetreat\") {\n    return applyCombatRetreatChoice(state, _playerId, _command.payload);\n  }\n\n  return state;\n};\n\nexport const runUntilBlocked = (state: GameState): GameState => {\n  let nextState = state;\n\n  while (true) {\n    if (nextState.winnerPlayerId) {\n      return nextState;\n    }\n\n    if (nextState.blocks?.type === \"combat.retreat\") {\n      if (nextState.blocks.waitingFor.length > 0) {\n        return nextState;\n      }\n      nextState = resolveCombatRetreatBlock(nextState, nextState.blocks);\n      nextState = {\n        ...nextState,\n        blocks: undefined\n      };\n      continue;\n    }\n\n    if (nextState.blocks?.type === \"action.scoutReport\") {\n      if (nextState.blocks.waitingFor.length > 0) {\n        return nextState;\n      }\n      nextState = resolveScoutReportBlock(nextState, nextState.blocks);\n      nextState = {\n        ...nextState,\n        blocks: undefined\n      };\n      continue;\n    }\n\n    if (nextState.blocks?.type === \"market.rollOff\") {\n      if (nextState.blocks.waitingFor.length > 0) {\n        return nextState;\n      }\n      nextState = resolveMarketRollOff(nextState);\n      if (nextState.blocks?.type === \"market.rollOff\") {\n        return nextState;\n      }\n      continue;\n    }\n\n    if (nextState.phase === \"round.reset\") {\n      const resetState = applyRoundReset(nextState);\n      nextState =\n        resetState.phase !== nextState.phase\n          ? enterPhase(resetState, resetState.phase)\n          : resetState;\n      continue;\n    }\n\n    if (nextState.phase === \"round.study\") {\n      if (!nextState.blocks) {\n        const block = createQuietStudyBlock(nextState);\n        if (!block) {\n          nextState = enterPhase(nextState, \"round.action\");\n          continue;\n        }\n        nextState = {\n          ...nextState,\n          blocks: block\n        };\n        if (block.waitingFor.length > 0) {\n          return nextState;\n        }\n      }\n\n      if (nextState.blocks.type === \"round.quietStudy\") {\n        if (nextState.blocks.waitingFor.length > 0) {\n          return nextState;\n        }\n        nextState = resolveQuietStudyChoices(nextState);\n        nextState = {\n          ...nextState,\n          blocks: undefined\n        };\n        nextState = enterPhase(nextState, \"round.market\");\n        continue;\n      }\n\n      return nextState;\n    }\n\n    if (nextState.phase === \"round.market\") {\n      nextState = prepareMarketRow(nextState);\n      if (!nextState.blocks) {\n        const block = createMarketBidBlock(nextState);\n        if (!block) {\n          const quietStudyBlock = createQuietStudyBlock(nextState);\n          if (quietStudyBlock) {\n            nextState = enterPhase(nextState, \"round.study\");\n            continue;\n          }\n          nextState = enterPhase(nextState, \"round.action\");\n          continue;\n        }\n        nextState = {\n          ...nextState,\n          blocks: block\n        };\n        continue;\n      }\n\n      if (nextState.blocks.type === \"market.bidsForCard\") {\n        if (nextState.blocks.waitingFor.length > 0) {\n          return nextState;\n        }\n        nextState = resolveMarketBids(nextState);\n        if (nextState.blocks?.type === \"market.rollOff\") {\n          return nextState;\n        }\n        nextState = {\n          ...nextState,\n          blocks: undefined\n        };\n        continue;\n      }\n\n      return nextState;\n    }\n\n    if (nextState.phase === \"round.action\") {\n      if (nextState.actionResolution) {\n        nextState = resolveNextActionEntry(nextState);\n        if (nextState.blocks?.type === \"combat.retreat\") {\n          return nextState;\n        }\n        continue;\n      }\n\n      if (!nextState.blocks) {\n        const block = createActionStepBlock(nextState);\n        if (!block) {\n          nextState = enterPhase(nextState, \"round.sieges\");\n          continue;\n        }\n        nextState = {\n          ...nextState,\n          blocks: block\n        };\n        continue;\n      }\n\n      if (nextState.blocks.type === \"actionStep.declarations\") {\n        if (nextState.blocks.waitingFor.length > 0) {\n          return nextState;\n        }\n        nextState = {\n          ...nextState,\n          blocks: undefined,\n          actionResolution: createActionResolutionState(\n            nextState,\n            nextState.blocks.payload.declarations\n          )\n        };\n        continue;\n      }\n\n      return nextState;\n    }\n\n    if (nextState.phase === \"round.sieges\") {\n      nextState = resolveSieges(nextState);\n      if (nextState.blocks?.type === \"combat.retreat\") {\n        return nextState;\n      }\n      nextState = enterPhase(nextState, \"round.collection\");\n      continue;\n    }\n\n    if (nextState.phase === \"round.collection\") {\n      if (!nextState.blocks) {\n        const collection = createCollectionBlock(nextState);\n        if (!collection.block) {\n          nextState = enterPhase(collection.state, \"round.scoring\");\n          continue;\n        }\n        nextState = {\n          ...collection.state,\n          blocks: collection.block\n        };\n        continue;\n      }\n\n      if (nextState.blocks.type === \"collection.choices\") {\n        if (nextState.blocks.waitingFor.length > 0) {\n          return nextState;\n        }\n        nextState = resolveCollectionChoices(nextState);\n        nextState = {\n          ...nextState,\n          blocks: undefined\n        };\n        nextState = enterPhase(nextState, \"round.scoring\");\n        continue;\n      }\n\n      return nextState;\n    }\n\n    if (nextState.phase === \"round.scoring\") {\n      nextState = applyScoring(nextState);\n      if (nextState.winnerPlayerId) {\n        return nextState;\n      }\n      nextState = enterPhase(nextState, \"round.cleanup\");\n      continue;\n    }\n\n    if (nextState.phase === \"round.cleanup\") {\n      nextState = applyCleanup(nextState);\n      nextState = enterPhase(nextState, \"round.ageUpdate\");\n      continue;\n    }\n\n    if (nextState.phase === \"round.ageUpdate\") {\n      nextState = applyAgeUpdate(nextState);\n      nextState = enterPhase(nextState, \"round.reset\");\n      continue;\n    }\n\n    if (nextState.phase !== \"setup\") {\n      return nextState;\n    }\n\n    if (!nextState.blocks) {\n      return {\n        ...nextState,\n        blocks: createDeckPreviewBlock()\n      };\n    }\n\n    if (nextState.blocks.waitingFor.length > 0) {\n      return nextState;\n    }\n\n    if (!nextState.setup.advanceRequested) {\n      return nextState;\n    }\n\n    const advanceReadyState = {\n      ...nextState,\n      setup: {\n        ...nextState.setup,\n        advanceRequested: false\n      }\n    };\n\n    if (advanceReadyState.blocks.type === \"setup.deckPreview\") {\n      const capitalSlots = getCapitalSlots(\n        advanceReadyState.players.length,\n        advanceReadyState.board.radius,\n        advanceReadyState.config.capitalSlotsByPlayerCount\n      );\n      nextState = {\n        ...advanceReadyState,\n        blocks: createCapitalDraftBlock(advanceReadyState.players, capitalSlots)\n      };\n      continue;\n    }\n\n    if (advanceReadyState.blocks.type === \"setup.capitalDraft\") {\n      const setupState = finalizeCapitalDraft(advanceReadyState);\n      nextState = {\n        ...setupState,\n        blocks: createStartingBridgesBlock(setupState.players)\n      };\n      continue;\n    }\n\n    if (advanceReadyState.blocks.type === \"setup.startingBridges\") {\n      const revealed = finalizeStartingBridges(advanceReadyState);\n      const { state: updatedState, block } = createFreeStartingCardBlock(revealed);\n      nextState = {\n        ...updatedState,\n        blocks: block\n      };\n      continue;\n    }\n\n    if (advanceReadyState.blocks.type === \"setup.freeStartingCardPick\") {\n      const finalized = finalizeFreeStartingCardPick(advanceReadyState);\n      nextState = enterPhase(finalized, \"round.reset\");\n      continue;\n    }\n\n    return nextState;\n  }\n};\n", "import type {\n  BlockState,\n  CombatRetreatPublicView,\n  GameState,\n  GameView,\n  Modifier,\n  ModifierView,\n  PlayerID,\n  SetupPrivateView,\n  SetupPublicView,\n  SetupStatusView\n} from \"./types\";\nimport { getControlBonus } from \"./modifiers\";\nimport { getControlTotals } from \"./round-flow\";\n\ntype SetupBlockState = Extract<\n  BlockState,\n  {\n    type:\n      | \"setup.deckPreview\"\n      | \"setup.capitalDraft\"\n      | \"setup.startingBridges\"\n      | \"setup.freeStartingCardPick\";\n  }\n>;\n\nconst isSetupBlock = (block: BlockState): block is SetupBlockState =>\n  block.type === \"setup.deckPreview\" ||\n  block.type === \"setup.capitalDraft\" ||\n  block.type === \"setup.startingBridges\" ||\n  block.type === \"setup.freeStartingCardPick\";\n\nconst buildSetupPublicView = (block: SetupBlockState): SetupPublicView => {\n  if (block.type === \"setup.deckPreview\") {\n    return {\n      type: block.type,\n      waitingForPlayerIds: block.waitingFor\n    };\n  }\n  if (block.type === \"setup.capitalDraft\") {\n    return {\n      type: block.type,\n      waitingForPlayerIds: block.waitingFor,\n      availableSlots: block.payload.availableSlots,\n      choices: block.payload.choices\n    };\n  }\n  if (block.type === \"setup.startingBridges\") {\n    return {\n      type: block.type,\n      waitingForPlayerIds: block.waitingFor,\n      remaining: block.payload.remaining\n    };\n  }\n  const chosen = Object.fromEntries(\n    Object.entries(block.payload.chosen).map(([playerId, cardId]) => [playerId, Boolean(cardId)])\n  );\n  return {\n    type: block.type,\n    waitingForPlayerIds: block.waitingFor,\n    chosen\n  };\n};\n\nconst buildSetupPrivateView = (block: SetupBlockState, playerId: PlayerID): SetupPrivateView => {\n  if (block.type === \"setup.startingBridges\") {\n    return {\n      type: block.type,\n      remaining: block.payload.remaining[playerId] ?? 0,\n      selectedEdges: block.payload.selectedEdges[playerId] ?? []\n    };\n  }\n  if (block.type !== \"setup.freeStartingCardPick\") {\n    return null;\n  }\n  return {\n    type: block.type,\n    offers: block.payload.offers[playerId] ?? [],\n    chosen: block.payload.chosen[playerId] ?? null\n  };\n};\n\nconst buildSetupStatusView = (state: GameState): SetupStatusView | null => {\n  if (state.phase !== \"setup\") {\n    return null;\n  }\n\n  const setupBlock = state.blocks && isSetupBlock(state.blocks) ? state.blocks : null;\n  const waitingForPlayerIds = setupBlock?.waitingFor ?? [];\n  const hostPlayerId = state.players.find((player) => player.seatIndex === 0)?.id ?? null;\n  const lockedByPlayerId = Object.fromEntries(\n    state.players.map((player) => [player.id, !waitingForPlayerIds.includes(player.id)])\n  );\n\n  return {\n    phase: setupBlock ? setupBlock.type : \"setup.lobby\",\n    hostPlayerId,\n    lockedByPlayerId,\n    waitingForPlayerIds,\n    canAdvance: Boolean(setupBlock && waitingForPlayerIds.length === 0)\n  };\n};\n\nconst buildCombatRetreatView = (\n  block: Extract<BlockState, { type: \"combat.retreat\" }>\n): CombatRetreatPublicView => {\n  return {\n    hexKey: block.payload.hexKey,\n    attackers: block.payload.attackers,\n    defenders: block.payload.defenders,\n    waitingForPlayerIds: block.waitingFor,\n    eligiblePlayerIds: block.payload.eligiblePlayerIds,\n    availableEdges: block.payload.availableEdges,\n    choices: block.payload.choices\n  };\n};\n\nconst mapCardInstances = (state: GameState, instanceIds: string[]) => {\n  return instanceIds.map(\n    (instanceId) =>\n      state.cardsByInstanceId[instanceId] ?? { id: instanceId, defId: \"unknown\" }\n  );\n};\n\nconst toModifierView = (modifier: Modifier): ModifierView => {\n  const { hooks, ...rest } = modifier;\n  return rest;\n};\n\nexport const buildView = (state: GameState, viewerPlayerId: PlayerID | null): GameView => {\n  const viewer = state.players.find((player) => player.id === viewerPlayerId) ?? null;\n  const controlTotals = viewer ? getControlTotals(state) : null;\n  const viewerVp =\n    viewer && controlTotals\n      ? (() => {\n          const baseControl = controlTotals[viewer.id] ?? 0;\n          const controlBonus = getControlBonus(state, { playerId: viewer.id }, 0);\n          const control = baseControl + controlBonus;\n          return {\n            ...viewer.vp,\n            control,\n            total: viewer.vp.permanent + control\n          };\n        })()\n      : null;\n  const actionStep =\n    state.blocks?.type === \"actionStep.declarations\"\n      ? {\n          eligiblePlayerIds: Object.keys(state.blocks.payload.declarations),\n          waitingForPlayerIds: state.blocks.waitingFor\n        }\n      : null;\n  const setupPublic =\n    state.phase === \"setup\" && state.blocks && isSetupBlock(state.blocks)\n      ? buildSetupPublicView(state.blocks)\n      : null;\n  const setupPrivate =\n    viewer && state.phase === \"setup\" && state.blocks && isSetupBlock(state.blocks)\n      ? buildSetupPrivateView(state.blocks, viewer.id)\n      : null;\n  const collectionPublic =\n    state.phase === \"round.collection\" && state.blocks?.type === \"collection.choices\"\n      ? { waitingForPlayerIds: state.blocks.waitingFor }\n      : null;\n  const collectionPrivate =\n    viewer && state.phase === \"round.collection\" && state.blocks?.type === \"collection.choices\"\n      ? {\n          prompts: state.blocks.payload.prompts[viewer.id] ?? [],\n          choices: state.blocks.payload.choices[viewer.id] ?? null\n        }\n      : null;\n  const quietStudyPublic =\n    state.phase === \"round.study\" && state.blocks?.type === \"round.quietStudy\"\n      ? { waitingForPlayerIds: state.blocks.waitingFor }\n      : null;\n  const quietStudyPrivate =\n    viewer && state.phase === \"round.study\" && state.blocks?.type === \"round.quietStudy\"\n      ? {\n          maxDiscard: state.blocks.payload.maxDiscard,\n          selected: state.blocks.payload.choices[viewer.id] ?? null,\n          isWaiting: state.blocks.waitingFor.includes(viewer.id)\n        }\n      : null;\n  const scoutReportPrivate =\n    viewer &&\n    state.blocks?.type === \"action.scoutReport\" &&\n    state.blocks.payload.playerId === viewer.id\n      ? {\n          offers: mapCardInstances(state, state.blocks.payload.offers),\n          keepCount: state.blocks.payload.keepCount,\n          selected: state.blocks.payload.chosen ?? null,\n          isWaiting: state.blocks.waitingFor.includes(viewer.id)\n        }\n      : null;\n  const setupStatus = buildSetupStatusView(state);\n  const combatPublic =\n    state.blocks?.type === \"combat.retreat\" ? buildCombatRetreatView(state.blocks) : null;\n\n  return {\n    public: {\n      config: state.config,\n      seed: state.seed,\n      round: state.round,\n      phase: state.phase,\n      board: state.board,\n      modifiers: state.modifiers.map(toModifierView),\n      market: state.market,\n      logs: state.logs,\n      players: state.players.map((player) => ({\n        id: player.id,\n        name: player.name,\n        seatIndex: player.seatIndex,\n        factionId: player.factionId,\n        resources: player.resources,\n        handCount: player.deck.hand.length,\n        vp: state.winnerPlayerId ? player.vp : null,\n        doneThisRound: player.doneThisRound,\n        connected: player.visibility.connected\n      })),\n      actionStep,\n      combat: combatPublic,\n      setup: setupPublic,\n      setupStatus,\n      collection: collectionPublic,\n      quietStudy: quietStudyPublic,\n      winnerPlayerId: state.winnerPlayerId\n    },\n    private: viewer\n      ? {\n          playerId: viewer.id,\n          hand: viewer.deck.hand,\n          handCards: mapCardInstances(state, viewer.deck.hand),\n          deckCounts: {\n            drawPile: viewer.deck.drawPile.length,\n            discardPile: viewer.deck.discardPile.length,\n            scrapped: viewer.deck.scrapped.length,\n            burned: viewer.burned.length\n          },\n          deckCards: {\n            drawPile: mapCardInstances(state, viewer.deck.drawPile),\n            discardPile: mapCardInstances(state, viewer.deck.discardPile),\n            scrapped: mapCardInstances(state, viewer.deck.scrapped),\n            burned: mapCardInstances(state, viewer.burned)\n          },\n          vp: viewerVp,\n          setup: setupPrivate,\n          collection: collectionPrivate,\n          quietStudy: quietStudyPrivate,\n          scoutReport: scoutReportPrivate\n        }\n      : null\n  };\n};\n", "import type * as Party from \"partykit/server\";\nimport {\n  applyCommand,\n  buildView,\n  createNewGame,\n  DEFAULT_CONFIG,\n  emit,\n  getBridgeKey,\n  runUntilBlocked\n} from \"@bridgefront/engine\";\nimport type {\n  BlockState,\n  CollectionChoice,\n  CollectionPrompt,\n  Command,\n  GameEvent,\n  GameState,\n  LobbyPlayer,\n  PlayerID,\n  SetupChoice\n} from \"@bridgefront/engine\";\n\ntype ConnectionState = {\n  playerId: PlayerID;\n  seatIndex: number | null;\n  spectator: boolean;\n  rejoinToken?: string;\n};\n\ntype JoinMessage = {\n  type: \"join\";\n  name?: string;\n  rejoinToken?: string;\n  asSpectator?: boolean;\n};\n\ntype CommandMessage = {\n  type: \"command\";\n  playerId: PlayerID;\n  clientSeq?: number;\n  command: Command;\n};\n\ntype LobbyCommandMessage = {\n  type: \"lobbyCommand\";\n  playerId: PlayerID;\n  command: \"rerollMap\" | \"rollDice\" | \"startGame\" | \"autoSetup\" | \"pickFaction\";\n  factionId?: string;\n};\n\ntype DebugCommandMessage = {\n  type: \"debugCommand\";\n  playerId: PlayerID;\n  command: \"state\" | \"advancePhase\" | \"resetGame\" | \"patchState\";\n  seed?: number;\n  path?: string;\n  value?: unknown;\n};\n\ntype CombatCommandMessage = {\n  type: \"combatCommand\";\n  playerId: PlayerID;\n  command: \"roll\";\n  sequenceId: string;\n  roundIndex: number;\n};\n\ntype ClientMessage =\n  | JoinMessage\n  | CommandMessage\n  | LobbyCommandMessage\n  | DebugCommandMessage\n  | CombatCommandMessage;\n\ntype LobbyPlayerView = {\n  id: PlayerID;\n  name: string;\n  seatIndex: number;\n  connected: boolean;\n  factionId: string | null;\n};\n\ntype LobbySnapshot = {\n  players: LobbyPlayerView[];\n  minPlayers: number;\n  maxPlayers: number;\n};\n\ntype CombatSyncState = {\n  sequenceId: string;\n  playerIds: PlayerID[];\n  roundIndex: number;\n  readyByPlayerId: Record<PlayerID, boolean>;\n  phaseStartAt: number | null;\n  stage: \"idle\" | \"rolling\" | \"assigned\";\n};\n\nconst MIN_PLAYERS = 2;\nconst MAX_PLAYERS = 6;\nconst MAX_COMBAT_SYNC = 12;\nconst COMBAT_ROLL_DONE_MS = DEFAULT_CONFIG.COMBAT_ROLL_DONE_MS;\nconst FACTION_IDS = new Set([\n  \"bastion\",\n  \"veil\",\n  \"aerial\",\n  \"prospect\",\n  \"cipher\",\n  \"gatewright\"\n]);\n\ntype AxialCoord = {\n  q: number;\n  r: number;\n};\n\nconst HEX_DIRS: AxialCoord[] = [\n  { q: 1, r: 0 },\n  { q: 1, r: -1 },\n  { q: 0, r: -1 },\n  { q: -1, r: 0 },\n  { q: -1, r: 1 },\n  { q: 0, r: 1 }\n];\n\nconst parseHexKey = (key: string): AxialCoord => {\n  const parts = key.split(\",\");\n  if (parts.length !== 2) {\n    throw new Error(\"hex key must be in the form q,r\");\n  }\n  const q = Number(parts[0]);\n  const r = Number(parts[1]);\n  if (!Number.isInteger(q) || !Number.isInteger(r)) {\n    throw new Error(\"hex key coordinates must be integers\");\n  }\n  return { q, r };\n};\n\nconst toHexKey = (coord: AxialCoord): string => `${coord.q},${coord.r}`;\n\nconst axialDistance = (a: AxialCoord, b: AxialCoord): number => {\n  const dq = a.q - b.q;\n  const dr = a.r - b.r;\n  return (Math.abs(dq) + Math.abs(dr) + Math.abs(dq + dr)) / 2;\n};\n\nconst neighborHexKeys = (key: string): string[] => {\n  const coord = parseHexKey(key);\n  return HEX_DIRS.map((dir) => toHexKey({ q: coord.q + dir.q, r: coord.r + dir.r }));\n};\n\nconst pickCapitalSlot = (block: Extract<BlockState, { type: \"setup.capitalDraft\" }>): string => {\n  const taken = new Set(\n    Object.values(block.payload.choices).filter((hexKey): hexKey is string => Boolean(hexKey))\n  );\n  const available = block.payload.availableSlots.find((hexKey) => !taken.has(hexKey));\n  if (!available) {\n    throw new Error(\"no available capital slots\");\n  }\n  return available;\n};\n\nconst getStartingBridgeOptions = (state: GameState, playerId: PlayerID): string[] => {\n  const player = state.players.find((entry) => entry.id === playerId);\n  if (!player?.capitalHex) {\n    throw new Error(\"player has no capital for starting bridges\");\n  }\n  const capitalCoord = parseHexKey(player.capitalHex);\n  const candidates = new Set<string>();\n\n  for (const hexKey of Object.keys(state.board.hexes)) {\n    const coord = parseHexKey(hexKey);\n    if (axialDistance(coord, capitalCoord) > 2) {\n      continue;\n    }\n    for (const neighborKey of neighborHexKeys(hexKey)) {\n      if (!state.board.hexes[neighborKey]) {\n        continue;\n      }\n      candidates.add(getBridgeKey(hexKey, neighborKey));\n    }\n  }\n\n  return Array.from(candidates).sort();\n};\n\nconst pickStartingBridge = (\n  state: GameState,\n  block: Extract<BlockState, { type: \"setup.startingBridges\" }>,\n  playerId: PlayerID\n): string => {\n  const placed = new Set(block.payload.selectedEdges[playerId] ?? []);\n  const options = getStartingBridgeOptions(state, playerId);\n  const edgeKey = options.find((candidate) => !placed.has(candidate));\n  if (!edgeKey) {\n    throw new Error(\"no available starting bridge edges\");\n  }\n  return edgeKey;\n};\n\nconst pickFreeStartingCard = (\n  block: Extract<BlockState, { type: \"setup.freeStartingCardPick\" }>,\n  playerId: PlayerID\n): string => {\n  const offers = block.payload.offers[playerId];\n  if (!offers || offers.length === 0) {\n    throw new Error(\"no free starting card offer available\");\n  }\n  return offers[0];\n};\n\nconst buildAutoSetupChoice = (\n  state: GameState\n): { playerId: PlayerID; choice: SetupChoice } => {\n  const block = state.blocks;\n  if (!block || block.type === \"actionStep.declarations\") {\n    throw new Error(\"no setup block available\");\n  }\n  const playerId = block.waitingFor[0];\n  if (!playerId) {\n    throw new Error(\"no player awaiting setup choice\");\n  }\n\n  if (block.type === \"setup.capitalDraft\") {\n    return {\n      playerId,\n      choice: { kind: \"pickCapital\", hexKey: pickCapitalSlot(block) }\n    };\n  }\n\n  if (block.type === \"setup.startingBridges\") {\n    return {\n      playerId,\n      choice: {\n        kind: \"placeStartingBridge\",\n        edgeKey: pickStartingBridge(state, block, playerId)\n      }\n    };\n  }\n\n  if (block.type === \"setup.freeStartingCardPick\") {\n    return {\n      playerId,\n      choice: {\n        kind: \"pickFreeStartingCard\",\n        cardId: pickFreeStartingCard(block, playerId)\n      }\n    };\n  }\n\n  throw new Error(\"unsupported setup block\");\n};\n\nconst runAutoSetup = (state: GameState): GameState => {\n  let nextState = runUntilBlocked(state);\n  for (let step = 0; step < 200; step += 1) {\n    if (nextState.phase !== \"setup\") {\n      return nextState;\n    }\n    if (!nextState.blocks || nextState.blocks.waitingFor.length === 0) {\n      if (nextState.blocks && nextState.blocks.waitingFor.length === 0) {\n        const hostId = nextState.players.find((player) => player.seatIndex === 0)?.id;\n        if (!hostId) {\n          throw new Error(\"no host available to advance setup\");\n        }\n        nextState = applyCommand(nextState, { type: \"AdvanceSetup\" }, hostId);\n      }\n      nextState = runUntilBlocked(nextState);\n      continue;\n    }\n\n    const { playerId, choice } = buildAutoSetupChoice(nextState);\n    nextState = applyCommand(\n      nextState,\n      { type: \"SubmitSetupChoice\", payload: choice },\n      playerId\n    );\n    nextState = runUntilBlocked(nextState);\n  }\n\n  throw new Error(\"auto-setup exceeded step limit\");\n};\n\nconst buildDebugCollectionChoices = (\n  state: GameState,\n  playerId: PlayerID,\n  prompts: CollectionPrompt[]\n): CollectionChoice[] | null => {\n  const player = state.players.find((entry) => entry.id === playerId);\n  const hand = player?.deck.hand ?? [];\n\n  const choices = prompts.map((prompt) => {\n    if (prompt.kind === \"forge\") {\n      if (hand.length > 0) {\n        return {\n          kind: \"forge\",\n          hexKey: prompt.hexKey,\n          choice: \"reforge\",\n          scrapCardId: hand[0]\n        };\n      }\n      if (prompt.revealed.length > 0) {\n        return {\n          kind: \"forge\",\n          hexKey: prompt.hexKey,\n          choice: \"draft\",\n          cardId: prompt.revealed[0]\n        };\n      }\n      return null;\n    }\n\n    if (prompt.revealed.length > 0) {\n      return {\n        kind: \"center\",\n        hexKey: prompt.hexKey,\n        cardId: prompt.revealed[0]\n      };\n    }\n\n    return null;\n  });\n\n  if (choices.some((choice) => choice === null)) {\n    return null;\n  }\n\n  return choices as CollectionChoice[];\n};\n\nconst resolveDebugBlock = (state: GameState): GameState => {\n  const block = state.blocks;\n  if (!block) {\n    return state;\n  }\n\n  if (block.type.startsWith(\"setup.\")) {\n    return runAutoSetup(state);\n  }\n\n  if (block.type === \"actionStep.declarations\") {\n    let nextState = state;\n    for (const playerId of block.waitingFor) {\n      nextState = applyCommand(\n        nextState,\n        { type: \"SubmitAction\", payload: { kind: \"done\" } },\n        playerId\n      );\n    }\n    return nextState;\n  }\n\n  if (block.type === \"market.bidsForCard\") {\n    let nextState = state;\n    for (const playerId of block.waitingFor) {\n      nextState = applyCommand(\n        nextState,\n        { type: \"SubmitMarketBid\", payload: { kind: \"pass\", amount: 0 } },\n        playerId\n      );\n    }\n    return nextState;\n  }\n\n  if (block.type === \"market.rollOff\") {\n    let nextState = state;\n    for (const playerId of block.waitingFor) {\n      nextState = applyCommand(nextState, { type: \"SubmitMarketRollOff\" }, playerId);\n    }\n    return nextState;\n  }\n\n  if (block.type === \"collection.choices\") {\n    let nextState = state;\n    for (const playerId of block.waitingFor) {\n      const prompts = block.payload.prompts[playerId] ?? [];\n      const choices = buildDebugCollectionChoices(nextState, playerId, prompts);\n      if (!choices) {\n        continue;\n      }\n      nextState = applyCommand(\n        nextState,\n        { type: \"SubmitCollectionChoices\", payload: choices },\n        playerId\n      );\n    }\n    return nextState;\n  }\n\n  return state;\n};\n\nconst advanceToNextPhaseDebug = (state: GameState): GameState => {\n  const startPhase = state.phase;\n  let nextState = state;\n\n  for (let step = 0; step < 100; step += 1) {\n    nextState = runUntilBlocked(nextState);\n    if (nextState.phase !== startPhase) {\n      return nextState;\n    }\n    if (!nextState.blocks) {\n      return nextState;\n    }\n    const resolved = resolveDebugBlock(nextState);\n    if (resolved === nextState) {\n      return nextState;\n    }\n    nextState = resolved;\n  }\n\n  return nextState;\n};\n\ntype PatchPathToken = string | number;\n\nconst parsePatchPath = (path: string): PatchPathToken[] | null => {\n  const trimmed = path.trim();\n  if (!trimmed) {\n    return null;\n  }\n  const normalized = trimmed.replace(/\\[(\\d+)\\]/g, \".$1\").replace(/^\\./, \"\");\n  const parts = normalized.split(\".\").filter((part) => part.length > 0);\n  if (parts.length === 0) {\n    return null;\n  }\n  return parts.map((part) => (/^\\d+$/.test(part) ? Number(part) : part));\n};\n\nconst setValueAtPath = (\n  current: unknown,\n  tokens: PatchPathToken[],\n  value: unknown\n): unknown => {\n  if (tokens.length === 0) {\n    return value;\n  }\n  const [head, ...rest] = tokens;\n  const key = String(head);\n  const nextCurrent =\n    current && typeof current === \"object\" ? (current as Record<string, unknown>)[key] : undefined;\n  const nextValue = setValueAtPath(nextCurrent, rest, value);\n  const shouldUseArray = Array.isArray(current) || (!current && typeof head === \"number\");\n\n  if (shouldUseArray) {\n    const copy = Array.isArray(current) ? [...current] : [];\n    if (typeof head === \"number\") {\n      copy[head] = nextValue;\n      return copy;\n    }\n    (copy as unknown as Record<string, unknown>)[key] = nextValue;\n    return copy;\n  }\n\n  const base =\n    current && typeof current === \"object\" && !Array.isArray(current)\n      ? (current as Record<string, unknown>)\n      : {};\n  return {\n    ...base,\n    [key]: nextValue\n  };\n};\n\nconst applyStatePatch = (\n  state: GameState,\n  path: string,\n  value: unknown\n): GameState | null => {\n  const tokens = parsePatchPath(path);\n  if (!tokens) {\n    return null;\n  }\n  const nextState = setValueAtPath(state, tokens, value);\n  if (!nextState || typeof nextState !== \"object\") {\n    return null;\n  }\n  return nextState as GameState;\n};\n\nconst readRecord = (value: unknown): Record<string, unknown> | null => {\n  if (!value || typeof value !== \"object\" || Array.isArray(value)) {\n    return null;\n  }\n  return value as Record<string, unknown>;\n};\n\nconst readString = (value: unknown): string | null => {\n  return typeof value === \"string\" ? value : null;\n};\n\nconst buildCombatSequenceId = (hexKey: string, startIndex: number) =>\n  `${hexKey}-${startIndex}`;\n\nconst safeParseMessage = (message: string): ClientMessage | null => {\n  try {\n    const parsed = JSON.parse(message);\n    if (!parsed || typeof parsed !== \"object\") {\n      return null;\n    }\n    if (\n      parsed.type === \"join\" ||\n      parsed.type === \"command\" ||\n      parsed.type === \"lobbyCommand\" ||\n      parsed.type === \"debugCommand\" ||\n      parsed.type === \"combatCommand\"\n    ) {\n      return parsed as ClientMessage;\n    }\n  } catch {\n    return null;\n  }\n  return null;\n};\n\nconst createRejoinToken = (): string => {\n  if (typeof crypto !== \"undefined\" && \"randomUUID\" in crypto) {\n    return crypto.randomUUID();\n  }\n  return `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 10)}`;\n};\n\nexport default class Server implements Party.Server {\n  private lobbyPlayers: LobbyPlayer[] = [];\n  private state: GameState | null = null;\n  private lastLogCount = 0;\n  private rejoinTokens = new Map<string, PlayerID>();\n  private playerConnections = new Map<PlayerID, number>();\n  private combatSyncById = new Map<string, CombatSyncState>();\n  private combatSyncOrder: string[] = [];\n\n  constructor(readonly room: Party.Room) {}\n\n  private send(connection: Party.Connection, payload: Record<string, unknown>) {\n    connection.send(JSON.stringify(payload));\n  }\n\n  private sendError(connection: Party.Connection, message: string) {\n    this.send(connection, { type: \"error\", message });\n  }\n\n  private resetCombatSync(): void {\n    this.combatSyncById.clear();\n    this.combatSyncOrder = [];\n  }\n\n  private getCombatSyncSnapshot(): Record<string, CombatSyncState> {\n    return Object.fromEntries(this.combatSyncById.entries());\n  }\n\n  private trackCombatEvents(events: GameEvent[], startIndex: number): void {\n    for (let index = 0; index < events.length; index += 1) {\n      const event = events[index];\n      if (event.type !== \"combat.start\") {\n        continue;\n      }\n      const payload = readRecord(event.payload) ?? {};\n      const hexKey = readString(payload.hexKey);\n      const attackers = readRecord(payload.attackers);\n      const defenders = readRecord(payload.defenders);\n      const attackerId = readString(attackers?.playerId);\n      const defenderId = readString(defenders?.playerId);\n      if (!hexKey || !attackerId || !defenderId) {\n        continue;\n      }\n      const sequenceId = buildCombatSequenceId(hexKey, startIndex + index);\n      if (this.combatSyncById.has(sequenceId)) {\n        continue;\n      }\n      const playerIds = [attackerId, defenderId];\n      const readyByPlayerId = Object.fromEntries(\n        playerIds.map((playerId) => [playerId, false])\n      );\n      const sync: CombatSyncState = {\n        sequenceId,\n        playerIds,\n        roundIndex: 0,\n        readyByPlayerId,\n        phaseStartAt: null,\n        stage: \"idle\"\n      };\n      this.combatSyncById.set(sequenceId, sync);\n      this.combatSyncOrder.push(sequenceId);\n      if (this.combatSyncOrder.length > MAX_COMBAT_SYNC) {\n        const removed = this.combatSyncOrder.shift();\n        if (removed) {\n          this.combatSyncById.delete(removed);\n        }\n      }\n    }\n  }\n\n  private getConnectionState(connection: Party.Connection): ConnectionState | null {\n    const state = connection.state as ConnectionState | undefined;\n    if (!state || !state.playerId) {\n      return null;\n    }\n    return state;\n  }\n\n  private setConnectionState(connection: Party.Connection, state: ConnectionState) {\n    connection.setState(state);\n  }\n\n  private markPlayerConnected(playerId: PlayerID, connected: boolean): void {\n    if (!this.state) {\n      return;\n    }\n    const player = this.state.players.find((entry) => entry.id === playerId);\n    if (!player || player.visibility.connected === connected) {\n      return;\n    }\n    this.state = {\n      ...this.state,\n      players: this.state.players.map((entry) =>\n        entry.id === playerId\n          ? { ...entry, visibility: { ...entry.visibility, connected } }\n          : entry\n      )\n    };\n    this.bumpRevision();\n  }\n\n  private bumpRevision(): void {\n    if (!this.state) {\n      return;\n    }\n    this.state = {\n      ...this.state,\n      revision: this.state.revision + 1\n    };\n  }\n\n  private createMapSeed(): number {\n    return Math.floor(Math.random() * 0xffffffff);\n  }\n\n  private isDebugAllowed(): boolean {\n    const env = this.room.env as Record<string, string> | undefined;\n    const nodeEnv = env?.NODE_ENV ?? process.env.NODE_ENV;\n    return nodeEnv !== \"production\";\n  }\n\n  private getHostPlayerId(): PlayerID | null {\n    if (this.state) {\n      return this.state.players.find((player) => player.seatIndex === 0)?.id ?? null;\n    }\n    return this.lobbyPlayers[0]?.id ?? null;\n  }\n\n  private collectEvents(): GameEvent[] {\n    if (!this.state) {\n      return [];\n    }\n    const logs = this.state.logs;\n    const logsShrunk = logs.length < this.lastLogCount;\n    const startIndex = logsShrunk ? 0 : this.lastLogCount;\n    let events: GameEvent[] = [];\n    if (this.lastLogCount === 0 || logsShrunk) {\n      events = logs;\n    } else {\n      events = logs.slice(this.lastLogCount);\n    }\n    this.lastLogCount = logs.length;\n    if (logsShrunk) {\n      this.resetCombatSync();\n    }\n    if (events.length > 0) {\n      this.trackCombatEvents(events, startIndex);\n    }\n    return events;\n  }\n\n  private broadcastUpdate(events: GameEvent[] = []): void {\n    if (!this.state) {\n      return;\n    }\n    const serverTime = Date.now();\n    const combatSync = this.getCombatSyncSnapshot();\n    for (const connection of this.room.getConnections()) {\n      const meta = this.getConnectionState(connection);\n      const viewerId = meta && !meta.spectator ? meta.playerId : null;\n      const view = buildView(this.state, viewerId);\n      this.send(connection, {\n        type: \"update\",\n        revision: this.state.revision,\n        events,\n        view,\n        serverTime,\n        combatSync\n      });\n    }\n  }\n\n  private getLobbySnapshot(): LobbySnapshot {\n    const players = this.lobbyPlayers.map((player, index) => ({\n      id: player.id,\n      name: player.name,\n      seatIndex: index,\n      connected: (this.playerConnections.get(player.id) ?? 0) > 0,\n      factionId: player.factionId ?? null\n    }));\n    return {\n      players,\n      minPlayers: MIN_PLAYERS,\n      maxPlayers: MAX_PLAYERS\n    };\n  }\n\n  private broadcastLobby(): void {\n    if (this.state) {\n      return;\n    }\n    const lobby = this.getLobbySnapshot();\n    for (const connection of this.room.getConnections()) {\n      this.send(connection, { type: \"lobby\", lobby });\n    }\n  }\n\n  private syncLobbySeatIndices(): void {\n    const seatIndexById = new Map(\n      this.lobbyPlayers.map((player, index) => [player.id, index])\n    );\n    for (const connection of this.room.getConnections()) {\n      const meta = this.getConnectionState(connection);\n      if (!meta || meta.spectator) {\n        continue;\n      }\n      const seatIndex = seatIndexById.get(meta.playerId);\n      if (seatIndex === undefined || meta.seatIndex === seatIndex) {\n        continue;\n      }\n      this.setConnectionState(connection, { ...meta, seatIndex });\n    }\n  }\n\n  private pruneDisconnectedLobbyPlayers(): void {\n    if (this.state) {\n      return;\n    }\n    const activeIds = new Set(\n      this.lobbyPlayers\n        .filter((player) => (this.playerConnections.get(player.id) ?? 0) > 0)\n        .map((player) => player.id)\n    );\n    if (activeIds.size === this.lobbyPlayers.length) {\n      return;\n    }\n    const removedIds = new Set(\n      this.lobbyPlayers.filter((player) => !activeIds.has(player.id)).map((player) => player.id)\n    );\n    this.lobbyPlayers = this.lobbyPlayers.filter((player) => activeIds.has(player.id));\n    for (const [token, playerId] of this.rejoinTokens.entries()) {\n      if (removedIds.has(playerId)) {\n        this.rejoinTokens.delete(token);\n      }\n    }\n    this.syncLobbySeatIndices();\n  }\n\n  private removeLobbyPlayer(playerId: PlayerID): void {\n    if (this.state) {\n      return;\n    }\n    if ((this.playerConnections.get(playerId) ?? 0) > 0) {\n      return;\n    }\n    if (!this.lobbyPlayers.some((player) => player.id === playerId)) {\n      return;\n    }\n    this.lobbyPlayers = this.lobbyPlayers.filter((player) => player.id !== playerId);\n    for (const [token, tokenPlayerId] of this.rejoinTokens.entries()) {\n      if (tokenPlayerId === playerId) {\n        this.rejoinTokens.delete(token);\n      }\n    }\n    this.syncLobbySeatIndices();\n  }\n\n  private nextPlayerId(): PlayerID {\n    const used = new Set(this.lobbyPlayers.map((player) => player.id));\n    let index = 1;\n    while (used.has(`p${index}`)) {\n      index += 1;\n    }\n    return `p${index}`;\n  }\n\n  private startGameFromLobby(): void {\n    if (this.state) {\n      return;\n    }\n    if (this.lobbyPlayers.length < MIN_PLAYERS) {\n      return;\n    }\n    const seed = this.createMapSeed();\n    let nextState = runUntilBlocked(createNewGame(DEFAULT_CONFIG, seed, this.lobbyPlayers));\n    nextState = {\n      ...nextState,\n      players: nextState.players.map((player) => ({\n        ...player,\n        visibility: {\n          connected: (this.playerConnections.get(player.id) ?? 0) > 0\n        }\n      }))\n    };\n    this.state = nextState;\n    this.bumpRevision();\n    this.lastLogCount = this.state.logs.length;\n    this.resetCombatSync();\n  }\n\n  private registerPlayerConnection(playerId: PlayerID): void {\n    const count = (this.playerConnections.get(playerId) ?? 0) + 1;\n    this.playerConnections.set(playerId, count);\n    if (count === 1) {\n      this.markPlayerConnected(playerId, true);\n      if (!this.state) {\n        this.broadcastLobby();\n      }\n    }\n  }\n\n  private unregisterPlayerConnection(playerId: PlayerID): void {\n    const count = (this.playerConnections.get(playerId) ?? 0) - 1;\n    if (count > 0) {\n      this.playerConnections.set(playerId, count);\n      return;\n    }\n    this.playerConnections.delete(playerId);\n    this.markPlayerConnected(playerId, false);\n    if (!this.state) {\n      this.broadcastLobby();\n    }\n  }\n\n  private handleJoin(message: JoinMessage, connection: Party.Connection): void {\n    if (this.getConnectionState(connection)) {\n      this.sendError(connection, \"connection already joined\");\n      return;\n    }\n\n    const requestedToken = message.rejoinToken;\n    const allowSpectator = Boolean(message.asSpectator);\n\n    if (requestedToken && this.rejoinTokens.has(requestedToken)) {\n      const playerId = this.rejoinTokens.get(requestedToken) as PlayerID;\n      const seatIndex = this.state\n        ? this.state.players.findIndex((player) => player.id === playerId)\n        : this.lobbyPlayers.findIndex((player) => player.id === playerId);\n      if (seatIndex === -1) {\n        this.sendError(connection, \"rejoin token is no longer valid\");\n        return;\n      }\n      this.setConnectionState(connection, {\n        playerId,\n        seatIndex,\n        spectator: false,\n        rejoinToken: requestedToken\n      });\n      this.registerPlayerConnection(playerId);\n      const view = this.state ? buildView(this.state, playerId) : null;\n      this.send(connection, {\n        type: \"welcome\",\n        playerId,\n        seatIndex,\n        rejoinToken: requestedToken,\n        view\n      });\n      if (this.state) {\n        this.broadcastUpdate();\n      } else {\n        this.broadcastLobby();\n      }\n      return;\n    }\n\n    if (this.state) {\n      if (allowSpectator) {\n        this.setConnectionState(connection, {\n          playerId: `spectator:${connection.id}`,\n          seatIndex: null,\n          spectator: true\n        });\n        const view = buildView(this.state, null);\n        this.send(connection, {\n          type: \"welcome\",\n          playerId: `spectator:${connection.id}`,\n          seatIndex: null,\n          rejoinToken: null,\n          view\n        });\n        return;\n      }\n      this.sendError(connection, \"game already started; join as spectator or use a rejoin token\");\n      return;\n    }\n\n    this.pruneDisconnectedLobbyPlayers();\n\n    if (this.lobbyPlayers.length >= MAX_PLAYERS) {\n      this.sendError(connection, \"lobby is full\");\n      return;\n    }\n\n    const seatIndex = this.lobbyPlayers.length;\n    const playerId = this.nextPlayerId();\n    const name =\n      typeof message.name === \"string\" && message.name.trim().length > 0\n        ? message.name.trim()\n        : `Player ${seatIndex + 1}`;\n    this.lobbyPlayers.push({ id: playerId, name });\n    const token = createRejoinToken();\n    this.rejoinTokens.set(token, playerId);\n    this.setConnectionState(connection, {\n      playerId,\n      seatIndex,\n      spectator: false,\n      rejoinToken: token\n    });\n    this.registerPlayerConnection(playerId);\n    const view = this.state ? buildView(this.state, playerId) : null;\n    this.send(connection, {\n      type: \"welcome\",\n      playerId,\n      seatIndex,\n      rejoinToken: token,\n      view,\n      serverTime: Date.now(),\n      combatSync: this.getCombatSyncSnapshot()\n    });\n    if (this.state) {\n      this.broadcastUpdate();\n    } else {\n      this.broadcastLobby();\n    }\n  }\n\n  private handleCommand(message: CommandMessage, connection: Party.Connection): void {\n    if (!this.state) {\n      this.sendError(connection, \"game has not started\");\n      return;\n    }\n    const meta = this.getConnectionState(connection);\n    if (!meta || meta.spectator) {\n      this.sendError(connection, \"spectators cannot send commands\");\n      return;\n    }\n    if (message.playerId !== meta.playerId) {\n      this.sendError(connection, \"player id does not match connection\");\n      return;\n    }\n\n    try {\n      const applied = applyCommand(this.state, message.command, message.playerId);\n      const advanced = runUntilBlocked(applied);\n      this.state = {\n        ...advanced,\n        revision: this.state.revision + 1\n      };\n      const events = this.collectEvents();\n      this.broadcastUpdate(events);\n    } catch (error) {\n      const reason = error instanceof Error ? error.message : \"command rejected\";\n      this.sendError(connection, reason);\n    }\n  }\n\n  private handleCombatCommand(\n    message: CombatCommandMessage,\n    connection: Party.Connection\n  ): void {\n    if (!this.state) {\n      this.sendError(connection, \"game has not started\");\n      return;\n    }\n    const meta = this.getConnectionState(connection);\n    if (!meta || meta.spectator) {\n      this.sendError(connection, \"spectators cannot send combat commands\");\n      return;\n    }\n    if (message.playerId !== meta.playerId) {\n      this.sendError(connection, \"player id does not match connection\");\n      return;\n    }\n\n    const sequenceId =\n      typeof message.sequenceId === \"string\" ? message.sequenceId.trim() : \"\";\n    const roundIndex =\n      typeof message.roundIndex === \"number\" && Number.isFinite(message.roundIndex)\n        ? message.roundIndex\n        : -1;\n    if (!sequenceId || roundIndex < 0) {\n      this.sendError(connection, \"invalid combat command\");\n      return;\n    }\n    const sync = this.combatSyncById.get(sequenceId);\n    if (!sync) {\n      this.sendError(connection, \"combat sequence not found\");\n      return;\n    }\n    if (!sync.playerIds.includes(meta.playerId)) {\n      this.sendError(connection, \"player not in this combat\");\n      return;\n    }\n\n    const now = Date.now();\n    const rollDoneMs = this.state.config.COMBAT_ROLL_DONE_MS ?? COMBAT_ROLL_DONE_MS;\n    const stage = sync.stage ?? \"idle\";\n    if (roundIndex < sync.roundIndex) {\n      this.sendError(connection, \"combat round already resolved\");\n      return;\n    }\n    if (roundIndex > sync.roundIndex + 1) {\n      this.sendError(connection, \"combat round out of range\");\n      return;\n    }\n\n    const rollElapsed =\n      stage === \"rolling\" && sync.phaseStartAt ? now - sync.phaseStartAt : null;\n    const rollDone = rollElapsed !== null && rollElapsed >= rollDoneMs;\n\n    if (roundIndex > sync.roundIndex) {\n      if (stage !== \"assigned\") {\n        this.sendError(connection, \"combat round is still resolving\");\n        return;\n      }\n      sync.roundIndex = roundIndex;\n      sync.stage = \"idle\";\n      sync.phaseStartAt = null;\n      sync.readyByPlayerId = Object.fromEntries(\n        sync.playerIds.map((playerId) => [playerId, false])\n      );\n    } else if (stage === \"idle\") {\n      sync.readyByPlayerId[meta.playerId] = true;\n      const allReady = sync.playerIds.every(\n        (playerId) => sync.readyByPlayerId[playerId]\n      );\n      if (allReady) {\n        sync.stage = \"rolling\";\n        sync.phaseStartAt = now;\n        sync.readyByPlayerId = Object.fromEntries(\n          sync.playerIds.map((playerId) => [playerId, false])\n        );\n      }\n    } else if (stage === \"rolling\") {\n      if (!rollDone) {\n        this.sendError(connection, \"combat round is still resolving\");\n        return;\n      }\n      sync.readyByPlayerId[meta.playerId] = true;\n      const allReady = sync.playerIds.every(\n        (playerId) => sync.readyByPlayerId[playerId]\n      );\n      if (allReady) {\n        sync.stage = \"assigned\";\n        sync.phaseStartAt = null;\n        sync.readyByPlayerId = Object.fromEntries(\n          sync.playerIds.map((playerId) => [playerId, false])\n        );\n      }\n    } else {\n      sync.readyByPlayerId[meta.playerId] = true;\n      const allReady = sync.playerIds.every(\n        (playerId) => sync.readyByPlayerId[playerId]\n      );\n      if (allReady) {\n        sync.roundIndex += 1;\n        sync.stage = \"idle\";\n        sync.phaseStartAt = null;\n        sync.readyByPlayerId = Object.fromEntries(\n          sync.playerIds.map((playerId) => [playerId, false])\n        );\n      }\n    }\n\n    this.combatSyncById.set(sequenceId, sync);\n    this.broadcastUpdate();\n  }\n\n  private handleLobbyCommand(\n    message: LobbyCommandMessage,\n    connection: Party.Connection\n  ): void {\n    if (message.command === \"startGame\") {\n      this.handleStartGame(message, connection);\n      return;\n    }\n    if (message.command === \"autoSetup\") {\n      this.handleAutoSetup(message, connection);\n      return;\n    }\n    if (message.command === \"pickFaction\") {\n      this.handlePickFaction(message, connection);\n      return;\n    }\n    if (message.command === \"rerollMap\") {\n      this.handleRerollMap(message, connection);\n      return;\n    }\n    if (message.command === \"rollDice\") {\n      this.handleRollDice(message, connection);\n    }\n  }\n\n  private handleDebugCommand(\n    message: DebugCommandMessage,\n    connection: Party.Connection\n  ): void {\n    if (!this.isDebugAllowed()) {\n      this.sendError(connection, \"debug commands are disabled\");\n      return;\n    }\n    const meta = this.getConnectionState(connection);\n    if (!meta || meta.spectator) {\n      this.sendError(connection, \"spectators cannot send debug commands\");\n      return;\n    }\n    if (message.playerId !== meta.playerId) {\n      this.sendError(connection, \"player id does not match connection\");\n      return;\n    }\n    const hostId = this.getHostPlayerId();\n    if (!hostId || hostId !== meta.playerId) {\n      this.sendError(connection, \"only the host can use debug commands\");\n      return;\n    }\n\n    if (message.command === \"state\") {\n      if (!this.state) {\n        this.sendError(connection, \"game has not started\");\n        return;\n      }\n      this.send(connection, { type: \"debugState\", state: this.state });\n      return;\n    }\n\n    if (message.command === \"advancePhase\") {\n      if (!this.state) {\n        this.sendError(connection, \"game has not started\");\n        return;\n      }\n      const nextState = advanceToNextPhaseDebug(this.state);\n      this.state = {\n        ...nextState,\n        revision: this.state.revision + 1\n      };\n      const events = this.collectEvents();\n      this.broadcastUpdate(events);\n      return;\n    }\n\n    if (message.command === \"patchState\") {\n      if (!this.state) {\n        this.sendError(connection, \"game has not started\");\n        return;\n      }\n      const path = typeof message.path === \"string\" ? message.path.trim() : \"\";\n      if (!path) {\n        this.sendError(connection, \"patchState requires a non-empty path\");\n        return;\n      }\n      const nextState = applyStatePatch(this.state, path, message.value);\n      if (!nextState) {\n        this.sendError(connection, \"patchState could not apply path\");\n        return;\n      }\n      this.state = {\n        ...nextState,\n        revision: this.state.revision + 1\n      };\n      const events = this.collectEvents();\n      this.broadcastUpdate(events);\n      return;\n    }\n\n    if (message.command === \"resetGame\") {\n      const lobbyPlayers = this.state\n        ? [...this.state.players]\n            .sort((a, b) => a.seatIndex - b.seatIndex)\n            .map((player) => ({ id: player.id, name: player.name, factionId: player.factionId }))\n        : [...this.lobbyPlayers];\n      if (lobbyPlayers.length < MIN_PLAYERS) {\n        this.sendError(connection, `need at least ${MIN_PLAYERS} players to reset`);\n        return;\n      }\n      const seed =\n        typeof message.seed === \"number\" && Number.isFinite(message.seed)\n          ? message.seed\n          : this.createMapSeed();\n      const config = this.state?.config ?? DEFAULT_CONFIG;\n      let nextState = runUntilBlocked(createNewGame(config, seed, lobbyPlayers));\n      nextState = {\n        ...nextState,\n        players: nextState.players.map((player) => ({\n          ...player,\n          visibility: {\n            connected: (this.playerConnections.get(player.id) ?? 0) > 0\n          }\n        }))\n      };\n      const nextRevision = (this.state?.revision ?? 0) + 1;\n      this.state = { ...nextState, revision: nextRevision };\n      this.lastLogCount = this.state.logs.length;\n      this.resetCombatSync();\n      this.broadcastUpdate();\n      return;\n    }\n  }\n\n  private handleStartGame(\n    message: LobbyCommandMessage,\n    connection: Party.Connection\n  ): void {\n    if (this.state) {\n      this.sendError(connection, \"game already started\");\n      return;\n    }\n    const meta = this.getConnectionState(connection);\n    if (!meta || meta.spectator) {\n      this.sendError(connection, \"spectators cannot start the game\");\n      return;\n    }\n    if (message.playerId !== meta.playerId) {\n      this.sendError(connection, \"player id does not match connection\");\n      return;\n    }\n    const hostId = this.lobbyPlayers[0]?.id ?? null;\n    if (!hostId || hostId !== meta.playerId) {\n      this.sendError(connection, \"only the host can start the game\");\n      return;\n    }\n    if (this.lobbyPlayers.length < MIN_PLAYERS) {\n      this.sendError(connection, `need at least ${MIN_PLAYERS} players to start`);\n      return;\n    }\n    if (this.lobbyPlayers.some((player) => !player.factionId)) {\n      this.sendError(connection, \"all players must pick a faction before starting\");\n      return;\n    }\n    const uniqueFactions = new Set<string>();\n    for (const player of this.lobbyPlayers) {\n      if (!player.factionId) {\n        continue;\n      }\n      if (uniqueFactions.has(player.factionId)) {\n        this.sendError(connection, \"factions must be unique before starting\");\n        return;\n      }\n      uniqueFactions.add(player.factionId);\n    }\n\n    this.startGameFromLobby();\n    if (!this.state) {\n      this.sendError(connection, \"failed to start game\");\n      return;\n    }\n    this.broadcastUpdate();\n  }\n\n  private handlePickFaction(\n    message: LobbyCommandMessage,\n    connection: Party.Connection\n  ): void {\n    if (this.state) {\n      this.sendError(connection, \"game already started\");\n      return;\n    }\n    const meta = this.getConnectionState(connection);\n    if (!meta || meta.spectator) {\n      this.sendError(connection, \"spectators cannot pick a faction\");\n      return;\n    }\n    if (message.playerId !== meta.playerId) {\n      this.sendError(connection, \"player id does not match connection\");\n      return;\n    }\n    const rawFactionId =\n      typeof message.factionId === \"string\" ? message.factionId.trim() : \"\";\n    if (!rawFactionId) {\n      this.sendError(connection, \"missing faction id\");\n      return;\n    }\n    const normalized = rawFactionId.toLowerCase();\n    if (!FACTION_IDS.has(normalized)) {\n      this.sendError(connection, \"unknown faction id\");\n      return;\n    }\n    const player = this.lobbyPlayers.find((entry) => entry.id === meta.playerId);\n    if (!player) {\n      this.sendError(connection, \"player not found in lobby\");\n      return;\n    }\n    const claimedBy = this.lobbyPlayers.find(\n      (entry) => entry.factionId === normalized && entry.id !== meta.playerId\n    );\n    if (claimedBy) {\n      this.sendError(connection, `faction already claimed by ${claimedBy.name}`);\n      return;\n    }\n    player.factionId = normalized;\n    this.broadcastLobby();\n  }\n\n  private handleAutoSetup(\n    message: LobbyCommandMessage,\n    connection: Party.Connection\n  ): void {\n    if (!this.state) {\n      this.sendError(connection, \"game has not started\");\n      return;\n    }\n    if (this.state.phase !== \"setup\") {\n      this.sendError(connection, \"auto-setup is only available during setup\");\n      return;\n    }\n    const meta = this.getConnectionState(connection);\n    if (!meta || meta.spectator) {\n      this.sendError(connection, \"spectators cannot run auto-setup\");\n      return;\n    }\n    if (message.playerId !== meta.playerId) {\n      this.sendError(connection, \"player id does not match connection\");\n      return;\n    }\n    const hostId = this.state.players.find((player) => player.seatIndex === 0)?.id;\n    if (!hostId || hostId !== meta.playerId) {\n      this.sendError(connection, \"only the host can run auto-setup\");\n      return;\n    }\n\n    try {\n      const nextState = runAutoSetup(this.state);\n      this.state = {\n        ...nextState,\n        revision: this.state.revision + 1\n      };\n      const events = this.collectEvents();\n      this.broadcastUpdate(events);\n    } catch (error) {\n      const reason = error instanceof Error ? error.message : \"auto-setup failed\";\n      this.sendError(connection, reason);\n    }\n  }\n\n  private handleRollDice(\n    message: LobbyCommandMessage,\n    connection: Party.Connection\n  ): void {\n    if (!this.state) {\n      this.sendError(connection, \"game has not started\");\n      return;\n    }\n    if (this.state.phase !== \"setup\") {\n      this.sendError(connection, \"dice rolls are only available during the lobby\");\n      return;\n    }\n    const meta = this.getConnectionState(connection);\n    if (!meta || meta.spectator) {\n      this.sendError(connection, \"spectators cannot roll the dice\");\n      return;\n    }\n    if (message.playerId !== meta.playerId) {\n      this.sendError(connection, \"player id does not match connection\");\n      return;\n    }\n\n    const roll = Math.floor(Math.random() * 6) + 1;\n    const nextState = emit(this.state, {\n      type: \"lobby.diceRolled\",\n      payload: { playerId: meta.playerId, roll, sides: 6 }\n    });\n    this.state = {\n      ...nextState,\n      revision: this.state.revision + 1\n    };\n    const events = this.collectEvents();\n    this.broadcastUpdate(events);\n  }\n\n  private handleRerollMap(\n    message: LobbyCommandMessage,\n    connection: Party.Connection\n  ): void {\n    if (!this.state) {\n      this.sendError(connection, \"game has not started\");\n      return;\n    }\n    if (this.state.phase !== \"setup\") {\n      this.sendError(connection, \"map reroll is only available during setup\");\n      return;\n    }\n    const block = this.state.blocks;\n    if (!block || block.type !== \"setup.capitalDraft\") {\n      this.sendError(connection, \"map reroll is only available before capital draft starts\");\n      return;\n    }\n    if (\n      this.state.players.some((player) => player.capitalHex) ||\n      Object.values(block.payload.choices).some(Boolean)\n    ) {\n      this.sendError(connection, \"map reroll is locked after a capital is picked\");\n      return;\n    }\n    const meta = this.getConnectionState(connection);\n    if (!meta || meta.spectator) {\n      this.sendError(connection, \"spectators cannot reroll the map\");\n      return;\n    }\n    if (message.playerId !== meta.playerId) {\n      this.sendError(connection, \"player id does not match connection\");\n      return;\n    }\n    const hostId = this.state.players.find((player) => player.seatIndex === 0)?.id;\n    if (!hostId || hostId !== meta.playerId) {\n      this.sendError(connection, \"only the host can reroll the map\");\n      return;\n    }\n\n    const lobbyPlayers = [...this.state.players]\n      .sort((a, b) => a.seatIndex - b.seatIndex)\n      .map((player) => ({ id: player.id, name: player.name, factionId: player.factionId }));\n    const seed = this.createMapSeed();\n    let nextState = runUntilBlocked(\n      createNewGame(this.state.config ?? DEFAULT_CONFIG, seed, lobbyPlayers)\n    );\n    nextState = {\n      ...nextState,\n      players: nextState.players.map((player) => ({\n        ...player,\n        visibility: {\n          connected: (this.playerConnections.get(player.id) ?? 0) > 0\n        }\n      }))\n    };\n    const nextRevision = this.state.revision + 1;\n    this.state = { ...nextState, revision: nextRevision };\n    this.lastLogCount = this.state.logs.length;\n    this.resetCombatSync();\n    this.broadcastUpdate();\n  }\n\n  onConnect(connection: Party.Connection) {\n    this.send(connection, {\n      type: \"connected\",\n      roomId: this.room.id\n    });\n  }\n\n  onMessage(message: string | ArrayBuffer, sender: Party.Connection) {\n    if (typeof message !== \"string\") {\n      this.sendError(sender, \"unsupported message payload\");\n      return;\n    }\n    const parsed = safeParseMessage(message);\n    if (!parsed) {\n      this.sendError(sender, \"invalid message\");\n      return;\n    }\n    if (parsed.type === \"join\") {\n      this.handleJoin(parsed, sender);\n      return;\n    }\n    if (parsed.type === \"command\") {\n      this.handleCommand(parsed, sender);\n      return;\n    }\n    if (parsed.type === \"lobbyCommand\") {\n      this.handleLobbyCommand(parsed, sender);\n      return;\n    }\n    if (parsed.type === \"debugCommand\") {\n      this.handleDebugCommand(parsed, sender);\n      return;\n    }\n    if (parsed.type === \"combatCommand\") {\n      this.handleCombatCommand(parsed, sender);\n      return;\n    }\n  }\n\n  onClose(connection: Party.Connection) {\n    const meta = this.getConnectionState(connection);\n    if (meta && !meta.spectator) {\n      this.unregisterPlayerConnection(meta.playerId);\n      if (this.state) {\n        this.broadcastUpdate();\n        return;\n      }\n      this.removeLobbyPlayer(meta.playerId);\n      this.broadcastLobby();\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["modifier", "nextState", "unitId", "hex", "updatedBoard", "updatedState", "updatedChoices", "nextState", "rawA", "rawB", "edgeKey", "nextSelected", "nextRemaining", "nextChosen", "unitId", "addGold", "isModifierActive", "getPlayer", "addGold", "isModifierActive", "from", "to", "addGold", "hex", "state", "round", "unit", "attackerPlayerId", "defenderPlayerId", "nextState", "plan", "bridges", "getBuildBridgePlan", "nextState", "getBuildBridgePlan", "takeFromDeck", "parseHexKey", "toHexKey", "axialDistance", "neighborHexKeys", "playerId", "seatIndex", "view"]
}
